<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>疫情防控项目展示</title>
      <link href="posts/48153/"/>
      <url>posts/48153/</url>
      
        <content type="html"><![CDATA[<h1 id="疫情防控项目展示"><a href="#疫情防控项目展示" class="headerlink" title="疫情防控项目展示"></a>疫情防控项目展示</h1><h2 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h2><p>本项目主要是针对校园疫情防控，设计了三个角色：教师、学生、管理员。实现了对教师学生的管理，公告的发布，请假审批的流程，每日健康填报以及个人信息的修改等功能。</p><h2 id="项目展示"><a href="#项目展示" class="headerlink" title="项目展示"></a>项目展示</h2><h3 id="登录页面"><a href="#登录页面" class="headerlink" title="登录页面"></a>登录页面</h3><p><img src="https://img2.jimu98.cn/haley/20210307215824.jpeg" alt=""></p><h3 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h3><p><img src="https://img2.jimu98.cn/haley/20210307215909.jpeg" alt=""></p><p><img src="https://img2.jimu98.cn/haley/20210307215938.jpeg" alt=""></p><h3 id="管理员"><a href="#管理员" class="headerlink" title="管理员"></a>管理员</h3><h4 id="学生教师管理"><a href="#学生教师管理" class="headerlink" title="学生教师管理"></a>学生教师管理</h4><p><img src="https://img2.jimu98.cn/haley/20210307220012.jpeg" alt=""></p><h4 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h4><p><img src="https://img2.jimu98.cn/haley/20210307220046.jpeg" alt=""></p><h4 id="公告"><a href="#公告" class="headerlink" title="公告"></a>公告</h4><p><img src="https://img2.jimu98.cn/haley/20210307220142.jpeg" alt=""></p><h4 id="公告详情"><a href="#公告详情" class="headerlink" title="公告详情"></a>公告详情</h4><p><img src="https://img2.jimu98.cn/haley/20210307220215.jpeg" alt=""></p><h3 id="学生"><a href="#学生" class="headerlink" title="学生"></a>学生</h3><h4 id="查看公告"><a href="#查看公告" class="headerlink" title="查看公告"></a>查看公告</h4><p><img src="https://img2.jimu98.cn/haley/20210307220255.jpeg" alt=""></p><h4 id="健康填报"><a href="#健康填报" class="headerlink" title="健康填报"></a>健康填报</h4><p><img src="https://img2.jimu98.cn/haley/20210307220414.jpeg" alt=""></p><h4 id="查看健康填报情况"><a href="#查看健康填报情况" class="headerlink" title="查看健康填报情况"></a>查看健康填报情况</h4><p><img src="https://img2.jimu98.cn/haley/20210307220454.jpeg" alt=""></p><h4 id="申请请假"><a href="#申请请假" class="headerlink" title="申请请假"></a>申请请假</h4><p><img src="https://img2.jimu98.cn/haley/20210307220529.jpeg" alt=""></p><h4 id="修改个人信息"><a href="#修改个人信息" class="headerlink" title="修改个人信息"></a>修改个人信息</h4><p><img src="https://img2.jimu98.cn/haley/20210307220554.jpeg" alt=""></p><h3 id="教师"><a href="#教师" class="headerlink" title="教师"></a>教师</h3><h4 id="请假审批"><a href="#请假审批" class="headerlink" title="请假审批"></a>请假审批</h4><p><img src="https://img2.jimu98.cn/haley/20210307220649.jpeg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 项目展示 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript垃圾回收机制</title>
      <link href="posts/42773/"/>
      <url>posts/42773/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript垃圾回收机制"><a href="#JavaScript垃圾回收机制" class="headerlink" title="JavaScript垃圾回收机制"></a>JavaScript垃圾回收机制</h1><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>程序的运行需要内存，只要程序提出要求，操作系统或者运行是就必须供给内存。</p><p>对于持续运行的服务进程，必须及时释放内存，否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。</p><p>不再用到的内存，没有及时释放，就叫做内存泄漏。</p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>js代码想要运行，需要操作系统或者运行时提供内存空间，来存储变量及它的值。在某些变量(例如局部变量)在不参与运行时，就需要系统回收被占用的内存空间，称为垃圾回收。</p><h2 id="垃圾回收机制的方法"><a href="#垃圾回收机制的方法" class="headerlink" title="垃圾回收机制的方法"></a>垃圾回收机制的方法</h2><p>解决内存的泄露，垃圾回收机制会定期(周期性找)出那些不再用到的内存(变量)，然后释放其内存。</p><p>现在各大浏览器通常采用的垃圾回收机制有两种方法：<code>标记清除</code>、<code>引用计数</code>。</p><h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p>标记清除是js中最常用的垃圾回收的方式了。当变量进入环境时，就将这个变量标记为”进入环境”，从逻辑上讲，永远不能释放进入环境变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为”离开环境”。</p><p>例如下面这段代码：变量a和变量b会先被标记为”进入环境“，但是当test这个函数执行完毕后，就会将变量a和变量b标记为”离开环境”，进行回收。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p>垃圾回收机制在运行的时候会给存储在内存中的所有变量都加上标记(可以是任何标记方式)，然后，它会去掉处在环境中的变量以及被环境中的变量引用的变量标记(闭包)。而在此之后剩下的带有标记的变量被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后垃圾回收机制到下一个周期运行时，将释放这些变量的内存，回收它们所占用的空间。</p><p>到目前为止，IE、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。</p><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>另一种不太常见的垃圾回收策略是引用计数。引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间回收。这样，垃圾收集器下次再运行时，它就会释放那些引用次数为0的值所占的内存。</p><p>引用计数有个最大的问题：<strong>循环引用</strong></p><p>比如对象A有一个属性指向对象B，而对象B也有有一个属性指向对象A，这样相互引用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> obj1 = &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> obj2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    obj1.a = obj2; <span class="comment">// obj1 引用 obj2</span></span><br><span class="line">    obj2.a = obj1; <span class="comment">// obj2 引用 obj1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，objA和objB通过各自的属性相互引用；也就是说这两个对象的引用次数都是2。在采用引用计数的策略中，由于函数执行之后，这两个对象都离开了作用域，函数执行完成之后，objA和objB还将会继续存在，因为他们的引用次数永远不会是0。这样的相互引用如果说很大量的存在就会导致大量的内存泄露。</p><p>解决的办法就是通过手动解除了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj1.a = <span class="literal">null</span>;</span><br><span class="line">obj2.a = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h2 id="避免垃圾回收"><a href="#避免垃圾回收" class="headerlink" title="避免垃圾回收"></a>避免垃圾回收</h2><p>1、对数组进行优化</p><p>清空数组的捷径，就是将 <code>[]</code> 赋值给一个数组对象，但是这里就相当于又创建了一个新的空对象，并且原来的数组对象变成了一小片内存垃圾！其实我们可以将数组长度赋值为0(arr.length = 0)，也能达到清空数组的目的，并且同时能实现数组重用，减少内存垃圾的产生。 </p><p>2、尽量复用对象</p><p>在循环等地方出现创建新对象，能复用就复用。不用的对象，也尽可能设置为null，尽快被垃圾回收</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标记清除 </tag>
            
            <tag> 引用计数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端性能优化</title>
      <link href="posts/11055/"/>
      <url>posts/11055/</url>
      
        <content type="html"><![CDATA[<h1 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a>前端性能优化</h1><h2 id="初始阶段"><a href="#初始阶段" class="headerlink" title="初始阶段"></a>初始阶段</h2><h3 id="1、首页加载慢的优化"><a href="#1、首页加载慢的优化" class="headerlink" title="1、首页加载慢的优化"></a>1、首页加载慢的优化</h3><p>首页加载慢可能存在的问题：</p><ul><li>首页加载图片过多</li><li>首页的请求量过多</li><li>首页请求的<strong>静态资源</strong>（HTML、CSS、JS、图片…）过大</li></ul><h4 id="加载的图片过多"><a href="#加载的图片过多" class="headerlink" title="加载的图片过多"></a>加载的图片过多</h4><p>可以通过<strong>懒加载</strong>的方式来减少<strong>首屏图片</strong>的加载量，懒加载原理就是监听滚动条事件，如果(滚动条距离浏览器顶部的高度 === 图片距离顶部的高度)，那么就将 data-src 的值赋值到 src 上。</p><p>如果是小图片过多的话，可以通过如下的方式来星星解决：</p><ol><li>对于纯色系<strong>小图标</strong>可以使用 <a href="https://www.iconfont.cn/help/detail?&helptype=code">iconfont</a> 来解决</li></ol><ul><li>设置 font-family 的 CSS 属性</li></ul><ol start="2"><li>对于一些彩色的<strong>小图片</strong>可以使用雪碧图</li></ol><ul><li>把所有小图片拼接到一张大图片上</li><li>并使用 background-position 的 CSS 属性来修改图片坐标</li></ul><p>总结：</p><blockquote><p>首页加载图片过多的问题，可以通过以下几种方法解决：</p><ol><li>通过懒加载的方式处理非首屏的图片</li><li>对于小图标可以采用 iconfont 的方式解决</li><li>对于小图片可以采用雪碧图的方式解决</li></ol></blockquote><h4 id="请求量过多"><a href="#请求量过多" class="headerlink" title="请求量过多"></a>请求量过多</h4><p>当首页的请求量过多的时候，我们可以通过减少资源的请求量。</p><h5 id="合并静态资源"><a href="#合并静态资源" class="headerlink" title="合并静态资源"></a>合并静态资源</h5><ul><li>通过 <a href="https://tengine.taobao.org/download/nginx@taobao.pdf">nginx 服务器</a> (可用来做 CDN，<strong>用来处理静态资源</strong>)来做<strong>资源文件合并</strong> <a href="https://github.com/alibaba/nginx-http-concat">combo</a> – <strong>将多个JavaScript、CSS文件合并成一个</strong><ul><li>扩展：<a href="https://www.aliyun.com/product/list">日常企业项目</a>中服务器按照功能区分：<ul><li><strong>应用服务器</strong>：服务端语言运行的服务器(Java，NodeJS…)放淘宝应用的位置</li><li>数据库服务器：放数据库的服务器</li><li>存储服务器：放大型文件的服务器(例如各种网盘)</li><li><strong>CDN服务器</strong>：<strong>放静态资源</strong>的服务器(JS，CSS, 图片, 字体…)</li></ul></li></ul></li><li>通过打包工具(Webpack)来做资源文件的<strong>物理打包</strong>(相对没有第一种灵活)</li></ul><h5 id="代码本身"><a href="#代码本身" class="headerlink" title="代码本身"></a>代码本身</h5><p>如果在项目中引入了比较大型的第三方库，那就可以通过特定的 Babel 插件来进行按需加载</p><p>在路由层面也可以使用 React lazy 进行动态路由的加载，从而可以减少首页的 JS 和 CSS 的大小</p><h4 id="请求资源过大"><a href="#请求资源过大" class="headerlink" title="请求资源过大"></a>请求资源过大</h4><ol><li>要分资源文件，CSS，JS，图片等要分开来处理</li><li>CSS 和 JS 可以通过 Webpack 来进行<a href="https://tool.chinaz.com/tools/jscodeconfusion.aspx">混淆和压缩</a><ul><li>混淆：将 JS 代码进行字符串加密(最大层度减少代码，比如将长变量名变成单个字母等等)</li><li>压缩：去除注释空行以及 console.log 等调试代码</li></ul></li><li>图片也可以进行压缩<ul><li>可以通过自动化工具来压缩图片</li><li>对图片进行转码 -&gt; base64 格式</li><li>使用 WebP 格式</li></ul></li><li>通过开启 gzip 进行<strong>全部资源</strong>压缩<ul><li>gzip: 是一种压缩文件格式，可以对任何文件进行压缩(类比于文件压缩)</li><li>可以通过 nginx 服务器的配置项进行开启(演示 <code>/usr/local/etc/nginx</code>)</li></ul></li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote><p>对于首页加载慢的问题，一般是由于首页加载资源过多，并且资源过大导致。所以应对的策略就减<strong>少</strong>资源的数量以及减<strong>小</strong>资源的大小。</p><ul><li>对于图片可以懒加载，减小首屏图片加载量。以及对于小图标和小图片和分别使用 iconfont 和 雪碧图来解决，最大程度减少首屏图片数量，从而提升首页渲染性能。</li><li>对于其他资源可以通过打包（nginx combo 或者 Webpack 打包）来合并资源，并可以通过懒加载路由的方式来减小首页 JS 的加载量</li><li>减小资源的方式可以通过压缩和混淆加密来减小文件体积，图片则可以使用工具来压缩或者使用 webp 格式。</li><li>同时可在服务器端开始 gzip 压缩来最大化减少所有文件体积。</li></ul><p>前端中最常见资源：HTML、CSS、JS、图片</p></blockquote><h3 id="2、优化图片"><a href="#2、优化图片" class="headerlink" title="2、优化图片"></a>2、优化图片</h3><h4 id="减少图片的请求——懒加载"><a href="#减少图片的请求——懒加载" class="headerlink" title="减少图片的请求——懒加载"></a>减少图片的请求——懒加载</h4><p>第一种可以使用 Webpack 的 <a href="https://www.webpackjs.com/loaders/url-loader/">url-loader</a> 进行图片策略配置，将<strong>小图</strong>转换成 base64 格式，因为 <strong>base64 格式的图片的作用是减少资源的数量，但是 base64  格式的图片会增大原有图片的体积</strong></p><p> 还有一种方式就是使用 webp 格式的图片。图片格式有很多种，PNG、JPG、GIF，还有新的 WebP 格式，它的优势就在于根据 Google 的测试，同等条件等比例无损压缩后的 WebP 比 PNG 文件少了 26％ 的体积。并且图片越多，压缩后的体积优势越明显。</p><p><a href="https://www.upyun.com/webp">体验一下 WebP</a></p><h4 id="减小图片的大小——使用自动化工具对图片进行压缩"><a href="#减小图片的大小——使用自动化工具对图片进行压缩" class="headerlink" title="减小图片的大小——使用自动化工具对图片进行压缩"></a>减小图片的大小——使用自动化工具对图片进行压缩</h4><p><a href="https://tinypng.com/">熊猫站</a>：只能压缩PNG和JPG的一个网站，可以对图片进行等比例的无损压缩</p><blockquote><p>通过相似颜色“量化”的技术来减少颜色数量，并且可以将 24 位的 PNG 文件转化成 8位的彩色图片。同时可以将<strong>不必要的元数据</strong>进行剥离。</p><p>—&gt;翻译成人话：<strong>通过减少颜色的数量以及不必要的数据来实现文件压缩</strong></p></blockquote><p>而且熊猫站吧他们的图片压缩工具<a href="https://tinypng.com/developers/reference/nodejs">开放</a> 出来了。可以使用 npm 安装开源包，就可以在我们本地进行图片压缩啦。</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><blockquote><p>图片的优化，也是从两个方面来考虑：<strong>太多</strong> 和 <strong>太大</strong>。</p><ul><li><p>可以通过懒加载<strong>减少</strong>图片的请求，或者通过雪碧图来合并图片，以及将小图转化成 base64 的格式，来解决多的问题。</p></li><li><p>图片大的问题，可以通过自动化压缩工具来压缩图片，或者使用 WebP 格式的图片。</p></li></ul></blockquote><h3 id="3、实现webpack打包优化"><a href="#3、实现webpack打包优化" class="headerlink" title="3、实现webpack打包优化"></a>3、实现webpack打包优化</h3><p>webpack打包主要可以从以下两个方面入手：</p><p><code>少</code>：使用webpack进行物理打包</p><p><code>小</code>：使用 Webpack 进行混淆和压缩，所有与 Webpack 优化相关的配置都是在 <a href="https://webpack.docschina.org/configuration/optimization/">optimization</a> 这个配置项里管理，并且可以使用 React lazy 进行拆包，结合路由进行按需加载。</p><blockquote><p>从 webpack 4 开始，会根据你选择的 <a href="https://webpack.docschina.org/concepts/mode/">mode</a> 来执行不同的优化，不过所有的优化还是可以手动配置和重写。</p><p>development：不混淆，不压缩，不优化</p><p>production：混淆 + 压缩，自动内置优化</p><p>结论：只需要将 mode 改成 production 即可</p></blockquote><p>那这里你可能就有一个疑惑，既然你对文件进行拆包处理，那么肯定会造成文件变多，是不是有矛盾？</p><p>其实不冲突，因为拆包后的文件，不可能同时加载的，所以就不会造成同一时间资源请求过多的请求。但是要注意<strong>打包策略</strong>， 使用Webpack 的 optimization.splitChunks 进行<strong>打包策略的优化</strong></p><p>我们同城会把包分为两类：</p><p>一类是<code>第三方包</code>(node_modules里面的)</p><p>另一类是<code>自己实现的代码</code>(src里面的)</p><ul><li>公共的</li><li>非公共的</li></ul><p>所以我们可以把第三方包打一个包，公共的代码打一个包，非公共的代码打一个包。</p><p>第三方包：改动频率——小</p><p>公共代码包：改动频率 ——中</p><p>非公共代码包：改动频率——高</p><p>所以可以将 <strong>打包策略</strong> 结合 <strong>网络缓存</strong> 来做优化</p><p>对于不需要经常变动的资源(第三方包)，可以使用 <code>Cache-Control: max-age=31536000</code>(缓存一年)，并配合协商缓存 <code>ETag</code> 使用(一旦文件名变动才会下载新的文件)</p><p>对于需要频繁变动的资源(代码包)，可以使用 <code>Cache-Control: no-cache</code> 并配合 <code>ETag</code> 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。</p><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><blockquote><p>Webpack 打包优化，也是从两个方面来考虑：<strong>太多</strong> 和 <strong>太大</strong>。</p><ul><li>可以通过设置 mode = production 来默认实现 Webpack 对代码的混淆和压缩，从而最大程度的减少代码体积</li><li>使用 Webpack + dynamic import 并结合路由的入口文件做拆包处理。</li><li>并且可以设定一些打包策略，并配合网络缓存做最终的加载性能优化。</li></ul></blockquote><h3 id="4、实现CDN加速"><a href="#4、实现CDN加速" class="headerlink" title="4、实现CDN加速"></a>4、实现CDN加速</h3><p>CDN：放静态资源的服务器(JS，CSS，图片，字体……)</p><p>CDN实现加速：CDN服务器就是在你家门口放一台服务器，把所有的静态资源都同步到你家门口这台服务器上，以后只要你访问这个网站，都直接从这台服务器上下载静态资源。</p><p><img src="https://img2.jimu98.cn/haley/20210310114028.jpeg" alt="4"></p><p>还有就是如果我们使用HTTP1.1请求的话，HTTP1.1对于同一个协议、域名、端口，浏览器允许同时打开最多 6个 TCP 连接(最多同时发送 6个请求)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">主站     Request URL: https:<span class="comment">//www.taobao.com/</span></span><br><span class="line"></span><br><span class="line">JS&amp;CSS  Request URL: https:<span class="comment">//g.alicdn.com/??kg/home-2017/1.4.17/lib/style/lazy.css</span></span><br><span class="line"></span><br><span class="line">图片     Request URL: https:<span class="comment">//img.alicdn.com/tfs/TB1_uT8a5ERMeJjSspiXXbZLFXa-143-59.png</span></span><br><span class="line"></span><br><span class="line">字体     Request URL: https:<span class="comment">//at.alicdn.com/t/font_403341_n8tj33yn5peng66r.woff</span></span><br></pre></td></tr></table></figure><p>但是CDN服务器与一般与主服务器的地址并不相同，这样就不会受限于6个TCP连接。</p><p>但是在HTTP2.0引入了<strong>多路复用</strong>的机制，可以最大化发送请求数量。</p><blockquote><p>总结：</p><p>CDN 服务器主要是用来放静态资源的服务器，可以用来<strong>加速</strong>静态资源的下载</p><p>CDN 之所以能够加速，是因为会在很多地方都部署 CDN 服务器，如果用户需要下载静态资源，会自动选择最近的节点下载</p><p>同时由于 CDN 服务器的地址一般都跟主服务器的地址不同，所以可以破除浏览器对同一个域名发送请求的限制</p></blockquote><h2 id="运行阶段"><a href="#运行阶段" class="headerlink" title="运行阶段"></a>运行阶段</h2><h3 id="1、为什么渲染很多条数据会造成浏览器的卡顿？"><a href="#1、为什么渲染很多条数据会造成浏览器的卡顿？" class="headerlink" title="1、为什么渲染很多条数据会造成浏览器的卡顿？"></a>1、为什么渲染很多条数据会造成浏览器的卡顿？</h3><p><img src="https://img2.jimu98.cn/haley/20210310112431.jpg" alt=""></p><blockquote><ol><li>无论是浏览器中的 DOM 和 BOM，还是 NodeJS，它们都是基于JavaScript引擎之上开发出来的</li><li>DOM 和 BOM 的处理最终都是要被转换成 JavaScript 引擎能够处理的数据</li><li>这个转换的过程很耗时，所以在浏览器中<strong>最消耗性能的就是操作 DOM</strong></li></ol></blockquote><h3 id="2、怎么优化渲染很多数据的情况"><a href="#2、怎么优化渲染很多数据的情况" class="headerlink" title="2、怎么优化渲染很多数据的情况"></a>2、怎么优化渲染很多数据的情况</h3><p><strong>指导原则：尽可能的减少 DOM 的操作</strong></p><p>假如有这样一个需求，我们要在一个页面中ul标签里渲染十万个li标签，我们应该怎么做？</p><blockquote><p>思路：</p><ol><li>可以使用 document.createDocumentFragment 创建虚拟节点，从而避免引起没有必要的渲染</li><li>当所有的 li 都创建完毕后，一次性把虚拟节点里的 li 标签全部渲染出来</li><li>可以采取分段渲染的方式，比如一次只渲染一屏的数据</li><li>最后使用 <strong>window.requestAnimationFrame</strong> 来逐帧渲染</li></ol></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入十万条数据</span></span><br><span class="line"><span class="keyword">const</span> total = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">let</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;ul&#x27;</span>); <span class="comment">// 拿到 ul</span></span><br><span class="line"><span class="comment">// 懒加载的思路 -- 分段渲染</span></span><br><span class="line"><span class="comment">// 1. 一次渲染一屏的量</span></span><br><span class="line"><span class="keyword">const</span> once = <span class="number">20</span>;</span><br><span class="line"><span class="comment">// 2. 全部渲染完需要多少次，循环的时候要用</span></span><br><span class="line"><span class="keyword">const</span> loopCount = total / once;</span><br><span class="line"><span class="comment">// 3. 已经渲染了多少次</span></span><br><span class="line"><span class="keyword">let</span> countHasRender = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建虚拟节点，（使用 createDocumentFragment 不会触发渲染）</span></span><br><span class="line">  <span class="keyword">const</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">  <span class="comment">// 循环 20 次</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; once; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> li = <span class="built_in">document</span>.createElement(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">    li.innerText = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * total);</span><br><span class="line">    fragment.appendChild(li);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 最后把虚拟节点 append 到 ul 上</span></span><br><span class="line">  ul.appendChild(fragment);</span><br><span class="line">  <span class="comment">// 4. 已渲染的次数 + 1</span></span><br><span class="line">  countHasRender += <span class="number">1</span>;</span><br><span class="line">  loop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最重要的部分来了</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 5. 如果还没渲染完，那么就使用 requestAnimationFrame 来继续渲染</span></span><br><span class="line">  <span class="keyword">if</span> (countHasRender &lt; loopCount) &#123;</span><br><span class="line">    <span class="comment">// requestAnimationFrame 叫做逐帧渲染</span></span><br><span class="line">    <span class="comment">// 类似于 setTimeout(add, 16);</span></span><br><span class="line">    <span class="comment">// 帧：一秒钟播放多少张图片，一秒钟播放的图片越多，动画就越流畅</span></span><br><span class="line">    <span class="comment">// 1000/60 = 16</span></span><br><span class="line">    <span class="built_in">window</span>.requestAnimationFrame(add);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">loop();</span><br></pre></td></tr></table></figure><h3 id="3、总结："><a href="#3、总结：" class="headerlink" title="3、总结："></a>3、总结：</h3><blockquote><p>导致浏览器卡顿的原因一般都是<strong>操作 DOM</strong> 的次数太频繁。</p><p>如果想要渲染很多条数据不造成卡顿，那么就一定要尽可能的减少操作 DOM 的次数。</p><p>比方说 Vue 的虚拟 DOM，本质上就是用 JS 数据来模拟真实 DOM树，从而大大减少了操作真是 DOM 的次数。</p><p>还有在渲染的时候，可以使用 document.createDocumentFragment 创建虚拟节点，从而避免引起没有必要的渲染</p><p>也可以采取分段渲染的方式，最后使用 window.requestAnimationFrame 来<strong>逐帧渲染</strong></p></blockquote><h2 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a>最后总结</h2><blockquote><p>在前端中性能优化的点主要分为两个阶段：</p><ol><li><p>初始阶段，主要就是加载方面优化的问题。所有问题的指导原则就两点：</p><ul><li>尽可能的<strong>减少</strong>前端资源的数量</li><li>尽可能的<strong>减小</strong>前端资源的大小</li></ul></li><li><p>运行阶段，主要就是渲染方面优化的问题。只要是在浏览器中，所有的问题的指导原则就是：</p><ul><li>尽可能的减少操作 DOM</li></ul></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器常见的攻击手段</title>
      <link href="posts/21053/"/>
      <url>posts/21053/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览器常见的攻击手段"><a href="#浏览器常见的攻击手段" class="headerlink" title="浏览器常见的攻击手段"></a>浏览器常见的攻击手段</h1><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p><code>XSS</code> 全称是 <code>Cross Site Scripting</code>，为了与<code>CSS</code>区分开来，故简称 <code>XSS</code>，翻译过来就是“跨站脚本攻击”。XSS 攻击是指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。</p><p><code>XSS</code>的攻击目标是为了盗取存储在客户端的cookie或者其他网站用于识别客户端身份的敏感信息。一旦获取到合法用户的信息后，攻击者甚至可以假冒合法用户与网站进行交互。</p><h3 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h3><h4 id="存储型XSS攻击"><a href="#存储型XSS攻击" class="headerlink" title="存储型XSS攻击"></a>存储型XSS攻击</h4><p>主要出现在让用户输入数据，供其他浏览此页的用户进行查看的地方，包括留言、评论、博客日志和各类表单等。应用程序从数据库中查询数据，在页面中显示出来，攻击者在相关页面输入恶意的脚本数据后，用户浏览此类页面时就可能受到攻击。</p><p>比如说我写了一个网站，然后攻击者在上面发布了一个文章，内容是这样的 <code>&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code>，如果我没有对他的内容进行处理，直接存储到数据库，那么下一次当其他用户访问他的这篇文章的时候，服务器从数据库读取后然后响应给客户端，浏览器执行了这段脚本，就会将cookie展现出来，这就是典型的存储型XSS。</p><h4 id="反射型XSS攻击"><a href="#反射型XSS攻击" class="headerlink" title="反射型XSS攻击"></a>反射型XSS攻击</h4><p>主要做法是将脚本代码加入URL地址的请求参数里，请求参数进入程序后在页面直接输出，用户点击类似的恶意链接就可能受到攻击。</p><h3 id="预防XSS攻击"><a href="#预防XSS攻击" class="headerlink" title="预防XSS攻击"></a>预防XSS攻击</h3><p>1、将输入的数据进行转义处理</p><p>2、将用户所提供的内容进行过滤(如上面的<code>script</code>标签)</p><p>3、纯前端渲染</p><p>4、使用HTTP头指定类型<br><code>w.Header().Set(&quot;Content-Type&quot;,&quot;text/javascript&quot;)</code><br>这样就可以让浏览器解析javascript代码，而不会是html输出</p><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p><code>CSRF</code> 的全称是 Cross-site request forgery，翻译过来就是“跨站请求伪造”：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站 执行某项操作的目的。</p><h3 id="一个典型的CSRF攻击流程"><a href="#一个典型的CSRF攻击流程" class="headerlink" title="一个典型的CSRF攻击流程"></a>一个典型的CSRF攻击流程</h3><p>1、受害者登录 a.com ，并保留了登录凭证(Cookie)</p><p>2、攻击者引诱受害者访问了 b.com</p><p>3、b.com 向 a.com 发送了一个请求：a.com/act=xx，浏览器会默认携带a.com的Cookie</p><p>4、a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求 </p><p>5、a.com，以受害者的名义执行了act=xx </p><p>6、攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作</p><h3 id="预防CSRF"><a href="#预防CSRF" class="headerlink" title="预防CSRF"></a>预防CSRF</h3><p>CSRF通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对CSRF的防护能力来提升安全性。 </p><h4 id="一、阻止不明外域的访问"><a href="#一、阻止不明外域的访问" class="headerlink" title="一、阻止不明外域的访问"></a>一、阻止不明外域的访问</h4><h5 id="1、同源检测"><a href="#1、同源检测" class="headerlink" title="1、同源检测"></a>1、同源检测</h5><p>既然CSRF大多来自第三方网站，那么我们就直接禁止外域(或者不受信任的域名)对我们发起请求：</p><p>1、使用Origin Header确定来源域名：在部分与CSRF有关的请求中，请求的Header中会携带<code>Origin</code>字段,如果Origin存在，那么直接使用Origin中的字段确认来源域名就可以</p><p>2、使用Referer Header确定来源域名：根据HTTP协议，在HTTP头中有一个字段叫<code>Referer</code>，记录了该HTTP请求的来源地址</p><h5 id="2、Samesite-Cookie属性"><a href="#2、Samesite-Cookie属性" class="headerlink" title="2、Samesite Cookie属性"></a>2、Samesite Cookie属性</h5><p>Google起草了一份草案来改进HTTP协议，那就是为 <code>Set-Cookie</code> 响应头新增 <code>Samesite</code> 属性，它用来标明这个 Cookie是个“同站 Cookie”，同站Cookie只能作为第一方Cookie，不能作为第三方Cookie。</p><p>Samesite 有两个属性值：</p><p>Samesite=Strict: 这种称为严格模式，表明这个 Cookie 在任何情况下都不可能作为第三方 Cookie</p><p>Samesite=Lax: 这种称为宽松模式，比 Strict 放宽了点限制，假如这个请求是这种请求且同时是个GET请求，则这个 Cookie可以作为第三方Cookie</p><h4 id="二、提交时要求附加本域才能获取的信息"><a href="#二、提交时要求附加本域才能获取的信息" class="headerlink" title="二、提交时要求附加本域才能获取的信息"></a>二、提交时要求附加本域才能获取的信息</h4><h5 id="1、CSRF-Token"><a href="#1、CSRF-Token" class="headerlink" title="1、CSRF Token"></a>1、CSRF Token</h5><p>CSRF的另一个特征是攻击者无法直接窃取到用户的信息(Cookie，Header，网站内容等)，仅仅是冒用Cookie中的信息。</p><p>而CSRF攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户自己的请求。那么我们可以要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token。服务器通过校验请求是否携带正确的Token，来把正常的请求和攻击的请求区分开，从而防范CSRF的攻击。</p><p>CSRF Token的防护策略分为三个步骤：</p><ul><li><p>将CSRF Token输出到页面中 </p></li><li><p>页面提交的请求携带这个Token </p></li><li><p>服务器验证Token是否正确</p></li></ul><h5 id="2、双重Cookie验证"><a href="#2、双重Cookie验证" class="headerlink" title="2、双重Cookie验证"></a>2、双重Cookie验证</h5><p>在会话中存储CSRF Token比较繁琐，而且不能在通用的拦截上统一处理所有的接口。那么另一种防御措施是使用双重提交Cookie。利用CSRF攻击不能获取到用户Cookie的特点，我们可以要求Ajax和表单请求携带一个Cookie中的值</p><p>双重Cookie的流程如下：</p><ul><li><p>在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串</p></li><li><p>在前端向后端发起请求时，取出Cookie，并添加到URL的参数中</p></li><li><p>后端接口验证Cookie中的字段与URL参数中的字段是否一致，不一致则拒绝</p></li></ul><h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><p>攻击者成功的向服务器提交恶意的SQL查询代码，程序在接收后错误的将攻击者的输入作为查询语句的一部分执行，导致原始的查询逻辑被改变，额外的执行了攻击者精心构造的恶意代码。</p><p>例一：<code>&#39; OR &#39;1&#39;=&#39;1</code></p><p>这是最常见的 SQL注入攻击，当我们输如用户名 admin ，然后密码输如<code>&#39; OR &#39;1&#39;=1=&#39;1</code>的时候，我们在查询用户名和密码是否正确的时候，本来要执行的是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM user WHERE username=<span class="string">&#x27;&#x27;</span> and password=<span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>经过参数拼接后，会执行 SQL语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM user WHERE username=<span class="string">&#x27;&#x27;</span> and password=<span class="string">&#x27;&#x27;</span> OR <span class="string">&#x27;1&#x27;</span>=<span class="string">&#x27;1&#x27;</span></span><br></pre></td></tr></table></figure><p>这个时候1=1是成立，自然就跳过验证了。</p><p>例二：<code>&#39;;DROP TABLE user;--</code></p><p>这个时候SQL命令就被变成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM user WHERE username=<span class="string">&#x27;admin&#x27;</span> and password=<span class="string">&#x27;&#x27;</span>;drop table user;--<span class="string">&#x27; </span></span><br></pre></td></tr></table></figure><p>会直接将整个表给删除了。</p><h3 id="如何预防SQL注入"><a href="#如何预防SQL注入" class="headerlink" title="如何预防SQL注入"></a>如何预防SQL注入</h3><p>1、对进入数据库的特殊字符（<code>&#39;&quot;\尖括号&amp;*</code>等）进行转义处理，或编码转换</p><p>2、在应用发布之前建议使用专业的SQL注入检测工具进行检测，以及时修补被发现的SQL注入漏洞。</p><p>3、避免网站打印出SQL错误信息，比如类型错误、字段不匹配等，把代码里的SQL语句暴露出来，防止攻击者利用讴歌这些错误信息进行SQL注入。</p><h2 id="DDOS"><a href="#DDOS" class="headerlink" title="DDOS"></a>DDOS</h2><p><code>DDOS</code>：分布式拒绝服务攻击（Distributed Denial of Service），简单说就是发送大量请求使服务器瘫痪。DDOS攻击是在DOS攻击基础上的，可以通俗理解，DOS是单挑，而DDOS是群殴，因为现代技术的发展，DOS攻击的杀伤力降低，所以出现了DDOS，攻击者借助公共网络，将大数量的计算机设备联合起来，向一个或多个目标进行攻击。</p><h2 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h2><p><code>SYN</code>攻击指的是，攻击客户端通过三次握手向服务器发出请求，请求建立连接，然后服务器返回一个报文，表明请求以被接受，然后客户端也会返回一个报文，最后建立连接。那么如果有这么一种情况，攻击者伪造ip地址，发出报文给服务器请求连接，这个时候服务器接收到了，根据tcp三次握手的规则，服务器也要回应一个报文，可是这个ip是伪造的，报文回应给谁呢，第二次握手出现错误，第三次自然也就不能顺利进行了，这个时候服务器收不到第三次握手时客户端发出的报文，又再重复第二次握手的操作。如果攻击者伪造了大量的ip地址并发出请求，这个时候服务器将维护一个非常大的半连接等待列表，占用了大量的资源，最后服务器瘫痪。</p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XSS </tag>
            
            <tag> CSRF </tag>
            
            <tag> SQL注入 </tag>
            
            <tag> DDOS </tag>
            
            <tag> SYN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序的学习笔记</title>
      <link href="posts/25826/"/>
      <url>posts/25826/</url>
      
        <content type="html"><![CDATA[<h1 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h1><p>微信小程序，简称小程序，是一种不需要下载安装即可使用的应用，它实现了应用”触手可及”的梦想，用户扫一扫或搜一下即可打开应用。</p><h2 id="微信开发者工具介绍"><a href="#微信开发者工具介绍" class="headerlink" title="微信开发者工具介绍"></a>微信开发者工具介绍</h2><p><img src="https://img2.jimu98.cn/haley/20210127224932.png" alt="image-20210127224932586"></p><h2 id="原生框架的目录结构"><a href="#原生框架的目录结构" class="headerlink" title="原生框架的目录结构"></a>原生框架的目录结构</h2><h3 id="小程序文件结构和传统web对比"><a href="#小程序文件结构和传统web对比" class="headerlink" title="小程序文件结构和传统web对比"></a>小程序文件结构和传统web对比</h3><p><img src="https://img2.jimu98.cn/haley/20210127224858.png" alt="image-20210127224858821"></p><p>传统web是三层结构，而微信小程序是四层结构，多了一层配置.json</p><h3 id="基本的项目目录"><a href="#基本的项目目录" class="headerlink" title="基本的项目目录"></a>基本的项目目录</h3><p><img src="https://img2.jimu98.cn/haley/20210127224829.png" alt="image-20210127224829089"></p><h2 id="小程序的配置文件"><a href="#小程序的配置文件" class="headerlink" title="小程序的配置文件"></a>小程序的配置文件</h2><p>⼀个⼩程序应⽤程序会包括最基本的两种配置⽂件。⼀种是全局的 <code>app.json</code>和⻚⾯⾃⼰的<code>page.json</code></p><p><strong>注意：</strong>配置文件中不能出现注释</p><h3 id="全局配置app-json"><a href="#全局配置app-json" class="headerlink" title="全局配置app.json"></a>全局配置app.json</h3><h4 id="pages字段"><a href="#pages字段" class="headerlink" title="pages字段"></a>pages字段</h4><p>用于描述当前小程序所有页面的路径，这是为了让微信客户端知道当前你的小程序页面定义在哪个目录。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;pages&quot;:[</span><br><span class="line">    &quot;pages/index/index&quot;,</span><br><span class="line">    <span class="string">&quot;pages/logs/logs&quot;</span> </span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在app.json中直接写一个新的路径，微信开发工具自动在pages文件夹下新建一个对应的文件夹，不用手动创建了。</p><p>pages中哪个页面放在第一个，打开模拟器就默认显示哪个页面。</p><h4 id="window字段"><a href="#window字段" class="headerlink" title="window字段"></a>window字段</h4><p>定义小程序所有页面的顶部背景颜色，文字颜色定义等。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&quot;window&quot;:&#123;</span><br><span class="line">    <span class="comment">//下拉loading的样式,仅支持dark/light</span></span><br><span class="line">    &quot;backgroundTextStyle&quot;:&quot;dark&quot;,</span><br><span class="line">    <span class="comment">//导航栏背景颜色</span></span><br><span class="line">    &quot;navigationBarBackgroundColor&quot;: &quot;#0094ff&quot;,</span><br><span class="line">    <span class="comment">//导航栏标题文字内容</span></span><br><span class="line">    &quot;navigationBarTitleText&quot;: &quot;我的应用&quot;,</span><br><span class="line">    <span class="comment">//导航栏标题颜色,仅支持black/white</span></span><br><span class="line">    &quot;navigationBarTextStyle&quot;:&quot;black&quot;,</span><br><span class="line">    <span class="comment">//是否开启全局的下拉刷新</span></span><br><span class="line">    &quot;enablePullDownRefresh&quot;: true,</span><br><span class="line">    <span class="comment">//窗口的背景色</span></span><br><span class="line">    &quot;backgroundColor&quot;: &quot;#ccc&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="tabbar字段"><a href="#tabbar字段" class="headerlink" title="tabbar字段"></a>tabbar字段</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&quot;tabBar&quot;: &#123;</span><br><span class="line">    &quot;list&quot;:[&#123;</span><br><span class="line">      &quot;pagePath&quot;: &quot;pages/index/index&quot;,</span><br><span class="line">      &quot;text&quot;:&quot;首页&quot;,</span><br><span class="line">      &quot;iconPath&quot;: &quot;icon/_home.png&quot;,</span><br><span class="line">      &quot;selectedIconPath&quot;: &quot;icon/home.png&quot;</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">      &quot;pagePath&quot;: &quot;pages/demo1/demo1&quot;,</span><br><span class="line">      &quot;text&quot;:&quot;图片&quot;,</span><br><span class="line">      &quot;iconPath&quot;: &quot;icon/_img.png&quot;,</span><br><span class="line">      &quot;selectedIconPath&quot;: &quot;icon/img.png&quot;</span><br><span class="line">    &#125;],</span><br><span class="line">    &quot;color&quot;:&quot;#0094ff&quot;,</span><br><span class="line">    &quot;selectedColor&quot;: &quot;#ff9400&quot;,</span><br><span class="line">    &quot;backgroundColor&quot;: &quot;#ff5533&quot;,</span><br><span class="line">    &quot;position&quot;: &quot;top&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><img src="https://img2.jimu98.cn/haley/20210127224801.png" alt="image-20210127224801348"></p><p>完整的配置信息请参考<a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html">app.json配置</a></p><h3 id="页面配置page-json"><a href="#页面配置page-json" class="headerlink" title="页面配置page.json"></a>页面配置page.json</h3><p>开发者可以独立定义每个页面的一些属性，如顶部颜色、是否允许下拉刷新等等。</p><p>页面的配置只能设置app. json中部分window配置项的内容，页面中配置项会覆盖app. json的window 中相同的配置项。</p><h3 id="sitemap配置"><a href="#sitemap配置" class="headerlink" title="sitemap配置"></a>sitemap配置</h3><p>用于配置小程序及其页面是否允许被微信索引</p><p><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/sitemap.html">具体配置</a></p><h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h3><h4 id="1、普通写法"><a href="#1、普通写法" class="headerlink" title="1、普通写法"></a>1、普通写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;.wxml</span><br><span class="line">&lt;view&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;view&gt;</span><br><span class="line">&#x2F;&#x2F;.js</span><br><span class="line">Page(&#123;</span><br><span class="line">data: &#123;</span><br><span class="line">message:&#39;Hello&#39;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="2、组件属性"><a href="#2、组件属性" class="headerlink" title="2、组件属性"></a>2、组件属性</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">data-num</span>=<span class="string">&quot;&#123;&#123;message&#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3、布尔类型"><a href="#3、布尔类型" class="headerlink" title="3、布尔类型"></a>3、布尔类型</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">chekcbox</span> <span class="attr">checked</span>=<span class="string">&quot;&#123;&#123;false&#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">chekcbox</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">chekcbox</span> <span class="attr">checked</span>=<span class="string">&quot;&#123;&#123;isChecked&#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">chekcbox</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不要直接写checked=”false”，其计算结果是一个字符串。</p><p>字符串和花括号之间不要存在空格，否则会导致识别失败。</p><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><h4 id="三元运算"><a href="#三元运算" class="headerlink" title="三元运算"></a>三元运算</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>&#123;&#123;11%2===0 ?&#x27;偶数&#x27;:&#x27;奇数&#x27;&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span>  //奇数</span><br></pre></td></tr></table></figure><h4 id="算数运算"><a href="#算数运算" class="headerlink" title="算数运算"></a>算数运算</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>&#123;&#123;1+1&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span>  //2</span><br></pre></td></tr></table></figure><h4 id="逻辑判断"><a href="#逻辑判断" class="headerlink" title="逻辑判断"></a>逻辑判断</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:if</span>=<span class="string">&quot;&#123;&#123;length &gt;5&#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><p>字符串运算</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>&#123;&#123;&quot;1&quot;+&quot;1&quot;&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span>   // 11</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>花括号和引号之间如果有空格，将最终被解析成为字符串</p><h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><h4 id="数组循环"><a href="#数组循环" class="headerlink" title="数组循环"></a>数组循环</h4><p>项的变量名默认为<code>item</code> ，<code>wx:for-item</code>可以指定数组当前元素的变量名</p><p>下标的变量名默认为<code>index</code>，<code>wx:for-index</code>可以指定数组当前下标的变量名</p><p><code>wx:key=&#39;唯一的值&#39;</code>用来提高列表渲染的性能。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;list&#125;&#125;&quot;</span> <span class="attr">wx:for-item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">wx:for-index</span>=<span class="string">&quot;index&quot;</span> <span class="attr">wx:key</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">  索引：&#123;&#123;index&#125;&#125;  值：&#123;&#123;item.name&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">    list:[</span><br><span class="line">      &#123;</span><br><span class="line">        id:<span class="number">0</span>,</span><br><span class="line">        name:<span class="string">&quot;猪八戒&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id:<span class="number">1</span>,</span><br><span class="line">        name:<span class="string">&#x27;天蓬元帅&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>wx:key</code>可以绑定的值</p><p>1、如果绑定的是一个普通的字符串的时候，那么这个字符串的名称肯定是循环数组中对象的唯一属性</p><p>2、保留字<code>*this</code>，表示你的数组就是一个普通的数组，<code>*this</code>表示的是循环项。</p><p>当出现数组的嵌套循环的时候，要注意绑定的名称不要重名，只有一层的话，可以省略<code>wx:for-item=&#39;item&#39;</code>和<code>wx:for-index=&#39;index&#39;</code></p><h4 id="对象循环"><a href="#对象循环" class="headerlink" title="对象循环"></a>对象循环</h4><p>格式：<code>wx:for=&quot;&#123;&#123;对象&#125;&#125;&quot; wx:for-item=&quot;对象的值&quot; wx:for-index=&quot;对象的属性&quot;</code></p><p>循环对象的时候最好把item和index的名称修改一下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;person&#125;&#125;&quot;</span> <span class="attr">wx:for-item</span>=<span class="string">&quot;value&quot;</span> <span class="attr">wx:for-index</span>=<span class="string">&quot;key&quot;</span> <span class="attr">wx:key</span>=<span class="string">&quot;age&quot;</span>&gt;</span></span><br><span class="line">  属性：&#123;&#123;key&#125;&#125;  值：&#123;&#123;value&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> person: &#123;</span><br><span class="line">      age:<span class="number">74</span>,</span><br><span class="line">      height:<span class="number">145</span>,</span><br><span class="line">      weight:<span class="number">200</span>,</span><br><span class="line">      name:<span class="string">&#x27;小红&#x27;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="block"><a href="#block" class="headerlink" title="block"></a>block</h4><p>渲染一个包含多节点的结构块block，最终不会变成真正的dom元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;list&#125;&#125;&quot;</span> <span class="attr">wx:for-item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">wx:for-index</span>=<span class="string">&quot;index&quot;</span> <span class="attr">wx:key</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">       索引：&#123;&#123;index&#125;&#125;  值：&#123;&#123;item.name&#125;&#125; </span><br><span class="line">    <span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><h4 id="wx-if"><a href="#wx-if" class="headerlink" title="wx:if"></a>wx:if</h4><p>使用<code>wx:if=&quot;&#123;&#123;条件&#125;&#125;&quot;</code>来判断是否需要渲染该代码块</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:if</span>=<span class="string">&quot;&#123;&#123;false&#125;&#125;&quot;</span>&gt;</span>显示<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:elif</span>=<span class="string">&quot;&#123;&#123;false&#125;&#125;&quot;</span>&gt;</span>隐藏<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:else</span>&gt;</span> 3<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="hidden"><a href="#hidden" class="headerlink" title="hidden"></a>hidden</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">hidden</span>=<span class="string">&quot;&#123;&#123;false&#125;&#125;&quot;</span>&gt;</span>显示<span class="tag">&lt;/<span class="name">view</span>&gt;</span>  //不隐藏</span><br></pre></td></tr></table></figure><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p><code>v-if</code>：不经常使用，直接把标签从页面结构移除</p><p><code>hidden</code>：频繁切换，通过添加删除样式的方式来切换，<code>display:none</code></p><p>hidden属性不能和display样式一起使用，会覆盖掉。</p><h2 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h2><p>小程序中绑定事件，通过<code>bind</code>关键字来实现，如<code>bindtap</code> <code>bindinput</code> <code>bindchange</code>等，不同的组件支持不同的事件。</p><p>修改data的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.setData(&#123;</span><br><span class="line">    num:e.detail.value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>小程序中无法在事件中直接传参，必须通过自定义属性的方式来传递参数，然后从事件源中获取自定义属性。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">bindinput</span>=<span class="string">&quot;handleInput&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">bindtap</span>=<span class="string">&quot;handletap&quot;</span> <span class="attr">data-operation</span>=<span class="string">&quot;&#123;&#123;1&#125;&#125;&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">bindtap</span>=<span class="string">&quot;handletap&quot;</span> <span class="attr">data-operation</span>=<span class="string">&quot;&#123;&#123;-1&#125;&#125;&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>&#123;&#123;num&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    num:<span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">handleInput</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//输入框的值通过事件源对象获取</span></span><br><span class="line">    <span class="built_in">console</span>.log(e.detail.value)</span><br><span class="line">    <span class="built_in">this</span>.setData(&#123;</span><br><span class="line">      num: e.detail.value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//加减按钮的事件</span></span><br><span class="line">  <span class="function"><span class="title">handletap</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> operation = e.currentTarget.dataset.operation;</span><br><span class="line">    <span class="built_in">this</span>.setData(&#123;</span><br><span class="line">      num:<span class="built_in">this</span>.data.num +operation</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><h3 id="尺寸单位"><a href="#尺寸单位" class="headerlink" title="尺寸单位"></a>尺寸单位</h3><p><code>rpx</code>：可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。</p><p>如在iPhone6上，屏幕宽度为375px，共有750个物理像素，则<code>750rpx = 375px = 750物理像素</code>，<code>1rpx = 0.5px = 1物理像素</code>。</p><p><img src="https://img2.jimu98.cn/haley/20210127224715.png" alt="image-20210127224715241"></p><p>建议在开发微信小程序时，可以用iPhone6作为视觉稿的标准</p><p>小程序中不需要主动来引入样式文件。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*屏幕宽度750px，显示为200*200，屏幕宽度为375px，显示为100*100*/</span></span><br><span class="line">view&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200</span>rpx;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200</span>rpx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="样式导入"><a href="#样式导入" class="headerlink" title="样式导入"></a>样式导入</h3><p>wxss中直接就支持样式的导入功能。</p><p>使用<code>@import</code>语句可以导入外联样式表，只支持<code>相对路径</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@impot</span> <span class="string">&#x27;common.wxss&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p><img src="https://img2.jimu98.cn/haley/20210127224640.png" alt="image-20210127224640754"></p><p><strong>注意：</strong>小程序不支持通配符<code>*</code></p><h4 id="小程序中使用less"><a href="#小程序中使用less" class="headerlink" title="小程序中使用less"></a>小程序中使用less</h4><p>原生小程序不支持<code>less</code>，其他基于小程序的框架大体都支持，如<code>wepy</code>，<code>mpvue</code>，<code>taro</code>等。但是仅仅因为一个less功能，就去引入一个框架，肯定是不可取的。因此可以用一下方式来实现。</p><p>1、b编辑器<code>vscode</code></p><p>2、安装插件<code>Easy LESS</code></p><p>3、在vscode的设置的<code>settings.json</code>中加入如下配置</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;less.compile&quot;: &#123;</span><br><span class="line">    &quot;outExt&quot;: &quot;.wxss&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、在要编写样式的地方，新建<code>less</code>文件，然后正常编辑即可，就会生成对应的<code>.wxss</code>的文件</p><h2 id="常见组件"><a href="#常见组件" class="headerlink" title="常见组件"></a>常见组件</h2><h3 id="1、view"><a href="#1、view" class="headerlink" title="1、view"></a>1、view</h3><p>代替原来的div标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//hover-class指定按下去的样式类</span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">hover-class</span>=<span class="string">&quot;h-class&quot;</span>&gt;</span>嘿嘿<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2、text"><a href="#2、text" class="headerlink" title="2、text"></a>2、text</h3><p>（1）⽂本标签 </p><p>（2）只能嵌套text </p><p>（3）可以对空格、回⻋等进行编码 </p><p><code>user-select</code>：文本是否可选</p><p><code>decode</code>：是否解码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text</span> <span class="attr">decode</span>&gt;</span> text <span class="symbol">&amp;nbsp;</span> 123 &amp;lt<span class="tag">&lt;/<span class="name">text</span>&gt;</span>  // text 123 &lt;</span><br></pre></td></tr></table></figure><h3 id="3、image图片标签"><a href="#3、image图片标签" class="headerlink" title="3、image图片标签"></a>3、image图片标签</h3><p>image组件默认宽度是320px，高度是240px。</p><p><code>src</code>：指定要加载图片的路径</p><p><code>mode</code>：图片裁剪、缩放的模式</p><ul><li><code>aspectFit</code>：保持宽高比，确保图片的长边显示出来，页面轮播图常用</li><li><code>widthFix</code>：宽度指定了注资后，高度会自己按照比例来调整</li><li>更多值请参考<a href="https://developers.weixin.qq.com/miniprogram/dev/component/image.html">图片mode的属性</a></li></ul><p><code>lazy-load</code>：小程序中图片的懒加载会自己判断，当图片在即将进入一定范围（上下三屏）时才开始加载</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">image</span> <span class="attr">mode</span>=<span class="string">&quot;scaleTOFill&quot;</span> <span class="attr">lazy-load</span> <span class="attr">src</span>=<span class="string">&quot;https://&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4、swiper"><a href="#4、swiper" class="headerlink" title="4、swiper"></a>4、swiper</h3><p>微信内置的轮播图组件</p><p>轮播图外层容器<code>swiper</code>，每一个轮播项<code>swiper-item</code></p><p><code>swiper</code>标签存在默认样式，<code>width:100%</code> <code>height:150px</code>，<code>swiper</code>的高度无法实现由内容撑开。</p><p><code>autoplay</code>：是否自动轮播</p><p><code>interval</code>：自动轮播的时间间隔</p><p><code>circular</code>：是否采用衔接滑动</p><p><code>indicator-dots</code>：是否显示面板指示点</p><p><code>indicator-color</code>：指示点颜色</p><p><code>indicator-active-color</code>：当前选中的指示点颜色</p><p>更多值请参考<a href="https://developers.weixin.qq.com/miniprogram/dev/component/swiper.html">swiper的属性</a></p><p>swiper的高度：swiper宽度 * 原图的高度 / 原图的宽度</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">swiper</span> <span class="attr">autoplay</span> <span class="attr">interval</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">circular</span> <span class="attr">indicator-dots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">swiper-item</span>&gt;</span><span class="tag">&lt;<span class="name">image</span> <span class="attr">mode</span>=<span class="string">&quot;widthFix&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://aecpm.alicdn.com/simba/img/TB1XotJXQfb_uJkSnhJSuvdDVXa.jpg&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">swiper-item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">swiper-item</span>&gt;</span><span class="tag">&lt;<span class="name">image</span> <span class="attr">mode</span>=<span class="string">&quot;widthFix&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://img.alicdn.com/imgextra/i2/6000000004903/O1CN01JMpdMX1m5cZHZUPUV_!!6000000004903-0-octopus.jpg&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">swiper-item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">swiper-item</span>&gt;</span><span class="tag">&lt;<span class="name">image</span> <span class="attr">mode</span>=<span class="string">&quot;widthFix&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://aecpm.alicdn.com/simba/img/TB1JNHwKFXXXXafXVXXSutbFXXX.jpg&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">swiper-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">swiper</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">swiper&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">52.85vw</span>;</span><br><span class="line">&#125;</span><br><span class="line">image&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">100%</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、navigator"><a href="#5、navigator" class="headerlink" title="5、navigator"></a>5、navigator</h3><p>导航组件，类似于超链接标签。<a href="https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html">官方文档</a></p><p>navigater是块级元素，默认会换行，可以直接加高度和宽度</p><p><code>target</code>：在哪个目标上发生跳转，默认当前小程序</p><ul><li>self： 当前小程序</li><li>miniProgram：其它小程序</li></ul><p><code>url</code>：当前程序要跳转的链接，绝对路径/相对路径</p><p><code>open-type</code>：跳转的方式</p><ul><li>navigate：保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面。</li><li>redirect：关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面。</li><li>switchTab：跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面。</li><li>reLaunch：关闭所有页面，打开到应用内的某个页面。</li><li>navigateBack：关闭当前页面，返回上一页面或多级页面。</li><li>exit：退出小程序，<code>target=&quot;miniProgram&quot;</code>时生效。</li></ul><h3 id="6、rich-text"><a href="#6、rich-text" class="headerlink" title="6、rich-text"></a>6、rich-text</h3><p>可以将字符串解析成对应的标签，类似于vue中 <code>v-html</code> 功能。</p><p>node属性可以接收标签字符串和对象数组。</p><p>现支持两种节点，通过type来区分，分别是元素节点和文本节点，默认是元素节点。</p><p>元素节点：type = node</p><p><img src="https://img2.jimu98.cn/haley/20210127224519.png" alt="image-20210127224519253"></p><p>文本节点：type=text</p><p><img src="https://img2.jimu98.cn/haley/20210127224554.png" alt="image-20210127224554287"></p><p><img src="https://img2.jimu98.cn/haley/20210127224420.png" alt="image-20210127224420868"></p><p><a href="https://developers.weixin.qq.com/miniprogram/dev/component/rich-text.html"><strong>受信任的HTML节点及属性</strong></a></p><h3 id="7、button"><a href="#7、button" class="headerlink" title="7、button"></a>7、button</h3><h4 id="外观样式属性"><a href="#外观样式属性" class="headerlink" title="外观样式属性"></a>外观样式属性</h4><p><code>size</code>：按钮的大小</p><ul><li>default：默认大小</li><li>mini：小尺寸</li></ul><p><code>type</code>：按钮的样式类型</p><ul><li>primary：绿色</li><li>default：白色</li><li>warn：红色</li></ul><p><code>plain</code>：按钮是否镂空，背景色透明</p><p><code>loading</code>：名称前是否带 loading 图标</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>默认按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">size</span>=<span class="string">&quot;mini&quot;</span>&gt;</span>mini按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span>&gt;</span>primary按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;warn&quot;</span> <span class="attr">plain</span>&gt;</span>plain按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">loading</span>&gt;</span>loading按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="开放能力"><a href="#开放能力" class="headerlink" title="开放能力"></a>开放能力</h4><p>button的<code>open-type</code>属性</p><p><code>open-type</code>：是否具有微信开放能力</p><ul><li><p><code>contact</code>：打开客服会话，需要在微信小程序的后台配置，只能够通过真机调试来打开。</p></li><li><p><code>share</code>：转发当前的小程序到微信朋友或朋友圈</p></li><li><p><code>getPhoneNumber</code>：获取当前用户的手机号码信息，结合一个事件来使用，需要注意不是企业的小程序账号，没有权限来获取用户的手机号码</p><ul><li>绑定一个事件 bindgetphonenumber ，在事件的回到函数中获取参数来获取信息，获取到的信息，已经加密了。</li></ul></li><li><p><code>getUserInfo</code>：获取当前用户的个人信息，通过事件bindgetuserinfo直接获取，不加密。</p></li><li><p><code>launchApp</code>：在小程序中直接打开APP</p></li><li><p><code>openSetting</code>：打开小程序内置的授权页面，只显示用户曾经点击过的权限</p></li><li><p><code>feedback</code>：打开小程序内置的意见反馈页面，只能通过真机调试打开。</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">open-type</span>=<span class="string">&quot;contact&quot;</span>&gt;</span>contact<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">open-type</span>=<span class="string">&quot;share&quot;</span>&gt;</span>share<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">open-type</span>=<span class="string">&quot;getPhoneNumber&quot;</span> <span class="attr">bindgetphonenumber</span>=<span class="string">&quot;getPhoneNumber&quot;</span>&gt;</span>getPhoneNumber<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">open-type</span>=<span class="string">&quot;getUserInfo&quot;</span> <span class="attr">bindgetuserinfo</span>=<span class="string">&quot;getUserInfo&quot;</span> &gt;</span>getUserInfo<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">open-type</span>=<span class="string">&quot;launchAPP&quot;</span>&gt;</span>launchAPP<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">open-type</span>=<span class="string">&quot;openSetting&quot;</span>&gt;</span>openSetting<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">open-type</span>=<span class="string">&quot;feedback&quot;</span>&gt;</span>feedback<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">    <span class="comment">//获取用户的手机号码信息</span></span><br><span class="line">    <span class="function"><span class="title">getPhoneNumber</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//获取用户个人信息</span></span><br><span class="line">    <span class="function"><span class="title">getUserInfo</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="open-type的contact的实现流程"><a href="#open-type的contact的实现流程" class="headerlink" title="open-type的contact的实现流程"></a>open-type的contact的实现流程</h5><p>1、将小程序的<code>appid</code>由测试号改为自己的<code>appid</code></p><p>2、登录微信小程序官网，添加<code>客服-微信</code></p><h3 id="8、icon图标"><a href="#8、icon图标" class="headerlink" title="8、icon图标"></a>8、icon图标</h3><p><code>type</code>：icon的类型，有效值：success, success_no_circle, info, warn, waiting, cancel, download, search, clear</p><p><code>size</code>：icon的大小</p><p><code>color</code>：icon的颜色，同css的color</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">icon</span> <span class="attr">type</span>=<span class="string">&quot;success&quot;</span> <span class="attr">size</span>=<span class="string">&quot;60&quot;</span> <span class="attr">color</span>=<span class="string">&quot;#0094ff&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">icon</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="9、radio单选框"><a href="#9、radio单选框" class="headerlink" title="9、radio单选框"></a>9、radio单选框</h3><p><code>radio</code> 标签必须要和父元素<code>radio-group</code>来使用</p><p><code>value</code>：选中的单选框的值</p><p><code>color</code>：修改颜色</p><p>例：显示选中的单选框的内容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">radio-group</span> <span class="attr">bindchange</span>=<span class="string">&quot;handleChange&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">radio</span> <span class="attr">color</span>=<span class="string">&quot;red&quot;</span> <span class="attr">value</span>=<span class="string">&quot;male&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">radio</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">radio</span> <span class="attr">color</span>=<span class="string">&quot;red&quot;</span> <span class="attr">value</span>=<span class="string">&quot;female&quot;</span>&gt;</span>女<span class="tag">&lt;/<span class="name">radio</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">radio-group</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>您选中的是：&#123;&#123;gender&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    gender:<span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  handleChange(e)&#123;</span><br><span class="line">    let gender = e.detail.value;</span><br><span class="line">    this<span class="selector-class">.setData</span>(&#123;</span><br><span class="line">      gender</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="10、checkbox复选框"><a href="#10、checkbox复选框" class="headerlink" title="10、checkbox复选框"></a>10、checkbox复选框</h3><p><code>checkbox</code> 标签必须要和父元素<code>checkbox-group</code>来使用</p><p>例：显示当前页面点击的水果名称</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">checkbox-group</span> <span class="attr">bindchange</span>=<span class="string">&quot;handleItemChange&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">checkbox</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123;item.value&#125;&#125;&quot;</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;list&#125;&#125;&quot;</span> <span class="attr">wx:key</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123;item.name&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">checkbox</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">checkbox-group</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>选中的水果：&#123;&#123;checkedList&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    list:[</span><br><span class="line">      &#123;</span><br><span class="line">        id:<span class="number">0</span>,</span><br><span class="line">        name:<span class="string">&#x27;苹果&#x27;</span>,</span><br><span class="line">        value:<span class="string">&#x27;apple&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id:<span class="number">1</span>,</span><br><span class="line">        name:<span class="string">&#x27;葡萄&#x27;</span>,</span><br><span class="line">        value:<span class="string">&#x27;grape&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id:<span class="number">2</span>,</span><br><span class="line">        name:<span class="string">&#x27;香蕉&#x27;</span>,</span><br><span class="line">        value:<span class="string">&#x27;bananer&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    checkedList:[]</span><br><span class="line">  &#125;,</span><br><span class="line">  handleItemChange(e)&#123;</span><br><span class="line">    const checkedList = e.detail.value</span><br><span class="line">    this<span class="selector-class">.setData</span>(&#123;</span><br><span class="line">      checkedList</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a>自定义组件</h2><h3 id="自定义组件的步骤"><a href="#自定义组件的步骤" class="headerlink" title="自定义组件的步骤"></a>自定义组件的步骤</h3><h4 id="一、创建自定义组件"><a href="#一、创建自定义组件" class="headerlink" title="一、创建自定义组件"></a>一、创建自定义组件</h4><p>一个自定义组件由 <code>json</code> <code>wxml</code> <code>wxss</code> <code>js</code> 4个文件组成</p><p>在项目的根目录新建一个<code>components</code>文件夹，在该文件夹下再新建一个<code>Tabs</code>的文件夹，在该文件夹下右击<code>新建componetn</code>，就会自动生成对应的四个文件</p><p>1、声明文件</p><p>在组件的<code>json⽂件</code>中进⾏⾃定义组件声明</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  <span class="comment">//声明组件</span></span><br><span class="line">  <span class="attr">&quot;component&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">//还可以引入其他的组件</span></span><br><span class="line">  <span class="attr">&quot;usingComponents&quot;</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、在组件的<code>wxml文件</code>中编写组件模板，在<code>wxss文件</code>中加入组件样式。</p><p>3、在组件的<code>js文件</code>中，需要使用<code>Component()</code>来注册组件，并提供组件的属性定义、内部数据和自定义方法。</p><h4 id="二、声明引入自定义文件"><a href="#二、声明引入自定义文件" class="headerlink" title="二、声明引入自定义文件"></a>二、声明引入自定义文件</h4><p>首先要在页面的json文件中进行引用声明，还要提供对应的组件名和组件路径</p><p>在使用该组件的页面的<code>.json</code>文件内</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;usingComponents&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;Tabs&quot;</span>:<span class="string">&quot;../../components/Tabs/Tabs&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三、在页面中使用自定义组件"><a href="#三、在页面中使用自定义组件" class="headerlink" title="三、在页面中使用自定义组件"></a>三、在页面中使用自定义组件</h4><p>该页面的<code>.wxml</code>中这样使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Tabs</span>&gt;</span><span class="tag">&lt;/<span class="name">Tabs</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="父向子传递数据"><a href="#父向子传递数据" class="headerlink" title="父向子传递数据"></a>父向子传递数据</h3><p>父组件向子组件传递数据通过<code>标签属性</code>的方式来传递，子组件把传递过来的数据当成是data中的数据直接使用即可。</p><p>父组件 wxml</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Tabs</span> <span class="attr">a</span>=<span class="string">&quot;123&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Tabs</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子组件js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">properties: &#123;</span><br><span class="line">    <span class="comment">//要接收的数据名称</span></span><br><span class="line">    a:&#123;</span><br><span class="line">        <span class="comment">//type：要接收的数据类型</span></span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        <span class="comment">//value:默认值</span></span><br><span class="line">        value:<span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子组件wxml</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>&#123;&#123;a&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span>  //123</span><br></pre></td></tr></table></figure><h3 id="子向父传递数据"><a href="#子向父传递数据" class="headerlink" title="子向父传递数据"></a>子向父传递数据</h3><p>子组件向父组件传递数据，通过<code>事件</code>的方式</p><p>子组件内触发父组件的自定义事件：<code>this.triggerEvent(&quot;父组件自定义事件的名称&quot;，要传递的参数)</code>，父组件定义一个方法对数据进行修改。</p><p>子组件js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.triggerEvent(<span class="string">&#x27;itemChange&#x27;</span>,&#123;index&#125;)</span><br></pre></td></tr></table></figure><p>父组件wxml</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Tabs</span> <span class="attr">tabs</span>=<span class="string">&quot;&#123;&#123;tabs&#125;&#125;&quot;</span> <span class="attr">binditemChange</span>=<span class="string">&quot;handleItemChange&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Tabs</span>&gt;</span></span><br></pre></td></tr></table></figure><p>父组件js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">handleItemChange</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;index&#125; = e.detail;</span><br><span class="line">    <span class="keyword">let</span> &#123;tabs&#125; = <span class="built_in">this</span>.data;</span><br><span class="line">    tabs.forEach(<span class="function">(<span class="params">v,i</span>)=&gt;</span>&#123;</span><br><span class="line">      i===index ? v.isActive=<span class="literal">true</span> : v.isActive= <span class="literal">false</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">this</span>.setData(&#123;</span><br><span class="line">    tabs</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h3><p>slot标签其实就是一个占位符，<code>插槽</code>，当父组件使用子组件的时候，再传递标签过来，最终这些被传递的标签就会替换slot插槽的位置。</p><p>父组件wxml</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Tabs</span> <span class="attr">tabs</span>=<span class="string">&quot;&#123;&#123;tabs&#125;&#125;&quot;</span> <span class="attr">binditemChange</span>=<span class="string">&quot;handleItemChange&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:if</span>=<span class="string">&quot;&#123;&#123;tabs[0].isActive&#125;&#125;&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:elif</span>=<span class="string">&quot;&#123;&#123;tabs[1].isActive&#125;&#125;&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:elif</span>=<span class="string">&quot;&#123;&#123;tabs[2].isActive&#125;&#125;&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:else</span>=<span class="string">&quot;&#123;&#123;tabs[3].isActive&#125;&#125;&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Tabs</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子组件wxml</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;tabs_content&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="组件的其他属性"><a href="#组件的其他属性" class="headerlink" title="组件的其他属性"></a>组件的其他属性</h3><p><code>observers</code>：监听器，和vue的watch相似，只在组件中存在，不存在在页面中</p><h3 id="组件的生命周期函数"><a href="#组件的生命周期函数" class="headerlink" title="组件的生命周期函数"></a>组件的生命周期函数</h3><p><code>created</code>：组件实例刚刚被创建执行，不能调用setdata</p><p><code>attached</code>：组件实例进入页面节点树时执行</p><p><code>ready</code>：在逐渐布局完成后执行</p><p><code>moved</code>：组件实例被移动到节点树的另一个位置时执行</p><p><code>detached</code>：组件实例被从页面节点树移除时执行</p><h2 id="小程序生命周期"><a href="#小程序生命周期" class="headerlink" title="小程序生命周期"></a>小程序生命周期</h2><h3 id="应用生命周期"><a href="#应用生命周期" class="headerlink" title="应用生命周期"></a>应用生命周期</h3><p>应用生命周期指的是入口文件<code>app.js</code></p><p><code>onLaunch</code>：监听⼩程序初始化。</p><ul><li>使用场景：在应用第一次启动的时候，获取用户的个人信息</li></ul><p><code>onShow</code>：监听⼩程序启动或切前台。 </p><ul><li>使用场景：对应用的数据或者页面效果重置</li></ul><p><code>onHide</code>：监听⼩程序切后台。</p><ul><li>使用场景：暂停或者清除定时器</li></ul><p><code>onError</code>：错误监听函数。 </p><ul><li>使用场景：在应用发生代码报错的时候，收集用户的错误信息，通过异步请求，将错误信息发送到后台</li></ul><p><code>onPageNotFound</code>：⻚⾯不存在监听函数。只有在应用第一次启动的时候，如果找不到入口页面，才会触发</p><ul><li>使用场景：如果页面找不到了，可以通过js的方式重新跳转页面</li></ul><h3 id="页面生命周期"><a href="#页面生命周期" class="headerlink" title="页面生命周期"></a>页面生命周期</h3><p><img src="https://img2.jimu98.cn/haley/20210127224319.png" alt="image-20210127224319868"></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><code>onload</code>：发送异步请求来初始化数据</p><p><code>onUnload</code> ：凡是具有关闭页面功能的跳转，都是卸载</p><p><code>onPullDownRefresh</code> ：页面的数据或者效果重新刷新</p><p><code>onReachBottom</code>： 页面出现上下滚动才会触发 ，使用场景：上拉加载下一页数据</p><p><code>onResize</code> ：小程序发生了横屏竖屏切换的时候触发，如果想整个应用都可以横竖屏切换，就在<code>app.json</code>中写入如下配置，如果只是当前页面，就写到当前页面的<code>.json</code>文件中。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;pageOrientation&quot;</span>:<span class="string">&quot;auto&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>onTabItem</code> ：只有当前页面是tabbar页面，并且只有点击自己的<code>tab item</code>的时候触发</p><h3 id="页面生命周期图解"><a href="#页面生命周期图解" class="headerlink" title="页面生命周期图解"></a>页面生命周期图解</h3><p><img src="https://img2.jimu98.cn/haley/20210127224237.png" alt="image-20210127224237107"></p>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uniapp基础知识</title>
      <link href="posts/34779/"/>
      <url>posts/34779/</url>
      
        <content type="html"><![CDATA[<h1 id="uni-app的基本使用"><a href="#uni-app的基本使用" class="headerlink" title="uni-app的基本使用"></a>uni-app的基本使用</h1><h2 id="uni-app介绍-官方网页"><a href="#uni-app介绍-官方网页" class="headerlink" title="uni-app介绍 官方网页"></a>uni-app介绍 <a href="https://uniapp.dcloud.io">官方网页</a></h2><p><code>uni-app</code> 是一个使用 <a href="https://vuejs.org/">Vue.js</a> 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、H5、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉）等多个平台。</p><p>即使不跨端，<code>uni-app</code>同时也是更好的小程序开发框架。</p><p>具有vue和微信小程序的开发经验，可快速上手uni-app</p><p><strong>为什么要去学习uni-app？</strong></p><p>相对开发者来说，减少了学习成本，因为只学会uni-app之后，即可开发出iOS、Android、H5、以及各种小程序的应用，不需要再去学习开发其他应用的框架，相对公司而言，也大大减少了开发成本。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>安装编辑器<code>HbuilderX</code>  <a href="https://www.dcloud.io/hbuilderx.html">下载地址</a></p><p>HBuilderX是通用的前端开发工具，但为<code>uni-app</code>做了特别强化。</p><p>下载App开发版，可开箱即用</p><p>安装<code>微信开发者工具</code> <a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html">下载地址</a></p><h3 id="利用HbuilderX初始化项目"><a href="#利用HbuilderX初始化项目" class="headerlink" title="利用HbuilderX初始化项目"></a>利用HbuilderX初始化项目</h3><ul><li><p>点击HbuilderX菜单栏文件&gt;项目&gt;新建</p></li><li><p>选择uni-app，填写项目名称，项目创建的目录</p></li></ul><h3 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h3><p>在菜单栏中点击运行，运行到浏览器，选择浏览器即可运行</p><p>在微信开发者工具里运行：进入hello-uniapp项目，点击工具栏的运行 -&gt; 运行到小程序模拟器 -&gt; 微信开发者工具，即可在微信开发者工具里面体验uni-app</p><p>在微信开发者工具里运行：进入hello-uniapp项目，点击工具栏的运行 -&gt; 运行到手机或模拟器 -&gt; 选择调式的手机</p><p><strong>注意：</strong></p><ul><li>如果是第一次使用，需要先配置小程序ide的相关路径，才能运行成功</li><li>微信开发者工具在设置中安全设置，服务端口开启</li></ul><h3 id="介绍项目目录和文件作用"><a href="#介绍项目目录和文件作用" class="headerlink" title="介绍项目目录和文件作用"></a>介绍项目目录和文件作用</h3><p><code>pages.json</code> 文件用来对 uni-app 进行全局配置，决定页面文件的路径、窗口样式、原生的导航栏、底部的原生tabbar 等</p><p><code>manifest.json</code> 文件是应用的配置文件，用于指定应用的名称、图标、权限等。</p><p><code>App.vue</code>是我们的跟组件，所有页面都是在<code>App.vue</code>下进行切换的，是页面入口文件，可以调用应用的生命周期函数。</p><p><code>main.js</code>是我们的项目入口文件，主要作用是初始化<code>vue</code>实例并使用需要的插件。</p><p><code>uni.scss</code>文件的用途是为了方便整体控制应用的风格。比如按钮颜色、边框风格，<code>uni.scss</code>文件里预置了一批scss变量预置。</p><figure class="highlight plain"><figcaption><span>就是打包目录，在这里有各个平台的打包文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#96;&#96;&#96;pages&#96;&#96;&#96; 所有的页面存放目录</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;static&#96;&#96;&#96; 静态资源目录，例如图片等</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;components&#96;&#96;&#96; 组件存放目录</span><br><span class="line"></span><br><span class="line">为了实现多端兼容，综合考虑编译速度、运行性能等因素，&#96;uni-app&#96; 约定了如下开发规范：</span><br><span class="line"></span><br><span class="line">- 页面文件遵循 [Vue 单文件组件 (SFC) 规范](https:&#x2F;&#x2F;vue-loader.vuejs.org&#x2F;zh&#x2F;spec.html)</span><br><span class="line">- 组件标签靠近小程序规范，详见[uni-app 组件规范](https:&#x2F;&#x2F;uniapp.dcloud.io&#x2F;component&#x2F;README)</span><br><span class="line">- 接口能力（JS API）靠近微信小程序规范，但需将前缀 &#96;wx&#96; 替换为 &#96;uni&#96;，详见[uni-app接口规范](https:&#x2F;&#x2F;uniapp.dcloud.io&#x2F;api&#x2F;README)</span><br><span class="line">- 数据绑定及事件处理同 &#96;Vue.js&#96; 规范，同时补充了App及页面的生命周期</span><br><span class="line">- 为兼容多端运行，建议使用flex布局进行开发</span><br><span class="line"></span><br><span class="line">## 页面外观配置</span><br><span class="line"></span><br><span class="line">### 全局配置</span><br><span class="line"></span><br><span class="line">#### 通过globalStyle进行全局配置</span><br><span class="line"></span><br><span class="line">用于设置应用的状态栏、导航条、标题、窗口背景色等。[详细文档](https:&#x2F;&#x2F;uniapp.dcloud.io&#x2F;collocation&#x2F;pages?id&#x3D;globalstyle)</span><br><span class="line"></span><br><span class="line">| 属性                           | 类型       | 默认值     | 描述                                       |</span><br><span class="line">| ---------------------------- | -------- | ------- | ---------------------------------------- |</span><br><span class="line">| navigationBarBackgroundColor | HexColor | #F7F7F7 | 导航栏背景颜色（同状态栏背景色）                         |</span><br><span class="line">| navigationBarTextStyle       | String   | white   | 导航栏标题颜色及状态栏前景颜色，仅支持 black&#x2F;white          |</span><br><span class="line">| navigationBarTitleText       | String   |         | 导航栏标题文字内容                                |</span><br><span class="line">| backgroundColor              | HexColor | #ffffff | 窗口的背景色                                   |</span><br><span class="line">| backgroundTextStyle          | String   | dark    | 下拉 loading 的样式，仅支持 dark &#x2F; light          |</span><br><span class="line">| enablePullDownRefresh        | Boolean  | false   | 是否开启下拉刷新，详见[页面生命周期](https:&#x2F;&#x2F;uniapp.dcloud.io&#x2F;use?id&#x3D;%e9%a1%b5%e9%9d%a2%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f)。 |</span><br><span class="line">| onReachBottomDistance        | Number   | 50      | 页面上拉触底事件触发时距页面底部距离，单位只支持px，详见[页面生命周期](https:&#x2F;&#x2F;uniapp.dcloud.io&#x2F;use?id&#x3D;%e9%a1%b5%e9%9d%a2%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f) |</span><br><span class="line"></span><br><span class="line">### 页面配置</span><br><span class="line"></span><br><span class="line">#### 通过pages来配置页面</span><br><span class="line"></span><br><span class="line">| 属性    | 类型     | 默认值  | 描述                                       |</span><br><span class="line">| ----- | ------ | ---- | ---------------------------------------- |</span><br><span class="line">| path  | String |      | 配置页面路径                                   |</span><br><span class="line">| style | Object |      | 配置页面窗口表现，配置项参考 [pageStyle](https:&#x2F;&#x2F;uniapp.dcloud.io&#x2F;collocation&#x2F;pages?id&#x3D;style) |</span><br><span class="line"></span><br><span class="line">pages数组数组中第一项表示应用启动页</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;html</span><br><span class="line">&quot;pages&quot;: [ 、</span><br><span class="line">&#123;</span><br><span class="line">&quot;path&quot;:&quot;pages&#x2F;message&#x2F;message&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;path&quot;: &quot;pages&#x2F;index&#x2F;index&quot;,</span><br><span class="line">&quot;style&quot;: &#123;</span><br><span class="line">&quot;navigationBarTitleText&quot;: &quot;uni-app&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>通过style修改页面的标题和导航栏背景色，并且设置h5下拉刷新的特有样式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;pages&quot;</span>: [ <span class="comment">//pages数组中第一项表示应用启动页，参考：https://uniapp.dcloud.io/collocation/pages</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;path&quot;</span>:<span class="string">&quot;pages/message/message&quot;</span>,</span><br><span class="line"><span class="string">&quot;style&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;navigationBarBackgroundColor&quot;</span>: <span class="string">&quot;#007AFF&quot;</span>,</span><br><span class="line"><span class="string">&quot;navigationBarTextStyle&quot;</span>: <span class="string">&quot;white&quot;</span>,</span><br><span class="line"><span class="string">&quot;enablePullDownRefresh&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">&quot;disableScroll&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">&quot;h5&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;pullToRefresh&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;color&quot;</span>: <span class="string">&quot;#007AFF&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="配置tabbar"><a href="#配置tabbar" class="headerlink" title="配置tabbar"></a>配置tabbar</h3><p>如果应用是一个多 tab 应用，可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页。</p><p><strong>Tips</strong></p><ul><li>当设置 position 为 top 时，将不会显示 icon</li><li>tabBar 中的 list 是一个数组，只能配置最少2个、最多5个tab，tab 按数组的顺序排序。</li></ul><p><strong>属性说明：</strong></p><table><thead><tr><th>属性</th><th>类型</th><th>必填</th><th>默认值</th><th>描述</th><th>平台差异说明</th></tr></thead><tbody><tr><td>color</td><td>HexColor</td><td>是</td><td></td><td>tab 上的文字默认颜色</td><td></td></tr><tr><td>selectedColor</td><td>HexColor</td><td>是</td><td></td><td>tab 上的文字选中时的颜色</td><td></td></tr><tr><td>backgroundColor</td><td>HexColor</td><td>是</td><td></td><td>tab 的背景色</td><td></td></tr><tr><td>borderStyle</td><td>String</td><td>否</td><td>black</td><td>tabbar 上边框的颜色，仅支持 black/white</td><td>App 2.3.4+ 支持其他颜色值</td></tr><tr><td>list</td><td>Array</td><td>是</td><td></td><td>tab 的列表，详见 list 属性说明，最少2个、最多5个 tab</td><td></td></tr><tr><td>position</td><td>String</td><td>否</td><td>bottom</td><td>可选值 bottom、top</td><td>top 值仅微信小程序支持</td></tr></tbody></table><p>其中 list 接收一个数组，数组中的每个项都是一个对象，其属性值如下：</p><table><thead><tr><th>属性</th><th>类型</th><th>必填</th><th>说明</th></tr></thead><tbody><tr><td>pagePath</td><td>String</td><td>是</td><td>页面路径，必须在 pages 中先定义</td></tr><tr><td>text</td><td>String</td><td>是</td><td>tab 上按钮文字，在 5+APP 和 H5 平台为非必填。例如中间可放一个没有文字的+号图标</td></tr><tr><td>iconPath</td><td>String</td><td>否</td><td>图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px，当 postion 为 top 时，此参数无效，不支持网络图片，不支持字体图标</td></tr><tr><td>selectedIconPath</td><td>String</td><td>否</td><td>选中时的图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px ，当 postion 为 top 时，此参数无效</td></tr></tbody></table><p>案例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;tabBar&quot;</span>:&#123;</span><br><span class="line"><span class="string">&quot;color&quot;</span>:<span class="string">&quot;#A0522D&quot;</span>,</span><br><span class="line"><span class="string">&quot;selectedColor&quot;</span>:<span class="string">&quot;#B3EE3A&quot;</span>,</span><br><span class="line"><span class="string">&quot;backgroundColor&quot;</span>:<span class="string">&quot;#C8C7CC&quot;</span>,</span><br><span class="line"><span class="string">&quot;borderStyle&quot;</span>:<span class="string">&quot;black&quot;</span>,</span><br><span class="line"><span class="string">&quot;position&quot;</span>:<span class="string">&quot;top&quot;</span>,</span><br><span class="line"><span class="string">&quot;list&quot;</span>:[</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;text&quot;</span>:<span class="string">&quot;首页&quot;</span>,</span><br><span class="line"><span class="string">&quot;pagePath&quot;</span>:<span class="string">&quot;pages/index/index&quot;</span>,</span><br><span class="line"><span class="string">&quot;iconPath&quot;</span>:<span class="string">&quot;static/_home.png&quot;</span>,</span><br><span class="line"><span class="string">&quot;selectedIconPath&quot;</span>:<span class="string">&quot;static/home.png&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;text&quot;</span>:<span class="string">&quot;图片&quot;</span>,</span><br><span class="line"><span class="string">&quot;pagePath&quot;</span>:<span class="string">&quot;./pages/message/message&quot;</span>,</span><br><span class="line"><span class="string">&quot;iconPath&quot;</span>:<span class="string">&quot;static/_img.png&quot;</span>,</span><br><span class="line"><span class="string">&quot;selectedIconPath&quot;</span>:<span class="string">&quot;static/img.png&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="condition启动模式配置"><a href="#condition启动模式配置" class="headerlink" title="condition启动模式配置"></a>condition启动模式配置</h3><p>启动模式配置，仅开发期间生效，用于模拟直达页面的场景，如：小程序转发后，用户点击所打开的页面。</p><p><strong>属性说明：</strong></p><table><thead><tr><th>属性</th><th>类型</th><th>是否必填</th><th>描述</th></tr></thead><tbody><tr><td>current</td><td>Number</td><td>是</td><td>当前激活的模式，list节点的索引值</td></tr><tr><td>list</td><td>Array</td><td>是</td><td>启动模式列表</td></tr></tbody></table><p><strong>list说明：</strong></p><table><thead><tr><th>属性</th><th>类型</th><th>是否必填</th><th>描述</th></tr></thead><tbody><tr><td>name</td><td>String</td><td>是</td><td>启动模式名称</td></tr><tr><td>path</td><td>String</td><td>是</td><td>启动页面路径</td></tr><tr><td>query</td><td>String</td><td>否</td><td>启动参数，可在页面的 <a href="https://uniapp.dcloud.io/use?id=%e9%a1%b5%e9%9d%a2%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f">onLoad</a> 函数里获得</td></tr></tbody></table><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在小程序中，没法儿直接到达详情页，可以通过该方式，普通编译下就会有”详情页“了</span></span><br><span class="line">&quot;condition&quot;:&#123;</span><br><span class="line">&quot;current&quot;:0,</span><br><span class="line">&quot;list&quot;:[</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;name&quot;</span>:<span class="string">&quot;详情页&quot;</span>,</span><br><span class="line"><span class="attr">&quot;path&quot;</span>:<span class="string">&quot;pages/detail/detail&quot;</span>,</span><br><span class="line"><span class="attr">&quot;query&quot;</span>:<span class="string">&quot;id=80&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组件的基本使用"><a href="#组件的基本使用" class="headerlink" title="组件的基本使用"></a>组件的基本使用</h2><p>uni-app提供了丰富的基础组件给开发者，开发者可以像搭积木一样，组合各种组件拼接称自己的应用</p><p>uni-app中的组件，就像 <code>HTML</code> 中的 <code>div</code> 、<code>p</code>、<code>span</code> 等标签的作用一样，用于搭建页面的基础结构</p><h3 id="text文本组件"><a href="#text文本组件" class="headerlink" title="text文本组件"></a>text文本组件</h3><p><strong>1 - text 组件的属性</strong></p><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">默认值</th><th align="center">必填</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">selectable</td><td align="center">boolean</td><td align="center">false</td><td align="center">否</td><td align="center">文本是否可选</td></tr><tr><td align="center">space</td><td align="center">string</td><td align="center">.</td><td align="center">否</td><td align="center">显示连续空格，可选参数：<code>ensp</code>、<code>emsp</code>、<code>nbsp</code></td></tr><tr><td align="center">decode</td><td align="center">boolean</td><td align="center">false</td><td align="center">否</td><td align="center">是否解码</td></tr></tbody></table><ul><li><code>text</code> 组件相当于行内标，在同一行显示</li><li>除了文本节点以外的其他节点都无法长按选中</li></ul><p>space值说明</p><p><code>ensp</code>：中文字符空格一半大小</p><p><code>emsp</code>：中文字符空格大小</p><p><code>nbsp</code>：根据字体设置的空格大小</p><p><strong>2 - 代码案例</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 长按文本是否可选 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">text</span> <span class="attr">selectable</span>=<span class="string">&#x27;true&#x27;</span>&gt;</span>呵呵呵<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 显示连续空格的方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">text</span> <span class="attr">space</span>=<span class="string">&#x27;ensp&#x27;</span>&gt;</span>哈哈  哈<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">text</span> <span class="attr">space</span>=<span class="string">&#x27;emsp&#x27;</span>&gt;</span>哈哈  哈<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">text</span> <span class="attr">space</span>=<span class="string">&#x27;nbsp&#x27;</span>&gt;</span>哈哈  哈<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 是否解码 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">text</span> <span class="attr">decode</span>=<span class="string">&#x27;true&#x27;</span>&gt;</span><span class="symbol">&amp;nbsp;</span> <span class="symbol">&amp;lt;</span> <span class="symbol">&amp;gt;</span> <span class="symbol">&amp;amp;</span> <span class="symbol">&amp;apos;</span> <span class="symbol">&amp;ensp;</span> <span class="symbol">&amp;emsp;</span><span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="view视图容器组件"><a href="#view视图容器组件" class="headerlink" title="view视图容器组件"></a>view视图容器组件</h3><blockquote><p>View 视图容器， 类似于 HTML 中的 div</p></blockquote><p><strong>1 - 组件的属性</strong></p><p><img src="https://img2.jimu98.cn/haley/20210128213649.png" alt="image-20210128213645210"></p><p><strong>2 - 代码案例</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span> <span class="attr">hover-class</span>=<span class="string">&quot;box2_active&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&#x27;box1&#x27;</span> <span class="attr">hover-class</span>=<span class="string">&#x27;active&#x27;</span> <span class="attr">hover-stop-propagation</span> <span class="attr">:hover-start-time</span>=<span class="string">&quot;2000&quot;</span> <span class="attr">:hover-stay-time</span>=<span class="string">&#x27;2000&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="button按钮组件"><a href="#button按钮组件" class="headerlink" title="button按钮组件"></a>button按钮组件</h3><p><strong>1 - 组件的属性</strong></p><table><thead><tr><th align="center">属性名</th><th align="center">类型</th><th align="center">默认值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">size</td><td align="center">String</td><td align="center">default</td><td align="center">按钮的大小</td></tr><tr><td align="center">type</td><td align="center">String</td><td align="center">default</td><td align="center">按钮的样式类型</td></tr><tr><td align="center">plain</td><td align="center">Boolean</td><td align="center">false</td><td align="center">按钮是否镂空，背景色透明</td></tr><tr><td align="center">disabled</td><td align="center">Boolean</td><td align="center">false</td><td align="center">是否按钮</td></tr><tr><td align="center">loading</td><td align="center">Boolean</td><td align="center">false</td><td align="center">名称是否带 loading 图标</td></tr></tbody></table><ul><li><code>button</code> 组件默认独占一行，设置 <code>size</code> 为 <code>mini</code> 时可以在一行显示多个</li></ul><p><strong>2 - 案例代码</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">size</span>=<span class="string">&#x27;mini&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;primary&#x27;</span>&gt;</span>前端<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">size</span>=<span class="string">&#x27;mini&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;default&#x27;</span> <span class="attr">disabled</span>=<span class="string">&#x27;true&#x27;</span>&gt;</span>前端<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">size</span>=<span class="string">&#x27;mini&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;warn&#x27;</span> <span class="attr">loading</span>=<span class="string">&#x27;true&#x27;</span>&gt;</span>前端<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="image组件"><a href="#image组件" class="headerlink" title="image组件"></a>image组件</h3><p><strong><a href="https://uniapp.dcloud.io/component/image?id=image">官网文档</a></strong></p><table><thead><tr><th>属性名</th><th>类型</th><th>默认值</th><th>说明</th><th>平台差异说明</th></tr></thead><tbody><tr><td>src</td><td>String</td><td></td><td>图片资源地址</td><td></td></tr><tr><td>mode</td><td>String</td><td>‘scaleToFill’</td><td>图片裁剪、缩放的模式</td><td></td></tr></tbody></table><p><strong>Tips</strong></p><ul><li><code>&lt;image&gt;</code> 组件默认宽度 300px、高度 240px；</li><li><code>mode</code>有13种模式，其中4种是缩放模式，9种是裁剪模式；</li><li><code>src</code> 仅支持相对路径、绝对路径，支持 base64 码；</li><li>页面结构复杂，css样式太多的情况，使用 image 可能导致样式生效较慢，出现 “闪一下” 的情况，此时设置 <code>image&#123;will-change: transform&#125;</code> ，可优化此问题。</li></ul><h2 id="uni-app中的样式"><a href="#uni-app中的样式" class="headerlink" title="uni-app中的样式"></a>uni-app中的样式</h2><ul><li><p>rpx 即响应式px，一种根据屏幕宽度自适应的动态单位。以750宽的屏幕为基准，750rpx恰好为屏幕宽度。屏幕变宽，rpx 实际显示效果会等比放大。</p></li><li><p>使用<code>@import</code>语句可以导入外联样式表，<code>@import</code>后跟需要导入的外联样式表的相对路径，用<code>;</code>表示语句结束</p><ul><li><pre><code class="js">@<span class="keyword">import</span> url(<span class="string">"./a.css"</span>)&lt;!--code￼<span class="number">7</span>--&gt;</code></pre></li><li><p>在全局或者页面的style标签内导入</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@impot</span> url(<span class="string">&quot;./static/fonts/iconfont.css&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>使用scss或者less</p><ul><li><p><code>工具</code>—<code>插件安装</code> 安装scss或less，就可以使用了</p></li><li><pre><code class="css">&lt;style lang="scss"&gt;&lt;/style&gt;&lt;!<span class="selector-tag">--code</span>￼9<span class="selector-tag">--</span>&gt;</code></pre></li></ul></li></ul><h3 id="插值表达式的使用"><a href="#插值表达式的使用" class="headerlink" title="插值表达式的使用"></a>插值表达式的使用</h3><ul><li><p>利用插值表达式渲染基本数据</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在插值表达式中使用三元运算</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>&#123;&#123; flag ? &#x27;我是真的&#x27;:&#x27;我是假的&#x27; &#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>基本运算</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>&#123;&#123;1+1&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="v-bind动态绑定属性"><a href="#v-bind动态绑定属性" class="headerlink" title="v-bind动态绑定属性"></a>v-bind动态绑定属性</h3><p>在data中定义了一张图片，我们希望把这张图片渲染到页面上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      img: <span class="string">&#x27;http://destiny001.gitee.io/image/monkey_02.jpg&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用v-bind进行渲染</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">image</span> <span class="attr">v-bind:src</span>=<span class="string">&quot;img&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br></pre></td></tr></table></figure><p>还可以缩写成:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">image</span> <span class="attr">:src</span>=<span class="string">&quot;img&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-for的使用"><a href="#v-for的使用" class="headerlink" title="v-for的使用"></a>v-for的使用</h3><p>data中定以一个数组，最终将数组渲染到页面上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">data () &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    arr: [</span><br><span class="line">&#123;<span class="attr">id</span>:<span class="number">0</span>, <span class="attr">name</span>:<span class="string">&#x27;刘能&#x27;</span>, <span class="attr">age</span>:<span class="number">28</span>&#125;,</span><br><span class="line">&#123;<span class="attr">id</span>:<span class="number">1</span>, <span class="attr">name</span>:<span class="string">&#x27;赵四&#x27;</span>, <span class="attr">age</span>:<span class="number">30</span>&#125;,</span><br><span class="line">&#123;<span class="attr">id</span>:<span class="number">2</span>, <span class="attr">name</span>:<span class="string">&#x27;谢广坤&#x27;</span>, <span class="attr">age</span>:<span class="number">60</span>&#125;</span><br><span class="line">]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用v-for进行循环</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;view v-<span class="keyword">for</span>=<span class="string">&quot;(item,index) in arr&quot;</span> :key=<span class="string">&quot;item.id&quot;</span>&gt;</span><br><span class="line">序号：&#123;&#123;index&#125;&#125;,名字：&#123;&#123;item.name&#125;&#125;,年龄：&#123;&#123;item.age&#125;&#125;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure><h2 id="uni中的事件"><a href="#uni中的事件" class="headerlink" title="uni中的事件"></a>uni中的事件</h2><h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><p>在uni中事件绑定和vue中是一样的，通过 <code>v-on</code> 进行事件的绑定，也可以简写为 <code>@</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;tapHandle&quot;</span>&gt;</span>点我啊<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>事件函数定义在methods中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  tapHandle () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;真的点我了&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事件传参"><a href="#事件传参" class="headerlink" title="事件传参"></a>事件传参</h3><ul><li><p>默认如果没有传递参数，事件函数第一个形参为事件对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; template</span><br><span class="line">&lt;button @click&#x3D;&quot;tapHandle&quot;&gt;点我啊&lt;&#x2F;button&gt;</span><br><span class="line">&#x2F;&#x2F; script</span><br><span class="line">methods: &#123;</span><br><span class="line">  tapHandle (e) &#123;</span><br><span class="line">    console.log(e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果给事件函数传递参数了，则对应的事件函数形参接收的则是传递过来的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; template</span><br><span class="line">&lt;button @click&#x3D;&quot;tapHandle(1)&quot;&gt;点我啊&lt;&#x2F;button&gt;</span><br><span class="line">&#x2F;&#x2F; script</span><br><span class="line">methods: &#123;</span><br><span class="line">  tapHandle (num) &#123;</span><br><span class="line">    console.log(num)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果获取事件对象也想传递参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; template</span><br><span class="line">&lt;button @click&#x3D;&quot;tapHandle(1,$event)&quot;&gt;点我啊&lt;&#x2F;button&gt;</span><br><span class="line">&#x2F;&#x2F; script</span><br><span class="line">methods: &#123;</span><br><span class="line">  tapHandle (num,e) &#123;</span><br><span class="line">    console.log(num,e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="uni的生命周期"><a href="#uni的生命周期" class="headerlink" title="uni的生命周期"></a>uni的生命周期</h2><h3 id="应用的生命周期"><a href="#应用的生命周期" class="headerlink" title="应用的生命周期"></a>应用的生命周期</h3><p>生命周期的概念：一个对象从创建、运行、销毁的整个过程被成为生命周期。</p><p>生命周期函数：在生命周期中每个阶段会伴随着每一个函数的触发，这些函数被称为生命周期函数</p><p><code>uni-app</code> 支持如下应用生命周期函数，定义在<code>App.vue</code>中：</p><table><thead><tr><th>函数名</th><th>说明</th></tr></thead><tbody><tr><td>onLaunch</td><td>当<code>uni-app</code> 初始化完成时触发（全局只触发一次）</td></tr><tr><td>onShow</td><td>当 <code>uni-app</code> 启动，或从后台进入前台显示</td></tr><tr><td>onHide</td><td>当 <code>uni-app</code> 从前台进入后台</td></tr><tr><td>onError</td><td>当 <code>uni-app</code> 报错时触发</td></tr></tbody></table><h3 id="页面的生命周期"><a href="#页面的生命周期" class="headerlink" title="页面的生命周期"></a>页面的生命周期</h3><p><code>uni-app</code> 支持如下页面生命周期函数：</p><table><thead><tr><th>函数名</th><th>说明</th><th>平台差异说明</th><th>最低版本</th></tr></thead><tbody><tr><td>onLoad</td><td>监听页面加载，其参数为上个页面传递的数据，参数类型为Object（用于页面传参），参考<a href="https://uniapp.dcloud.io/api/router?id=navigateto">示例</a></td><td></td><td></td></tr><tr><td>onShow</td><td>监听页面显示。页面每次出现在屏幕上都触发，包括从下级页面点返回露出当前页面</td><td></td><td></td></tr><tr><td>onReady</td><td>监听页面初次渲染完成。</td><td></td><td></td></tr><tr><td>onHide</td><td>监听页面隐藏</td><td></td><td></td></tr><tr><td>onUnload</td><td>监听页面卸载</td><td></td><td></td></tr></tbody></table><h2 id="下拉刷新"><a href="#下拉刷新" class="headerlink" title="下拉刷新"></a>下拉刷新</h2><h3 id="开启下拉刷新"><a href="#开启下拉刷新" class="headerlink" title="开启下拉刷新"></a>开启下拉刷新</h3><p>在uni-app中有两种方式开启下拉刷新</p><ul><li>需要在 <code>pages.json</code> 里，找到的当前页面的pages节点，并在 <code>style</code> 选项中开启 <code>enablePullDownRefresh</code></li><li>通过调用 <code>uni.startPullDownRefresh</code>方法来开启下拉刷新</li></ul><h4 id="通过配置文件开启"><a href="#通过配置文件开启" class="headerlink" title="通过配置文件开启"></a>通过配置文件开启</h4><p>创建list页面进行演示</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">杭州学科</span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">v-for</span>=<span class="string">&quot;(item,index) in arr&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br><span class="line">&#123;&#123;item&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">data () &#123;</span><br><span class="line"><span class="javascript"><span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">arr: [<span class="string">&#x27;前端&#x27;</span>,<span class="string">&#x27;java&#x27;</span>,<span class="string">&#x27;ui&#x27;</span>,<span class="string">&#x27;大数据&#x27;</span>]</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过pages.json文件中找到当前页面的pages节点，并在 <code>style</code> 选项中开启 <code>enablePullDownRefresh</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;path&quot;</span>:<span class="string">&quot;pages/list/list&quot;</span>,</span><br><span class="line">    <span class="string">&quot;style&quot;</span>:&#123;</span><br><span class="line">      <span class="string">&quot;enablePullDownRefresh&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通过API开启"><a href="#通过API开启" class="headerlink" title="通过API开启"></a>通过API开启</h4><p><a href="https://uniapp.dcloud.io/api/ui/pulldown">api文档</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uni.startPullDownRefresh()</span><br></pre></td></tr></table></figure><h3 id="监听下拉刷新"><a href="#监听下拉刷新" class="headerlink" title="监听下拉刷新"></a>监听下拉刷新</h3><p>通过onPullDownRefresh可以监听到下拉刷新的动作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      arr: [<span class="string">&#x27;前端&#x27;</span>,<span class="string">&#x27;java&#x27;</span>,<span class="string">&#x27;ui&#x27;</span>,<span class="string">&#x27;大数据&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    startPull () &#123;</span><br><span class="line">      uni.startPullDownRefresh()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  onPullDownRefresh () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;触发下拉刷新了&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关闭下拉刷新"><a href="#关闭下拉刷新" class="headerlink" title="关闭下拉刷新"></a>关闭下拉刷新</h3><p><code>uni.stopPullDownRefresh()</code></p><p>停止当前页面下拉刷新。</p><p>案例演示</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;startPull&quot;</span>&gt;</span>开启下拉刷新<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">v-for</span>=<span class="string">&quot;(item,index) in arr&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br><span class="line">&#123;&#123;item&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">data () &#123;</span><br><span class="line"><span class="javascript"><span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">arr: [<span class="string">&#x27;前端&#x27;</span>,<span class="string">&#x27;java&#x27;</span>,<span class="string">&#x27;ui&#x27;</span>,<span class="string">&#x27;大数据&#x27;</span>]</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">startPull () &#123;</span><br><span class="line">uni.startPullDownRefresh()</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">onPullDownRefresh () &#123;</span><br><span class="line"><span class="javascript"><span class="built_in">this</span>.arr = []</span></span><br><span class="line"><span class="javascript"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">this</span>.arr = [<span class="string">&#x27;前端&#x27;</span>,<span class="string">&#x27;java&#x27;</span>,<span class="string">&#x27;ui&#x27;</span>,<span class="string">&#x27;大数据&#x27;</span>]</span></span><br><span class="line">uni.stopPullDownRefresh()</span><br><span class="line">&#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="上拉加载"><a href="#上拉加载" class="headerlink" title="上拉加载"></a>上拉加载</h2><p>通过在pages.json文件中找到当前页面的pages节点下style中配置 <code>onReachBottomDistance</code>可以设置距离底部开启加载的距离，默认为50px</p><p>通过 <code>onReachBottom</code> 监听到触底的行为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;view&gt;</span><br><span class="line">&lt;button type=<span class="string">&quot;primary&quot;</span> @click=<span class="string">&quot;startPull&quot;</span>&gt;开启下拉刷新&lt;/button&gt;</span><br><span class="line">&lt;view v-<span class="keyword">for</span>=<span class="string">&quot;(item,index) in arr&quot;</span> :key=<span class="string">&quot;index&quot;</span>&gt;</span><br><span class="line">&#123;&#123;item&#125;&#125;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">data () &#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">arr: [<span class="string">&#x27;前端&#x27;</span>,<span class="string">&#x27;java&#x27;</span>,<span class="string">&#x27;ui&#x27;</span>,<span class="string">&#x27;大数据&#x27;</span>,<span class="string">&#x27;前端&#x27;</span>,<span class="string">&#x27;java&#x27;</span>,<span class="string">&#x27;ui&#x27;</span>,<span class="string">&#x27;大数据&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">onReachBottom () &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;触底了&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">view&#123;</span><br><span class="line">height: 100px;</span><br><span class="line">line-height: 100px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h2 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h2><p>在uni中可以调用 <code>uni.request</code> 方法进行请求网络请求</p><p>需要注意的是：在小程序中网络相关的 API 在使用前需要配置域名白名单。</p><h3 id="发送get请求"><a href="#发送get请求" class="headerlink" title="发送get请求"></a>发送get请求</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;view&gt;</span><br><span class="line">&lt;button @click=<span class="string">&quot;sendGet&quot;</span>&gt;发送请求&lt;/button&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">methods: &#123;</span><br><span class="line">sendGet () &#123;</span><br><span class="line">uni.request(&#123;</span><br><span class="line">url: <span class="string">&#x27;http://localhost:8082/api/getlunbo&#x27;</span>,</span><br><span class="line"><span class="function"><span class="title">success</span>(<span class="params">res</span>)</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="数据缓存"><a href="#数据缓存" class="headerlink" title="数据缓存"></a>数据缓存</h2><h3 id="uni-setStorage"><a href="#uni-setStorage" class="headerlink" title="uni.setStorage"></a>uni.setStorage</h3><p><a href="https://uniapp.dcloud.io/api/storage/storage?id=setstorage">官方文档</a></p><p>将数据存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，这是一个异步接口。</p><p>代码演示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;view&gt;</span><br><span class="line">&lt;button type=<span class="string">&quot;primary&quot;</span> @click=<span class="string">&quot;setStor&quot;</span>&gt;存储数据&lt;/button&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">methods: &#123;</span><br><span class="line">setStor () &#123;</span><br><span class="line">uni.setStorage(&#123;</span><br><span class="line"> key: <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line"> data: <span class="number">100</span>,</span><br><span class="line"> success () &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;存储成功&#x27;</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="uni-setStorageSync"><a href="#uni-setStorageSync" class="headerlink" title="uni.setStorageSync"></a>uni.setStorageSync</h3><p>将 data 存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，这是一个同步接口。</p><p>代码演示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;view&gt;</span><br><span class="line">&lt;button type=<span class="string">&quot;primary&quot;</span> @click=<span class="string">&quot;setStor&quot;</span>&gt;存储数据&lt;/button&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">methods: &#123;</span><br><span class="line">setStor () &#123;</span><br><span class="line">uni.setStorageSync(<span class="string">&#x27;id&#x27;</span>,<span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="uni-getStorage"><a href="#uni-getStorage" class="headerlink" title="uni.getStorage"></a>uni.getStorage</h3><p>从本地缓存中异步获取指定 key 对应的内容。</p><p>代码演示</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;getStorage&quot;</span>&gt;</span>获取数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">data () &#123;</span><br><span class="line"><span class="javascript"><span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">id: <span class="string">&#x27;&#x27;</span></span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">etStorage () &#123;</span><br><span class="line">uni.getStorage(&#123;</span><br><span class="line"><span class="javascript">key: <span class="string">&#x27;id&#x27;</span>,</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="title">success</span>(<span class="params">res</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(<span class="string">&#x27;获取成功&#x27;</span>,res.data)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="uni-getStorageSync"><a href="#uni-getStorageSync" class="headerlink" title="uni.getStorageSync"></a>uni.getStorageSync</h3><p>从本地缓存中同步获取指定 key 对应的内容。</p><p>代码演示</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;getStorage&quot;</span>&gt;</span>获取数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">methods: &#123;</span><br><span class="line">getStorage () &#123;</span><br><span class="line"><span class="javascript"><span class="keyword">const</span> id = uni.getStorageSync(<span class="string">&#x27;id&#x27;</span>)</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(id)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="uni-removeStorage"><a href="#uni-removeStorage" class="headerlink" title="uni.removeStorage"></a>uni.removeStorage</h3><p>从本地缓存中异步移除指定 key。</p><p>代码演示</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;removeStorage&quot;</span>&gt;</span>删除数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">methods: &#123;</span><br><span class="line">removeStorage () &#123;</span><br><span class="line">uni.removeStorage(&#123;</span><br><span class="line"><span class="javascript">key: <span class="string">&#x27;id&#x27;</span>,</span></span><br><span class="line"><span class="javascript">success: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(<span class="string">&#x27;删除成功&#x27;</span>)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="uni-removeStorageSync"><a href="#uni-removeStorageSync" class="headerlink" title="uni.removeStorageSync"></a>uni.removeStorageSync</h3><p>从本地缓存中同步移除指定 key。</p><p>代码演示</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;removeStorage&quot;</span>&gt;</span>删除数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">methods: &#123;</span><br><span class="line">removeStorage () &#123;</span><br><span class="line"><span class="javascript">uni.removeStorageSync(<span class="string">&#x27;id&#x27;</span>)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="上传图片、预览图片"><a href="#上传图片、预览图片" class="headerlink" title="上传图片、预览图片"></a>上传图片、预览图片</h2><h3 id="上传图片"><a href="#上传图片" class="headerlink" title="上传图片"></a>上传图片</h3><p><code>uni.chooseImage</code>方法从本地相册选择图片或使用相机拍照。</p><p>案例代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;chooseImg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span>&gt;</span>上传图片<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">image</span> <span class="attr">v-for</span>=<span class="string">&quot;item in imgArr&quot;</span> <span class="attr">:src</span>=<span class="string">&quot;item&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">data () &#123;</span><br><span class="line"><span class="javascript"><span class="keyword">return</span> &#123;</span></span><br><span class="line">imgArr: []</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">chooseImg () &#123;</span><br><span class="line">uni.chooseImage(&#123;</span><br><span class="line">count: 9,</span><br><span class="line"><span class="javascript">success: <span class="function"><span class="params">res</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">this</span>.imgArr = res.tempFilePaths</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="预览图片"><a href="#预览图片" class="headerlink" title="预览图片"></a>预览图片</h3><p>结构</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">image</span> <span class="attr">v-for</span>=<span class="string">&quot;item in imgArr&quot;</span> <span class="attr">:src</span>=<span class="string">&quot;item&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;previewImg(item)&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><p>预览图片的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">previewImg (current) &#123;</span><br><span class="line">  uni.previewImage(&#123;</span><br><span class="line">    urls: <span class="built_in">this</span>.imgArr,</span><br><span class="line">    current,</span><br><span class="line">    loop:<span class="literal">true</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条件注释实现跨段兼容"><a href="#条件注释实现跨段兼容" class="headerlink" title="条件注释实现跨段兼容"></a>条件注释实现跨段兼容</h2><p>条件编译是用特殊的注释作为标记，在编译时根据这些特殊的注释，将注释里面的代码编译到不同平台。</p><p><strong>写法：</strong>以 #ifdef 加平台标识 开头，以 #endif 结尾。</p><p>平台标识</p><table><thead><tr><th>值</th><th>平台</th><th>参考文档</th></tr></thead><tbody><tr><td>APP-PLUS</td><td>5+App</td><td><a href="http://www.html5plus.org/doc/">HTML5+ 规范</a></td></tr><tr><td>H5</td><td>H5</td><td></td></tr><tr><td>MP-WEIXIN</td><td>微信小程序</td><td><a href="https://developers.weixin.qq.com/miniprogram/dev/api/">微信小程序</a></td></tr><tr><td>MP-ALIPAY</td><td>支付宝小程序</td><td><a href="https://docs.alipay.com/mini/developer/getting-started">支付宝小程序</a></td></tr><tr><td>MP-BAIDU</td><td>百度小程序</td><td><a href="https://smartprogram.baidu.com/docs/develop/tutorial/codedir/">百度小程序</a></td></tr><tr><td>MP-TOUTIAO</td><td>头条小程序</td><td><a href="https://developer.toutiao.com/dev/cn/mini-app/develop/framework/basic-reference/introduction">头条小程序</a></td></tr><tr><td>MP-QQ</td><td>QQ小程序</td><td>（目前仅cli版支持）</td></tr><tr><td>MP</td><td>微信小程序/支付宝小程序/百度小程序/头条小程序/QQ小程序</td><td></td></tr></tbody></table><h3 id="组件的条件注释"><a href="#组件的条件注释" class="headerlink" title="组件的条件注释"></a>组件的条件注释</h3><p>代码演示</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- #ifdef H5 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">  h5页面会显示</span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- #endif --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- #ifdef MP-WEIXIN --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">  微信小程序会显示</span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- #endif --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- #ifdef APP-PLUS --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">  app会显示</span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- #endif --&gt;</span></span><br></pre></td></tr></table></figure><h3 id="api的条件注释"><a href="#api的条件注释" class="headerlink" title="api的条件注释"></a>api的条件注释</h3><p>代码演示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">onLoad () &#123;</span><br><span class="line">  <span class="comment">//#ifdef MP-WEIXIN</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;微信小程序&#x27;</span>)</span><br><span class="line">  <span class="comment">//#endif</span></span><br><span class="line">  <span class="comment">//#ifdef H5</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;h5页面&#x27;</span>)</span><br><span class="line">  <span class="comment">//#endif</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>样式的条件注释</p><p>代码演示</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* #ifdef H5 */</span></span><br><span class="line">view&#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* #endif */</span></span><br><span class="line"><span class="comment">/* #ifdef MP-WEIXIN */</span></span><br><span class="line">view&#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* #endif */</span></span><br></pre></td></tr></table></figure><h2 id="uni中的导航跳转"><a href="#uni中的导航跳转" class="headerlink" title="uni中的导航跳转"></a>uni中的导航跳转</h2><h3 id="利用navigator进行跳转"><a href="#利用navigator进行跳转" class="headerlink" title="利用navigator进行跳转"></a>利用navigator进行跳转</h3><p>navigator详细文档：<a href="https://uniapp.dcloud.io/component/navigator">文档地址</a></p><p>跳转到普通页面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigator</span> <span class="attr">url</span>=<span class="string">&quot;/pages/about/about&quot;</span> <span class="attr">hover-class</span>=<span class="string">&quot;navigator-hover&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;default&quot;</span>&gt;</span>跳转到关于页面<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">navigator</span>&gt;</span></span><br></pre></td></tr></table></figure><p>跳转到tabbar页面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigator</span> <span class="attr">url</span>=<span class="string">&quot;/pages/message/message&quot;</span> <span class="attr">open-type</span>=<span class="string">&quot;switchTab&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;default&quot;</span>&gt;</span>跳转到message页面<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">navigator</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="利用编程式导航进行跳转"><a href="#利用编程式导航进行跳转" class="headerlink" title="利用编程式导航进行跳转"></a>利用编程式导航进行跳转</h3><p><a href="[uni.navigateTo](https://uniapp.dcloud.io/api/router?id=navigateto)">导航跳转文档</a></p><p><strong>利用navigateTo进行导航跳转</strong></p><p>保留当前页面，跳转到应用内的某个页面，使用<code>uni.navigateBack</code>可以返回到原页面。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;goAbout&quot;</span>&gt;</span>跳转到关于页面<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过navigateTo方法进行跳转到普通页面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">goAbout () &#123;</span><br><span class="line">  uni.navigateTo(&#123;</span><br><span class="line">    url: <span class="string">&#x27;/pages/about/about&#x27;</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过switchTab跳转到tabbar页面</strong></p><p>跳转到tabbar页面，只要不是tabbar都关闭。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;goMessage&quot;</span>&gt;</span>跳转到message页面<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过switchTab方法进行跳转</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">goMessage () &#123;</span><br><span class="line">  uni.switchTab(&#123;</span><br><span class="line">    url: <span class="string">&#x27;/pages/message/message&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>redirectTo进行跳转</strong> </p><p>关闭当前页面，跳转到应用内的某个页面。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- template --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;goMessage&quot;</span>&gt;</span>跳转到message页面<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- js --&gt;</span></span><br><span class="line">goMessage () &#123;</span><br><span class="line">  uni.redirectTo(&#123;</span><br><span class="line">    url: &#x27;/pages/message/message&#x27;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过onUnload测试当前组件确实卸载</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onUnload () &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;组件卸载了&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="导航跳转传递参数"><a href="#导航跳转传递参数" class="headerlink" title="导航跳转传递参数"></a>导航跳转传递参数</h3><p>在导航进行跳转到下一个页面的同时，可以给下一个页面传递相应的参数，接收参数的页面可以通过onLoad生命周期进行接收</p><p>传递参数的页面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">goAbout () &#123;</span><br><span class="line">  uni.navigateTo(&#123;</span><br><span class="line">    url: <span class="string">&#x27;/pages/about/about?id=80&amp;age=19&#x27;</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收参数的页面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">onLoad (options) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(options)   <span class="comment">// &#123;id:80,age:19&#125;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="uni-app中组件的创建"><a href="#uni-app中组件的创建" class="headerlink" title="uni-app中组件的创建"></a>uni-app中组件的创建</h2><p>在uni-app中，可以通过创建一个后缀名为vue的文件，即创建一个组件成功，其他组件可以将该组件通过import的方式导入，在通过components进行注册即可</p><ul><li><p>创建login组件，在component中创建test目录，然后新建test.vue文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;view&gt;</span><br><span class="line">这是一个自定义组件</span><br><span class="line">&lt;&#x2F;view&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><script></script><style></style><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">+ 在其他组件中导入该组件并注册</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;vue</span><br><span class="line">  import test from &quot;@&#x2F;components&#x2F;test&#x2F;test.vue&quot;</span><br></pre></td></tr></table></figure></li><li><p>注册组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">components: &#123;test&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;test&gt;&lt;&#x2F;test&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="组件的生命周期函数"><a href="#组件的生命周期函数" class="headerlink" title="组件的生命周期函数"></a>组件的生命周期函数</h2><table><thead><tr><th>beforeCreate</th><th>在实例初始化之后被调用。<a href="https://cn.vuejs.org/v2/api/#beforeCreate">详见</a></th><th></th><th></th></tr></thead><tbody><tr><td>created</td><td>在实例创建完成后被立即调用。<a href="https://cn.vuejs.org/v2/api/#created">详见</a></td><td></td><td></td></tr><tr><td>beforeMount</td><td>在挂载开始之前被调用。<a href="https://cn.vuejs.org/v2/api/#beforeMount">详见</a></td><td></td><td></td></tr><tr><td>mounted</td><td>挂载到实例上去之后调用。<a href="https://cn.vuejs.org/v2/api/#mounted">详见</a> 注意：此处并不能确定子组件被全部挂载，如果需要子组件完全挂载之后在执行操作可以使用<code>$nextTick</code><a href="https://cn.vuejs.org/v2/api/#Vue-nextTick">Vue官方文档</a></td><td></td><td></td></tr><tr><td>beforeUpdate</td><td>数据更新时调用，发生在虚拟 DOM 打补丁之前。<a href="https://cn.vuejs.org/v2/api/#beforeUpdate">详见</a></td><td>仅H5平台支持</td><td></td></tr><tr><td>updated</td><td>由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。<a href="https://cn.vuejs.org/v2/api/#updated">详见</a></td><td>仅H5平台支持</td><td></td></tr><tr><td>beforeDestroy</td><td>实例销毁之前调用。在这一步，实例仍然完全可用。<a href="https://cn.vuejs.org/v2/api/#beforeDestroy">详见</a></td><td></td><td></td></tr><tr><td>destroyed</td><td>Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。<a href="https://cn.vuejs.org/v2/api/#destroyed">详见</a></td><td></td><td></td></tr></tbody></table><h2 id="组件的通讯"><a href="#组件的通讯" class="headerlink" title="组件的通讯"></a>组件的通讯</h2><h3 id="父组件给子组件传值"><a href="#父组件给子组件传值" class="headerlink" title="父组件给子组件传值"></a>父组件给子组件传值</h3><p>通过props来接受外界传递到组件内部的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;view&gt;</span><br><span class="line">这是一个自定义组件 &#123;&#123;msg&#125;&#125;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">props: [&#39;msg&#39;]</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>其他组件在使用login组件的时候传递值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;view&gt;</span><br><span class="line">&lt;test :msg&#x3D;&quot;msg&quot;&gt;&lt;&#x2F;test&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import test from &quot;@&#x2F;components&#x2F;test&#x2F;test.vue&quot;</span><br><span class="line">export default &#123;</span><br><span class="line">data () &#123;</span><br><span class="line">return &#123;</span><br><span class="line">msg: &#39;hello&#39;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">components: &#123;test&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="子组件给父组件传值"><a href="#子组件给父组件传值" class="headerlink" title="子组件给父组件传值"></a>子组件给父组件传值</h3><p>通过$emit触发事件进行传递参数</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">这是一个自定义组件 &#123;&#123;msg&#125;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;sendMsg&quot;</span>&gt;</span>给父组件传值<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">data () &#123;</span><br><span class="line"><span class="javascript"><span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">status: <span class="string">&#x27;打篮球&#x27;</span></span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">props: &#123;</span><br><span class="line">msg: &#123;</span><br><span class="line"><span class="javascript">type: <span class="built_in">String</span>,</span></span><br><span class="line"><span class="javascript">value: <span class="string">&#x27;&#x27;</span></span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">sendMsg () &#123;</span><br><span class="line"><span class="javascript"><span class="built_in">this</span>.$emit(<span class="string">&#x27;myEvent&#x27;</span>,<span class="built_in">this</span>.status)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>父组件定义自定义事件并接收参数</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">test</span> <span class="attr">:msg</span>=<span class="string">&quot;msg&quot;</span> @<span class="attr">myEvent</span>=<span class="string">&quot;getMsg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> test <span class="keyword">from</span> <span class="string">&quot;@/components/test/test.vue&quot;</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">data () &#123;</span><br><span class="line"><span class="javascript"><span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">msg: <span class="string">&#x27;hello&#x27;</span></span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">getMsg (res) &#123;</span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(res)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">components: &#123;test&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="兄弟组件通讯"><a href="#兄弟组件通讯" class="headerlink" title="兄弟组件通讯"></a>兄弟组件通讯</h3><h2 id="uni-ui的使用"><a href="#uni-ui的使用" class="headerlink" title="uni-ui的使用"></a>uni-ui的使用</h2><p><a href="https://uniapp.dcloud.io/component/README?id=uniui">uni-ui文档</a></p><p>1、进入Grid宫格组件</p><p>2、使用HBuilderX导入该组件</p><p>3、导入该组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import uniGrid from &quot;@/components/uni-grid/uni-grid.vue&quot;</span><br><span class="line">import uniGridItem from &quot;@/components/uni-grid-item/uni-grid-item.vue&quot;</span><br></pre></td></tr></table></figure><p>4、注册组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">components: &#123;uniGrid,uniGridItem&#125;</span><br></pre></td></tr></table></figure><p>5、使用组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uni-grid</span> <span class="attr">:column</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">uni-grid-item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span>文本<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">uni-grid-item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">uni-grid-item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span>文本<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">uni-grid-item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">uni-grid-item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span>文本<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">uni-grid-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">uni-grid</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><h3 id="微信小程序打包"><a href="#微信小程序打包" class="headerlink" title="微信小程序打包"></a>微信小程序打包</h3><p>1、打开<code>manifest.json</code>文件，选择微信小程序配置，AppID必须填。</p><p>2、打开微信开发者工具，点击上传，即可在<code>开发-版本管理</code>内看到。</p><h3 id="H5打包"><a href="#H5打包" class="headerlink" title="H5打包"></a>H5打包</h3><p>打开<code>manifest.json</code>文件，选择h5配置</p><p>配置完成后，点击<code>发行-网站-H5手机版(仅适用于uni-app)(H)</code></p><h3 id="App打包"><a href="#App打包" class="headerlink" title="App打包"></a>App打包</h3><p>打开<code>manifest.json</code>文件，进行App配置</p><p>2、选择<code>发行-原生App云打包</code>，测试选择<code>使用公共测试证书</code>，正式发布选择<code>使用自有证书</code>，根据<code>如何生成证书</code>的步骤进行操作即可。</p><p>3、点击<code>打包</code>，会生成一个链接，根据该链接生成二维码，然后即可下载。</p>]]></content>
      
      
      <categories>
          
          <category> 小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> uni-app </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云视听项目展示</title>
      <link href="posts/56243/"/>
      <url>posts/56243/</url>
      
        <content type="html"><![CDATA[<h1 id="云视听小程序展示"><a href="#云视听小程序展示" class="headerlink" title="云视听小程序展示"></a>云视听小程序展示</h1><h2 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h2><p>该项目是一款关于音乐的微信小程序，该项目的所有接口使用的都是网易云提供的开放接口，最终请求的地址是自己使用NodeJS搭建的服务器接口，由NodeJS转发给网易云音乐的服务器，实现了接口的规范化和统一化。</p><p>本项目对首页、音乐播放、视频播放、排行榜、每日推荐等页面进行了实现。</p><h2 id="项目展示"><a href="#项目展示" class="headerlink" title="项目展示"></a>项目展示</h2><h3 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h3><p><img src="https://img2.jimu98.cn/haley/20210307222042.jpeg" alt=""></p><p><img src="https://img2.jimu98.cn/haley/20210307222120.jpeg" alt=""></p><h3 id="未登录"><a href="#未登录" class="headerlink" title="未登录"></a>未登录</h3><p><img src="https://img2.jimu98.cn/haley/20210307222148.jpeg" alt=""></p><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p><img src="https://img2.jimu98.cn/haley/20210307222242.jpeg" alt=""></p><h3 id="已登录"><a href="#已登录" class="headerlink" title="已登录"></a>已登录</h3><p><img src="https://img2.jimu98.cn/haley/20210307222301.jpeg" alt=""></p><h3 id="每日推荐"><a href="#每日推荐" class="headerlink" title="每日推荐"></a>每日推荐</h3><p><img src="https://img2.jimu98.cn/haley/20210307222347.jpeg" alt=""></p><h3 id="播放音乐"><a href="#播放音乐" class="headerlink" title="播放音乐"></a>播放音乐</h3><p><img src="https://img2.jimu98.cn/haley/20210307222411.jpeg" alt=""></p><h3 id="视频页面"><a href="#视频页面" class="headerlink" title="视频页面"></a>视频页面</h3><p><img src="https://img2.jimu98.cn/haley/20210307222441.jpeg" alt=""></p><h3 id="搜索页面"><a href="#搜索页面" class="headerlink" title="搜索页面"></a>搜索页面</h3><p><img src="https://img2.jimu98.cn/haley/20210307222523.jpeg" alt=""></p><p><img src="https://img2.jimu98.cn/haley/20210307222543.jpeg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 项目展示 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>函数的节流与防抖</title>
      <link href="posts/2443/"/>
      <url>posts/2443/</url>
      
        <content type="html"><![CDATA[<h1 id="函数的节流与防抖"><a href="#函数的节流与防抖" class="headerlink" title="函数的节流与防抖"></a>函数的节流与防抖</h1><h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><p>在前端开发的过程中，我们经常会需要绑定一些持续触发的事件，如 resize、scroll、mousemove 等等，但有些时候我们并不希望在事件持续触发的过程中那么频繁地去执行函数。</p><p>函数节流和函数防抖，两者都是优化高频率执行js代码的一种手段。</p><p><strong>函数节流</strong>是指一定时间内js方法只跑一次。比如人的眨眼睛，就是一定时间内眨一次。</p><p><strong>函数防抖</strong>是指频繁触发的情况下，只有足够的空闲时间，才执行代码一次。比如生活中的坐公交，就是一定时间内，如果有人陆续刷卡上车，司机就不会开车。只有别人没刷卡了，司机才开车。</p><h2 id="二、函数防抖"><a href="#二、函数防抖" class="headerlink" title="二、函数防抖"></a>二、函数防抖</h2><p>所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timer; <span class="comment">// 维护一个 timer</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> _this = <span class="built_in">this</span>; <span class="comment">// 取debounce执行作用域的this</span></span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        &#125;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            fn.apply(_this, args);</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>连续的时间，只需触发一次回调：</p><p>1、搜索框搜索输入，只需要再用户最后一次输入完，再发送请求</p><p>2、手机号或者邮箱验证</p><h2 id="三、函数节流"><a href="#三、函数节流" class="headerlink" title="三、函数节流"></a>三、函数节流</h2><p>所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。节流会稀释函数的执行频率。</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> run = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!run) &#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="comment">// 如果开关关闭了，那就直接不执行下边的代码</span></span><br><span class="line">      &#125;</span><br><span class="line">      run = <span class="literal">false</span> <span class="comment">// 持续触发的话，run一直是false，就会停在上边的判断那里</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        func.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">        run = <span class="literal">true</span> <span class="comment">// 定时器到时间之后，会把开关打开，我们的函数就会被执行</span></span><br><span class="line">      &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p>间隔一段时间执行一次回调：</p><p>1、滚动加载，加载更多或者是滚动到底部进行监听</p><p>2、高频的点击提交，表单重复提交</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 节流 </tag>
            
            <tag> 防抖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js的事件循环机制</title>
      <link href="posts/11076/"/>
      <url>posts/11076/</url>
      
        <content type="html"><![CDATA[<h1 id="js的事件循环机制"><a href="#js的事件循环机制" class="headerlink" title="js的事件循环机制"></a>js的事件循环机制</h1><h2 id="1、关于JavaScript"><a href="#1、关于JavaScript" class="headerlink" title="1、关于JavaScript"></a>1、关于JavaScript</h2><p>我们都知道，javascript从诞生之日起就是一门单线程的非阻塞的脚本语言。这是由其最初的用途来决定的：<strong>与浏览器交互</strong>。</p><p>单线程是必要的，也是javascript这门语言的基石，原因之一在其最初也是最主要的执行环境——浏览器中，我们需要进行各种各样的dom操作。试想一下 如果javascript是多线程的，那么当两个线程同时对dom进行一项操作，例如一个向其添加事件，而另一个删除了这个dom，此时该如何处理呢？因此，为了保证不会 发生类似于这个例子中的情景，javascript选择只用一个主线程来执行代码，这样就保证了程序执行的一致性。</p><p>当然现如今人们也意识到，单线程在保证了执行顺序的同时也限制了javascript的效率，因此开发出了web worker技术。这项技术号称让javascript成为一门多线程语言。然而，使用web worker技术开的多线程有着诸多限制，例如：所有新线程都受主线程的完全控制，不能独立执行。这意味着这些“线程” 实际上应属于主线程的子线程。另外，这些子线程并没有执行I/O操作的权限，只能为主线程分担一些诸如计算等任务。所以严格来讲这些线程并没有完整的功能，也因此这项技术并非改变了javascript语言的单线程本质。</p><p>可以预见，未来的javascript也会一直是一门单线程的语言。</p><p>话说回来，前面提到javascript的另一个特点是“非阻塞”，那么javascript引擎到底是如何实现的这一点呢？答案就是今天这篇文章的主角——<code>event loop(事件循环)</code>。</p><h2 id="2、JavaScript的同步和异步"><a href="#2、JavaScript的同步和异步" class="headerlink" title="2、JavaScript的同步和异步"></a>2、JavaScript的同步和异步</h2><p>单线程意味着，javascript代码在执行的任何时候，都只有一个主线程来处理所有的任务。而非阻塞则是当代码需要进行一项异步任务(无法立刻返回结果，需要花一定时间才能返回的任务，如I/O事件)的时候，主线程会挂起(pending)这个任务，然后在异步任务返回结果的时候再根据一定规则去执行相应的回调。</p><p>于是，所有任务可以分成两种，一种是同步任务，另一种是异步任务。</p><p>同步任务指的是在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；</p><p>异步任务指的是不进入主线程，而进入”任务队列”(task queue)的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p><p><img src="https://img2.jimu98.cn/haley/20210309164340.png" alt="image-20210309164339994"></p><p><strong>执行过程：</strong></p><p>1、同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。<br>2、当Event Table中指定的事情完成时，会将这个函数移入Event Queue。<br>3、主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。<br>4、上述过程会不断重复，也就是常说的Event Loop(事件循环)。<br>5、我们不禁要问了，那怎么知道主线程执行栈为空啊？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。</p><h2 id="3、JavaScript的宏任务和微任务"><a href="#3、JavaScript的宏任务和微任务" class="headerlink" title="3、JavaScript的宏任务和微任务"></a>3、JavaScript的宏任务和微任务</h2><p>你是否觉得同步异步的执行机制流程就是JavaScript执行机制的全部？不是的，JavaScript除了广义上的的同步任务何异步任务，其对任务还有更精细的定义：<br>macro-task(宏任务)：包括整体代码script，setTimeout，setInterval<br>micro-task(微任务)：Promise，process.nextTick<br>不同类型的任务会进入对应的Event Queue。<br>事件循环的顺序，决定js代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。</p><p><img src="https://img2.jimu98.cn/haley/20210309164831.png" alt="image-20210309164831709"></p><h2 id="4、具体例子"><a href="#4、具体例子" class="headerlink" title="4、具体例子"></a>4、具体例子</h2><p><strong>第一题：</strong></p><p>同步任务按照顺序一步一步执行；异步任务放入消息队列中，等待同步任务执行结束，读取消息队列执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 执行结果：1 3 2 </span></span><br></pre></td></tr></table></figure><p><strong>第二题：</strong></p><p>当同步事件完成了，便从Event Queue中读取事件执行。因为3的事情先完成了，所以先从Event table中注册到Event Queue中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line"><span class="comment">// 执行结果：1 4 3 2</span></span><br></pre></td></tr></table></figure><p><strong>第三题：</strong></p><p><strong>第四题：</strong></p><p>1、首先执行同步代码，输出 <code>script start</code></p><p>2、调用函数async1，输出 <code>async1 start</code>，接着调用函数async2，输出<code>async2</code>，await后面的代码会放入到微任务队列里</p><p>3、接着往下执行同步promise，输出 <code>promise1</code>，调用resolve()，将then放入微任务队列</p><p>4、输出同步代码 <code>script end</code></p><p>5、接着去微任务队列，清空微任务队列，输出 <code>async1 end</code> 和 <code>promise2</code></p><p>6、执行异步任务setTimeout，输出 <code>setTimeout</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"> </span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;async1 start&#x27;</span>);</span><br><span class="line"> <span class="keyword">await</span> async2( );</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"> </span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;async2&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"> </span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">async1( );</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">resolve( );</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"> </span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>);</span><br><span class="line"><span class="comment">// 执行结果：script start   async1 start   async2   promise1   script end async1 end   promise2   setTimeout</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 事件循环机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flex</title>
      <link href="posts/10238/"/>
      <url>posts/10238/</url>
      
        <content type="html"><![CDATA[<h1 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h1><p>flex是CSS中 的又一种布局手段，它主要用来代替浮动完成页面的布局。</p><p>flex可以使元素具有弹性，让元素可以跟随页面大小的改变而改变。</p><p>flex是一种弹性盒子的布局方式，抛弃原来的float布局方式，<code>float、clear、vertical-align</code>禁止使用。</p><h2 id="flex核心"><a href="#flex核心" class="headerlink" title="flex核心"></a>flex核心</h2><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>如果要使用弹性盒，必须先将一个元素设置为弹性容器。</p><ul><li>我们通过display来设置弹性容器</li><li><code>display:flex</code> 设置为块级弹性容器</li><li><code>display:inline-flex</code> 设置为行内的弹性容器</li></ul><h3 id="容器的轴线"><a href="#容器的轴线" class="headerlink" title="容器的轴线"></a>容器的轴线</h3><p>分横向和纵向，默认主轴线是横轴</p><h3 id="项目-弹性元素"><a href="#项目-弹性元素" class="headerlink" title="项目(弹性元素)"></a>项目(弹性元素)</h3><p>弹性容器的子元素就是弹性元素（弹性项）</p><p>弹性元素可以同时是弹性容器</p><p>项目在主轴方向上并不会超出盒子，而且项目按照容器的主轴线进行排列。</p><p>项目会自动转换为块元素。</p><p>项目如果没有设置高度，默认和容器的高度一致。</p><h2 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h2><h3 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h3><p><code>flex-direction</code>：指定容器中弹性元素的排列方式</p><ul><li><p><code>row</code>：默认值，弹性元素在容器中水平排列（左向右）主轴：自左向右</p></li><li><p><code>row-reverse</code>：弹性元素在容器中反向水平排列（右向左）主轴：自右向左</p></li><li><p><code>column</code>：弹性元素纵向排列（自上向下）</p></li><li><p><code>column-reverse</code>：反向纵向排列（自下向上）</p></li></ul><h3 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h3><p><code>flex-wrap</code>：设置弹性元素是否在弹性容器中自动换行</p><ul><li><p><code>nowwrap</code>：默认值，元素不会自动换行</p><p><img src="https://img2.jimu98.cn/haley/20201018164527.png" alt="image-20201018164526922"></p></li><li><p><code>wrap</code>：元素沿着辅轴方向自动换行(第一行在上方)</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201018164347522.png" alt="image-20201018164347522">)<code>reverse</code>：元素沿着辅轴的反方向换行(第一行在下方)</p><p><img src="https://img2.jimu98.cn/haley/20201018164438.png" alt="image-20201018164438357"></p></li></ul><h3 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h3><p><code>flex-flow</code>是<code>flex-wrap</code>和<code>flex-direction</code>的简写属性</p><p>例：flex-flow：row  wrap-reverse</p><h3 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h3><p><code>justify-content</code>：主轴上的元素的排列方式</p><ul><li><p><code>flex-start</code>（默认值）：左对齐</p></li><li><p><code>flex-end</code>：右对齐</p></li><li><p><code>center</code>： 居中</p></li><li><p><code>space-between</code>：两端对齐，项目之间的间隔都相等。</p></li><li><p><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</p></li><li><p><code>space-evenly</code>：空白部分分布到元素的单侧</p></li></ul><h3 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h3><p><code>align-items</code>：元素在副轴上对齐的对齐方式</p><ul><li><p><code>stretch</code> ：默认值，将元素的长度设置为相同的值</p></li><li><p><code>flex-start</code> ：元素不会拉伸，沿着辅轴的起边对齐</p></li><li><p><code>flex-end</code> ：沿着辅轴的终边对齐</p></li><li><p><code>center</code> ：居中对齐</p></li><li><p><code>baseline</code> ：基线对齐</p></li></ul><p>如果项目没有设置副轴方向上的大小默认和容器副轴的大小一致，设置了align-items项目的大小，就是项目本身的大小。</p><h3 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h3><p><code>align-content</code>：多轴线(换行)行在副轴上的对齐方式</p><ul><li><code>flex-start</code>：与交叉轴的起点对齐。</li><li><code>flex-end</code>：与交叉轴的终点对齐。</li><li><code>center</code>：与交叉轴的中点对齐。</li><li><code>space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布。</li><li><code>space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li><li><code>stretch</code>（默认值）：轴线占满整个交叉轴。</li></ul><h2 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h2><h3 id="order"><a href="#order" class="headerlink" title="order"></a>order</h3><p><code>order</code>： 决定弹性元素的排列顺序，值越小，排列越前，默认为0</p><h3 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h3><p><code>flex-grow</code>：定义弹性元素的放大比例。</p><ul><li>0：默认值，即有空余空间，也不放大。</li><li>1：占满容器的剩余空间，如果多个弹性元素都设置了，根据比例放大。</li><li>1以上：会按照比例分配剩余空间</li></ul><h3 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h3><p><code>flex-shrink</code>：定义弹性元素的缩小比例</p><ul><li>1：默认值，空间不足时，等比例收缩</li><li>0：不允许缩小</li><li>值越大，收缩的越多</li></ul><h3 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h3><p><code>flex-basis</code>：指定的是元素在主轴上的基础长度</p><ul><li><p>如果主轴是横向的，则该值指定的就是元素的宽度</p></li><li><p>如果主轴是纵向的，则该值指定的就是元素的高度</p></li><li><p>默认值是auto，表示参考元素自身的高度和宽度</p></li><li><p>如果传递了一个具体的数值，则以该值为准。</p></li></ul><h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><p><code>flex</code>属性是<code>flex-grow</code>、 <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code></p><h3 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h3><p><code>align-self</code>：用来覆盖当前弹性元素上的align-items，值和align-items一样，可以给单个的弹性元素指定样式。</p><p>注意：如果是移动端就可以用，如果是Pc端就要考虑兼容问题。</p>]]></content>
      
      
      <categories>
          
          <category> 布局 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flex </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js</title>
      <link href="posts/5063/"/>
      <url>posts/5063/</url>
      
        <content type="html"><![CDATA[<h1 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h1><h2 id="node简介"><a href="#node简介" class="headerlink" title="node简介"></a>node简介</h2><p>Node.js是一个基于Chrome V8引擎的JavaScript运行时。 </p><p>通过node，可以使js代码在服务器端执行。</p><p>Node仅仅对Es标准进行了实现，所以在Node中不包含DOM和BOM</p><ul><li>node中可以使用所有的内建对象(String Number Boolean Math Date RegExp Function object Array)。而BOM和DOM都不能使用，但是可以使用console，也可以使用定时器(setTimeout()、setInterval())</li></ul><p>Node可以在后台用来编写服务器。Node编写服务器都是单线程的服务器。</p><p>进程和线程</p><ul><li>进程就是—个一个的工作计划(工厂中的车间)</li><li>线程是计算机最小的运算单位(工厂中的工人)</li></ul><p>传统的服务器都是多线程的，每进来一个请求，就创建—个线程去处理请求。</p><p>node的请求是单线程的，node处理请求时是单线程，但是在后台拥有一个I/O线程池</p><h2 id="node-js的安装"><a href="#node-js的安装" class="headerlink" title="node.js的安装"></a>node.js的安装</h2><p>百度node，进入中文网直接下载安装包，直接进行安装不需要做任何的选择，一直下一步即可。任意位置打开命令行工具，输入 <code>node -v</code> 和 <code>npm -v</code> 查看 node 和 npm 的版本号，如果有就安装好了，如果命令出错尝试重启电脑再次执行。</p><p>npm：安装好node之后，npm就附带安装好了。它是node包管理工具(node package manager)</p><h2 id="node-模块使用"><a href="#node-模块使用" class="headerlink" title="node 模块使用"></a>node 模块使用</h2><ul><li>新建文件夹，将该文件夹初始化为 node(npm) 项目，执行 <code>npm init -y</code></li><li>新建 index.html 页面</li><li>安装 jquery 插件。执行 <code>npm install jquery</code></li><li>安装完毕之后，项目内多出两个文件<ul><li>node_modules 文件夹：存储下载的包的文件夹</li><li>package-lock.json 文件：该文件记录安装的包的详细信息</li></ul></li><li>在 html 中使用 jquery 可以按照之前的路径导入(不推荐)。现在我们使用 npm 下载模块。可以使用 node 模块的方式导入安装好的包。 使用 <code>require(包名)</code>，但是当做模块导入之后浏览器会报错。因为模块语法浏览器不支持，需要编译。我们可以使用webpack打包编译。</li><li>但是如果我们只是想运行js文件，则直接在命令行窗口执行<code>node js文件名</code>就可以看到我们导入文件的运行结果了。</li></ul><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><h3 id="1、模块分类"><a href="#1、模块分类" class="headerlink" title="1、模块分类"></a>1、模块分类</h3><p>核心模块：由node引擎提供的模块，核心模块的标识就是模块的名字。</p><p>文件模块：由用户自己创建的模块，文件模块的标识就是文件的路径(绝对路径，相对路径)。</p><h3 id="2、模块的定义"><a href="#2、模块的定义" class="headerlink" title="2、模块的定义"></a>2、模块的定义</h3><p>① 在node中，一个js文件就是一个模块</p><p>② 在Node中，每一个js文件中的js代码都是独立运行在一个函数中，而不是全局作用域，所以一个模块中的变量和函数在其他模块中无法访问。</p><p>③ 在node中有一个全局对象global，它的作用和网页中window类似</p><ul><li><p>在全局中创建的变量都会作为global的属性保存</p></li><li><p>在全局中创建的函数都会作为global的方法保存</p></li><li><p>实际上模块中的代码都是包装在一个函数中执行的，并且在函数执行时，同时传递进了5个实参。</p><ul><li>exports：该对象用来将变量或函数暴露到外部</li><li>require：函数，用来引入外部的模块</li><li>module：代表的是当前模块本身，exports就是module的属性，既可以使用exports导出，也可以使用module.exports导出</li><li>_filename：当前模块的完整路径</li><li>_dirname：当前模块所在文件夹的完整路径</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">exports</span>，<span class="built_in">require</span>，<span class="built_in">module</span>,_filename,_dirname</span>) </span>&#123;</span><br><span class="line"><span class="comment">//arguments.callee：这个属性保存的是当前执行的函数对象</span></span><br><span class="line"><span class="built_in">console</span>.log(argument.callee+<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="④-导出变量和函数"><a href="#④-导出变量和函数" class="headerlink" title="④ 导出变量和函数"></a>④ 导出变量和函数</h4><p>使用exports</p><ul><li>例子：exports.属性=属性值     exports.方法=函数</li></ul><p>使用module.exports</p><ul><li><p>例子：module.exports.属性=属性值     module.exports.方法=函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports.a=<span class="number">1008</span></span><br></pre></td></tr></table></figure></li><li><p>如果导出多个，就使用对象   module.exports={}</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1008</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">1000</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123; a，b&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3、模块的标识-模块的导入"><a href="#3、模块的标识-模块的导入" class="headerlink" title="3、模块的标识(模块的导入)"></a>3、模块的标识(模块的导入)</h3><p>模块的标识就是模块的名字或路径</p><p>node通过模块的标识来寻找模块的，通过require()函数来引入外部的模块</p><p>使用require引入模块以后，该函数会返回一个对象，这个对象代表的是引入的模块。</p><p>对于核心模块(npm中下载的模块)，直接使用模块的名字对其进行引入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> $= <span class="built_in">require</span>(<span class="string">&#x27;jquery&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span> ( <span class="string">&quot;express&quot;</span>)</span><br></pre></td></tr></table></figure><p>对于自定义的文件模块，需要通过文件的路径来对模块进行引入,，路径可以是绝对路径，如果是相对路径必须以./或../开头</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="built_in">require</span>(<span class="string">&#x27; ./about&#x27;</span>)</span><br><span class="line"><span class="comment">//x就是引入的模块</span></span><br></pre></td></tr></table></figure><h3 id="4、exports和module-exports的区别"><a href="#4、exports和module-exports的区别" class="headerlink" title="4、exports和module.exports的区别"></a>4、exports和module.exports的区别</h3><p>通过exports只能使用<code>.</code>的方式来向外暴露内部变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.xxx=xxx</span><br></pre></td></tr></table></figure><p>module.exports既可以通过<code>.</code>的形式，也可以直接赋值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports.xxx=xxx</span><br><span class="line"><span class="built_in">module</span>.exports=&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="npm简介"><a href="#npm简介" class="headerlink" title="npm简介"></a>npm简介</h2><p>NPM(Node Package Manager)</p><p>对于Node而言，NPM帮助其完成了第三方模块的发布、安装和依赖等。借助NPM，Node与第三方模块之间形成了很好的一个生态系统。</p><h3 id="npm的命令"><a href="#npm的命令" class="headerlink" title="npm的命令"></a>npm的命令</h3><p><code>npm -v</code> 查看npm的版本</p><p><code>npm version</code> 查看所有模块的版本</p><p><code>npm search 包名</code> 搜索包</p><p><code>npm remove / r 包名</code> 删除包</p><p><code>npm install</code> 下载当前项目所依赖的包</p><h4 id="npm的下载-三种方式"><a href="#npm的下载-三种方式" class="headerlink" title="npm的下载(三种方式)"></a>npm的下载(三种方式)</h4><p><code>npm i 包名 --save</code>   这种方式一般下载的是项目的必须依赖，记录到 package.json 内的 dependencies 字段内。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install jquery@2.3.4 --save</span><br><span class="line">npm i jquery -S</span><br><span class="line">npm i jquery</span><br></pre></td></tr></table></figure><p><code>npm i 包名 包名 --save-dev</code>   这种方式安装的是项目的非必须依赖(工具类)，记录到 package.json 内的 devDependencies 字段内</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack --save-dev</span><br><span class="line">npm i webpack -D</span><br></pre></td></tr></table></figure><p><code>npm i -g 包名</code>  全局安装包（全局安装的包一般都是一些工具）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g server</span><br></pre></td></tr></table></figure><h5 id="npm-下载包的好处"><a href="#npm-下载包的好处" class="headerlink" title="npm 下载包的好处"></a>npm 下载包的好处</h5><ul><li>可以使用模块导入</li><li>下载的包的信息全部记录在 package.json 内</li><li>同事之间相互传递项目的时候不需要传递 node_modules 文件夹，使用的时候只需要执行 <code>npm i</code> 命令会重新下载将所有的包。</li></ul><h4 id="npm的卸载"><a href="#npm的卸载" class="headerlink" title="npm的卸载"></a>npm的卸载</h4><p>卸载包使用 <code>npm uninstall 包名</code>，通过哪种方式安装的就怎样卸载</p><h3 id="npm-的一些小技巧"><a href="#npm-的一些小技巧" class="headerlink" title="npm 的一些小技巧"></a>npm 的一些小技巧</h3><p>直接在任意位置的命令行执行即可</p><ul><li><p>切换 npm 包的来源，默认的来源是外网服务器，速度比较慢</p></li><li><p>镜像：因为资源都在外国的网站，淘宝把他们都做了一份镜像，所以要修改npm的下载源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure></li><li><p>显示安装的进度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set loglevel&#x3D;http</span><br></pre></td></tr></table></figure></li></ul><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="Buffer-缓冲区"><a href="#Buffer-缓冲区" class="headerlink" title="Buffer(缓冲区)"></a>Buffer(缓冲区)</h3><p>Buffer的结构和数组很像，操作的方法也和数组类似。但是数组中不能存储二进制的文件，而buffer就是专门用来存储二进制数据的。</p><p>在buffer中存储的都是二进制数据，但是在显示时都是以16进制的形式显示。</p><p>buffer中每一个元素的范围是从00—ff (0-255)，如果要添加的值超过了范围，就会把输入的值转换为2进制，然后取后8位，转换为十进制输出。</p><p>Buffer的大小一旦确定，则不能修改，Buffer实际上是对底层内存的直接操作。</p><p>使用buffer不需要引入模块，直接使用即可。</p><p>buffer数据在控制台输出就一定是10进制，如果我们不希望输出10进制，可以使用tostring方法修改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buf2[<span class="number">2</span>].toString(<span class="number">16</span>)</span><br><span class="line"><span class="comment">//这样就修改成了16进制显示</span></span><br></pre></td></tr></table></figure><h4 id="buffer的几种创建方法"><a href="#buffer的几种创建方法" class="headerlink" title="buffer的几种创建方法"></a>buffer的几种创建方法</h4><p>1、将一个字符串转换为buffer</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">varstr=<span class="string">&quot;Hello 尚硅谷&quot;</span> </span><br><span class="line"><span class="keyword">var</span> buf = Buffer.from (str);</span><br><span class="line"><span class="built_in">console</span>.log (buf) ;</span><br><span class="line"><span class="comment">//一个英文字母占一个字节，一个汉字占三个字节</span></span><br><span class="line"><span class="built_in">console</span>.log(buf.length)<span class="comment">//占用内存的大小  15</span></span><br><span class="line"><span class="built_in">console</span>.log(str.length)<span class="comment">//字符串的长度    9</span></span><br></pre></td></tr></table></figure><p>2、创建一个指定大小的buffer</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个10个字节的buffer，数据是空的</span></span><br><span class="line"><span class="keyword">var</span> buf2 = Buffer.alloc(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>3、创建一个指定大小的buffer，但是buffer中可能含有敏感数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个10个字节的buffer，原来的数据还在</span></span><br><span class="line">sar buf3 = Buffer.allocUnsafe(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><h4 id="将缓冲区中的数据转换为字符串"><a href="#将缓冲区中的数据转换为字符串" class="headerlink" title="将缓冲区中的数据转换为字符串"></a>将缓冲区中的数据转换为字符串</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用toString方法</span></span><br><span class="line"><span class="keyword">var</span> buf4 = Buffer.from(<span class="string">&quot;我是一段文本数据&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log (buf4.tostring()) ;</span><br></pre></td></tr></table></figure><h3 id="fs"><a href="#fs" class="headerlink" title="fs"></a>fs</h3><p>文件系统(File system)：文件系统简单来说就是通过Node来操作系统中的文件。</p><p>使用文件系统，需要先引入fs模块，fs是核心模块，直接引入不需要下载</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br></pre></td></tr></table></figure><p>fs模块中所有的操作都有两种形式可供选择：同步和异步。</p><ul><li><p>同步文件系统会阻塞程序的执行，也就是除非操作完毕，否则不会向下执行代码。同步方法带sync。</p></li><li><p>异步文件系统不会阻塞程序的执行，而是在操作完成时，通过回调函数将结果返回。异步方法没有sync，但是都需要回调函数。</p></li></ul><h4 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h4><h5 id="同步文件的写入"><a href="#同步文件的写入" class="headerlink" title="同步文件的写入"></a>同步文件的写入</h5><p>1、打开文件：fs .opensync (path, flags [ , mode])</p><ul><li><p>path：文件的路径</p></li><li><p>flags：打开文件要做的操作的类型</p><ul><li>r：只读的</li><li>w：可写的</li></ul></li><li><p>mode设置文件的操作权限，—般不传</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs .openync(<span class="string">&quot;hello .txt&quot;</span> , <span class="string">&quot;w&quot;</span>);</span><br></pre></td></tr></table></figure><p>返回值：该方法会返回一个文件的描述符作为结果，我们可以通过该描述符来对文件进行各种操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fd = fs.opensync(<span class="string">&quot;hello .txt&quot;</span> , <span class="string">&quot;w&quot;</span>)</span><br><span class="line"><span class="comment">//返回一个文件的编号</span></span><br></pre></td></tr></table></figure><p>2、向文件中写入内容：fs.writesync (fd, string[ , position [ , encoding]])</p><ul><li>fd文件的描述符，需要传递写入文件的描述符</li><li>string要写入的内容</li><li>position写入的起始位置</li><li>encoding写入的编码，默认utf-8</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.writeync(fd , <span class="string">&quot;今天天气真不错～~~&quot;</span>);</span><br></pre></td></tr></table></figure><p>3、保存并关闭文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fs.closesync(fd)</span><br><span class="line"><span class="comment">//fd是要关闭文件的描述符</span></span><br></pre></td></tr></table></figure><h5 id="异步文件的写入"><a href="#异步文件的写入" class="headerlink" title="异步文件的写入"></a>异步文件的写入</h5><p>1、打开文件：fs.open(path, flags[ ,mode] ,callback)</p><p>异步调用的方法，结果都是通过回调函数的参数返回的</p><ul><li><p>回调函数两个参数:</p><ul><li><p>err错误对象，如果没有错误则为null</p></li><li><p>fd文件的描述符</p></li></ul></li></ul><p>2、向文件中写入内容：fs.write(fd,string[,position[ ,encoding]] , callback)</p><p>3、关闭文件：fs.close(fd, callback )</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开文件</span></span><br><span class="line">fs.open(<span class="string">&#x27;hello.tex&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,fd</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//判断是否出错</span></span><br><span class="line">    <span class="keyword">if</span>（！err)&#123;</span><br><span class="line">        <span class="comment">//如果没有出错，则对文件进行写入操作</span></span><br><span class="line">        fs.write(fd,<span class="string">&#x27;这是异步写入的内容&#x27;</span>，<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;写入成功&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//关闭文件</span></span><br><span class="line">            fs.close(fd,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">&#x27;文件已关闭&#x27;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="简单文件的写入"><a href="#简单文件的写入" class="headerlink" title="简单文件的写入"></a>简单文件的写入</h5><p>异步：fs.writeFile(file, data [ , options] , callback)</p><p>同步：fs.writeFilesync(file, data [ , options])</p><ul><li><p>file：要操作文件的路径</p></li><li><p>data：要写入的数据</p></li><li><p>options选项，可以对参数进行一些配置</p></li><li><p>callback：当写入完成以后执行的函数</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入fs模块</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line">fs.writeFile(<span class="string">&#x27;hello.txt&#x27;</span>,<span class="string">&#x27;这是通过writeFile写入的内容&#x27;</span>，<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;写入成功&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="流式文件的写入"><a href="#流式文件的写入" class="headerlink" title="流式文件的写入"></a>流式文件的写入</h5><p>同步、异步、简单文件的写入都不适合大文件的写入，性能较差，容易导致内存溢出。</p><p>1、创建一个可写流：fs.createwritestream(path [, options])</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = fs.createwritestream(<span class="string">&quot;hello.txt&quot;</span>);</span><br></pre></td></tr></table></figure><p>2、通过ws向文件中输出内容(可写入多次)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ws.write(<span class="string">&quot;通过可写流写入文件的内容&quot;</span>）;</span><br><span class="line">ws.write(<span class="string">&quot;通过可写流写入文件的内容&quot;</span>）;</span><br></pre></td></tr></table></figure><p>3、关闭流</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws.end();</span><br></pre></td></tr></table></figure><p><strong>可以通过监听流的open和close事件来监听流的打开和关闭。</strong></p><ul><li><p>on(事件字符串，回调函数)：可以为对象绑定—个事件。</p></li><li><p>once(事件字符串，回调函数)：可以为对象绑定一个一次性的事件，该事件将会在触发一次以后自动失效。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ws.once(<span class="string">&#x27;open&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;流打开了&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">ws.once(<span class="string">&#x27;close&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;流关闭了&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h4 id="文件的读取"><a href="#文件的读取" class="headerlink" title="文件的读取"></a>文件的读取</h4><h5 id="同步文件的读取"><a href="#同步文件的读取" class="headerlink" title="同步文件的读取"></a>同步文件的读取</h5><h5 id="异步文件的读取"><a href="#异步文件的读取" class="headerlink" title="异步文件的读取"></a>异步文件的读取</h5><h5 id="简单文件的读取"><a href="#简单文件的读取" class="headerlink" title="简单文件的读取"></a>简单文件的读取</h5><p>异步：fs.readFile(path [ , options] , callback)</p><p>同步：fs.readFilesync(path [ , options])</p><p>data读取到的数据，会返回一个buffer</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line">fs.readFile(<span class="string">&#x27;hello.txt&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="流式文件的读取"><a href="#流式文件的读取" class="headerlink" title="流式文件的读取"></a>流式文件的读取</h5><p>流式文件的读取也适用于一些比较大的文件，可以分多次将文件读取到内存中。</p><p>如果要读取一个可读流中的数据，必须要为可读流绑定一个data事件，data事件绑定完毕，它会自动开始读取数据</p><p>流式不会一次读取完，每次读取65536个字节。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="comment">//创建一个可读流</span></span><br><span class="line"><span class="keyword">var</span> rs = fs.createReadStream(<span class="string">&#x27;hello.txt&#x27;</span>);</span><br><span class="line">rs.on(<span class="string">&#x27;data&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//结果就在data里</span></span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>将读出的数据写入另一个文件的简单方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="comment">//创建一个可读流</span></span><br><span class="line"><span class="keyword">var</span> rs = fs.createReadStream(<span class="string">&#x27;hello.txt&#x27;</span>);</span><br><span class="line"><span class="comment">//创建一个可写流</span></span><br><span class="line"><span class="keyword">var</span> ws = fs.createWriteStream(<span class="string">&#x27;b.mp3&#x27;</span>);</span><br><span class="line"><span class="comment">//pipe()可以将可读流中的内容，直接输出到可写流中</span></span><br><span class="line">rs.pipe(ws)</span><br></pre></td></tr></table></figure><h4 id="fs中的其他方法"><a href="#fs中的其他方法" class="headerlink" title="fs中的其他方法"></a>fs中的其他方法</h4><p>1、检查一个文件是否存在</p><p>同步：<code>fs.existssync(path)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查是否存在a123.mp3</span></span><br><span class="line"><span class="keyword">var</span> isExists = fs.existssync(<span class="string">&quot;a123.mp3&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log (isExists);</span><br></pre></td></tr></table></figure><p>2、获取文件的信息</p><p>异步：<code>fs.stat(path,callback)</code>   </p><p>同步： <code>fs.statsync(path)</code></p><p>它会给我们返回一个对象，这个对象中保存了当前对象状态的相关信息</p><ul><li><p>这个对象的属性</p><ul><li><p>size：文件的大小</p></li><li><p>isFile()：是否是一个文件</p></li><li><p>isDirectory()：是否是一个文件夹</p></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs.stat(<span class="string">&#x27;a.mp3&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,stat</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(stat);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>3、删除文件：</p><p>异步：<code>fs.unlink(path,callback)</code>  </p><p>同步：   <code>fs.unlinkSync(path)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.unlinkSync ( <span class="string">&quot;hello.txt&quot;</span>);</span><br></pre></td></tr></table></figure><p>4、读取一个目录的目录结构：</p><p>异步：<code>fs.readdir(path[,options],callback)</code></p><p>同步：<code>fs.readdirSync(path[,options])</code></p><p>files是一个字符串数组，每一个元素就是一个文件夹或文件的名字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fs.readdir(<span class="string">&#x27;.&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,files</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(files);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>5、截断文件，将文件修改为指定的大小</p><p>异步：<code>fs.truncate(path,len,callback)</code></p><p>同步：<code>fs.truncateSync(path,len)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.truncateSync(<span class="string">&quot;hello.txt&quot;</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>6、创建一个目录</p><p>异步：<code>fs.mkdir(path[ ,mode],callback)</code></p><p>同步：<code>fs.mkdirSync(path[,mode])</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.mkdirSync(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure><p>7、删除一个目录</p><p>异步：<code>fs.rmdir(path, callback)</code></p><p>同步：<code>fs.rmdirSync(path)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.rmdirSync( <span class="string">&quot;hello.txt&quot;</span>);</span><br></pre></td></tr></table></figure><p>8、对文件进行重命名</p><p>异步：<code>fs.rename(oldPath,newPath,callback)</code></p><p>同步：<code>fs.renameSync(oldPath, newPath)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fs.rename(<span class="string">&#x27;a.mp3&#x27;</span>,<span class="string">&#x27;笔记。mp3&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;修改成功&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>也可以通过该方法实现剪切操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fs.rename(<span class="string">&#x27;笔记.txt&#x27;</span>,<span class="string">&#x27;c:\\Users\\Desktop\\笔记.mp3&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;修改成功&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>9、监视文件的修改</p><p><code>fs.watchFile(filename[,options],listener)</code></p><p>参数：</p><ul><li><p>filename：要监视的文件的名字</p></li><li><p>options：配置选项</p></li><li><p>listener：回调函数，当文件发生变化时，回调函数会执行</p><ul><li><p>在回调函数中会有两个参数:</p><ul><li><p>curr：当前文件的状态</p></li><li><p>prev：修改前文件的状态</p></li><li><p>这两个对象都是stats对象</p></li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fs.watchFile(<span class="string">&#x27;hello.txt&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;文件发生了变化&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;修改前文件大小&#x27;</span>：+prev.size);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;修改后文件大小&#x27;</span>：+curr.size);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 服务器端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="posts/25246/"/>
      <url>posts/25246/</url>
      
        <content type="html"><![CDATA[<h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><p>Git是目前世界上最先进的分布式版本控制系统。</p><h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p>需要使用命令行，安装 git即可。</p><p>git安装的时候不需要选择安装目录，一直下一步，直到出现很多复选框其中有两个是 <code>git bash here</code> 和 <code>git gui here</code> ，将后面的勾选掉(不勾选)，继续一直下一步即可。安装完毕之后在任意空白处点击鼠标右键就会出现 <code>git bash here</code> 命令。</p><h3 id="基本的shell命令"><a href="#基本的shell命令" class="headerlink" title="基本的shell命令"></a>基本的shell命令</h3><ul><li><code>cd</code>  改变目录</li><li><code>cd..</code>  回退到上一个目录，直接cd进入默认目录</li><li><code>pwd</code>  显示当前所在的目录路径</li><li><code>Is(ll)</code>  都是列出当前目录中的所有文件，只不过两个ll列出的内容更为详细<ul><li><code>ls -a</code>  查看当前目录下的所有内容，包括隐藏文件</li></ul></li><li><code>touch</code>  新建一个文件，如touch index.js就会在当前目录下新建一-个index.js文件。</li><li><code>rm</code>  删除一个文件，如rm index.js就会把index.js文件删除。</li><li><code>mkdir</code>  新建一个目录，就是新建一个文件夹。</li><li><code>rm-r</code>  删除一个文件夹  </li><li><code>rm-f</code>  强制删除</li><li><code>cp</code>  复制或重命名   <ul><li><code>-r</code>  可以复制文件夹</li></ul></li><li><code>mv</code>  移动文件， mv index.html test 就是把index.html移动到test文件夹下</li><li><code>cat</code>  查看文件里面的内容</li><li><code>clear</code>  清屏</li><li><code>history</code>  查看命令历史。</li><li><code>exit</code>  退出。</li></ul><h2 id="git的基本理论"><a href="#git的基本理论" class="headerlink" title="git的基本理论"></a>git的基本理论</h2><p>Git本地有三个工作区域：工作目录( Working Directory)、暂存区(Stage/Index)、资源库(Repository或Git Directory)；如果再加上远程的git仓库(Remote Directory)就可以分为四个工作区域。文件在这四个区域之间的转换关系如下：</p><p><img src="http://img8.jimu98.cn/20200720191119.png" alt=""></p><h2 id="git的基本配置"><a href="#git的基本配置" class="headerlink" title="git的基本配置"></a>git的基本配置</h2><p>命令：git config –global –list</p><p>可以查看自己的名字和邮箱，也可以通过该命令设置。如下图。</p><p><img src="http://img8.jimu98.cn/20200721223351.png" alt="image-20200721223351587"></p><h2 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h2><ul><li><code>git config -l</code>  查看配置</li><li><code>git --version</code> 查看 git 版本号,有时候可以简写成 <code>-v</code></li><li><code>git log</code> 查看本地版本</li><li><code>git status</code> 查看当前仓库的状态</li><li><code>git init</code> 将本地项目变成仓库</li><li><code>git clone 仓库地址</code> 克隆仓库到本地</li><li><code>git add .</code>添加所有文件到暂存区  <code>.</code> 代表所有的修改，也可以换成文件名</li><li><code>git commit -m&#39;留言&#39;</code>  提交暂存区中的内容到本地仓库，-m提交信息</li><li><code>git push</code> 将做好的版本提交到远端</li><li><code>git pull</code> 将远端的更新拉取到本地</li><li><code>git branch 分支名称</code> 创建新分支</li><li><code>git branch</code> 查看分支</li><li><code>git checkout 分支名称</code> 切换分支</li><li><code>git merge 分支名称</code> 当前分支合并分支其他分支</li><li><code>git pull origin master</code> 拉取主分支上的更新</li><li><code>git checkout -b 分支名称</code> 创建新的分支并切换过去</li></ul><h2 id="创建远程仓库的方式"><a href="#创建远程仓库的方式" class="headerlink" title="创建远程仓库的方式"></a>创建远程仓库的方式</h2><h3 id="1、创建全新的仓库：git-init-初始化"><a href="#1、创建全新的仓库：git-init-初始化" class="headerlink" title="1、创建全新的仓库：git init 初始化"></a>1、创建全新的仓库：git init 初始化</h3><ul><li><p>网上传建一个项目同名(你的项目文件夹是什么名字，仓库名与之相同)的空仓库(创建的时候不添加 reademe 文件)</p></li><li><p>在你的本地项目文件夹内打开命令行工具</p></li><li><p>将自己本地的项目初始化成 git 仓库，执行 <code>git init</code> 命令</p></li><li><p>在本地的项目里，创建一个README.MD文件，执行 <code>add .</code> 和 <code>git commit -m &#39;留言&#39;</code>命令</p></li><li><p>去网上的空仓库复制代码，第一个提示框的最后两行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/Haley-JJ/first_demo.git</span><br><span class="line">这行命令的作用是给本地的仓库添加一个远端地址， 名称是origin， 地址是后面的地址</span><br><span class="line">git push -u origin master</span><br><span class="line">这行命令的作用是将版本上传到已经添加的远端origin</span><br></pre></td></tr></table></figure></li><li><p>执行完毕之后上传成功，想要修改的话，直接在本地仓库修改，然后执行上传三部曲即可</p></li></ul><h3 id="2、克隆远程仓库：git-clone-地址"><a href="#2、克隆远程仓库：git-clone-地址" class="headerlink" title="2、克隆远程仓库：git clone+地址"></a>2、克隆远程仓库：git clone+地址</h3><ul><li><p>先将网上的仓库下载到本地，需要使用命令 <code>git clone 仓库地址</code></p></li><li><p>将想要托管的项目放到该仓库内，仓库内不必要的东西删除</p></li><li><p>将本地和网上关联起来(将自己本地的修改上传)</p><ul><li><p>将自己对仓库的所有修改添加到 github 远端记录，执行 <code>git add .</code></p></li><li><p>将记录好的修改做成版本，执行命令 <code>git commit -m&#39;留言&#39;</code></p><ul><li><p>如果是第一次和 github 关联的话，会失败，然后会提示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">please tell me who you are ?</span><br><span class="line">让你依次分别执行以下命令</span><br><span class="line">git config --global user.name &quot;yourname&quot;</span><br><span class="line">git config --global user.email &quot;youremail&quot;</span><br></pre></td></tr></table></figure></li><li><p>告诉他之后再次执行 <code>git commit -m&#39;留言&#39;</code></p></li></ul></li><li><p>将新的版本上传，执行命名 <code>git push</code></p><ul><li><p>由于是第一次和网上关联，会失败提示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">让你执行</span><br><span class="line">git push -u origin master</span><br><span class="line">执行完毕之后就成功了</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>上传成功之后，想要修改的话，直接在本地仓库修改，然后执行上传三部曲即可</p></li></ul><h2 id="git-的基本操作"><a href="#git-的基本操作" class="headerlink" title="git 的基本操作"></a>git 的基本操作</h2><h3 id="多个人或者多台电脑对同一仓库的同一分支进行操作"><a href="#多个人或者多台电脑对同一仓库的同一分支进行操作" class="headerlink" title="多个人或者多台电脑对同一仓库的同一分支进行操作"></a>多个人或者多台电脑对同一仓库的同一分支进行操作</h3><p>如果远端存在本地不存在的版本时，本地需要向仓库里上传并执行 git 上传三部曲时，执行到<code>git push</code>命令就会提示失败。可以使用<code>git pull</code>命令</p><p>当执行 <code>git pull</code> 将远端的版本拉取到本地，但是本地已经存在了一个提交的版本</p><ul><li><p>当这两个版本不冲突的时候(不是同一个文件，或者是同一个文件的不同位置)</p><ul><li>git 会自动合并两个版本，并弹出新的命令面板让你提交合并的版本留言，可以直接按住shift +z+z，退出留言面板。</li><li>再次执行 git push，上传更新</li></ul></li><li><p>当这两个版本冲突的时候(修改的是同一个文件的同一个位置)</p><ul><li>git 并不会自动合并，而是将冲突体现在当前的文件内，需要用户自己选择保留哪个更改，选择完毕之后，使用 git 上传三步提交即可。</li></ul></li></ul><h3 id="github-的分支操作"><a href="#github-的分支操作" class="headerlink" title="github 的分支操作"></a>github 的分支操作</h3><p>一个仓库内默认只有一个分支 master，通常称为主分支(用来存放合并后的代码)。可以多个分支。</p><p>一般工作流程是先在主分支将项目的主体框架搭建完毕，然后创建多个分支，每个分支代表不同的功能，不同的程序猿分别在不同分支内进行开发，开发完毕后将代码合并到主分支上。</p><ul><li>创建一个仓库(有README.md文件)，然后克隆到本地，添加公共的内容，然后上传。</li><li>创建新的分支，使用 <code>git branch 分支名称</code>命令。分支创建的时候里面的内容和主分支是一模一样的。</li><li>需要将创建好的分支上传到网上，可能直接使用 <code>git push</code> 命令，但是由于网上并没有新分支，所以需要使用 <code>git push --set-upstream origin yourbranch</code> 上传。此时本地和网上仓库完全同步了。</li><li>主分支分别合并分支的内容，然后上传。需要使用 <code>git merge 分支名称</code> 命令合并分支。合并之后再次使用<code>git push</code>命令上传。</li></ul><p><strong>注意</strong>：如果存在多个分支，会弹出新的命令面板让你提交合并之后的版本留言，可以直接按住shift +z+z，退出留言面板，再次上传。</p><h3 id="github-的特殊分支：gh-pages"><a href="#github-的特殊分支：gh-pages" class="headerlink" title="github 的特殊分支：gh-pages"></a>github 的特殊分支：gh-pages</h3><p>mater 分支内已经存放好了其他分支做好的项目，github 仓库有一个特殊的分支叫 gh-pages，该分支下的内容会被自动托管到github 免费服务器上，也就是说只要该分支下有 index.html 就可以直接使用网址访问。只需要直接创建 gh-pages 分支，并上传到网上即可。</p><h2 id="使用-ssh-key-公钥"><a href="#使用-ssh-key-公钥" class="headerlink" title="使用 ssh-key 公钥"></a>使用 ssh-key 公钥</h2><p>将自己电脑的当前系统和 github 关联，当用户在上传或下载仓库的时候使用 ssh 方式，可以实现用户的免密码登录。</p><h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><ul><li><p>打开命令行工具 输入 <code>cd ~</code> 命令</p></li><li><p>执行 <code>ssh-keygen</code> 命令，生成电脑上的公钥和私钥，一直回车直到出现密码图即可。</p></li><li><p>找到生成的公钥和私钥，位置在 <code>~/.ssh/</code> 文件夹下，使用 cat 命令(<code>cat .ssh/id_rsa.pub</code>)打印出公钥内容并复制</p><ul><li>如果生成的秘钥名称不是<strong>id_rsa.pub</strong>，就需要进行如下操作<ul><li>执行 <code>cd .ssh</code>，再执行 <code>ls -a</code> 查看自己的秘钥名称</li><li>使用 <code>cat 你的公钥名称</code> ，复制打印出的公钥内容</li></ul></li></ul></li><li><p>打开 github 网站，点击头像的下箭头选择 setting，找到 ssh key 新增一个即可。</p></li><li><p>验证 ssh 是否生效的话，需要重新从网上下载(选择 ssh 方式下载)仓库到本地，再次上传更新的时候，如果不需要输入用户名和密码，那就是生效了。</p></li></ul><h4 id="如果觉得太多的命令不容易操作的话，我们就可以使用另一种简单的方法"><a href="#如果觉得太多的命令不容易操作的话，我们就可以使用另一种简单的方法" class="headerlink" title="如果觉得太多的命令不容易操作的话，我们就可以使用另一种简单的方法"></a>如果觉得太多的命令不容易操作的话，我们就可以使用另一种简单的方法</h4><ul><li><p>进入C:\users\Administrator.ssh目录</p></li><li><p>生成公钥：<code>ssh-keygen -t rsa</code> rsa加密</p></li><li><p>找到生成的公钥文件<strong>id_rsa.pub</strong>，去网站粘贴生成的加密文件</p></li></ul><h2 id="仓库根目录下的-gitignore-文件"><a href="#仓库根目录下的-gitignore-文件" class="headerlink" title="仓库根目录下的 .gitignore 文件"></a>仓库根目录下的 .gitignore 文件</h2><p>gitignore文件是一个隐藏文件，该文件的作用是当你将一些文件或文件夹的名称写在 .gitignore 内的话，该仓库执行上传操作的时候，会忽略 .gitignore 内添加的文件或文件夹。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>仓库不能嵌套仓库</li></ul><h2 id="类似-github-网站的其他工具"><a href="#类似-github-网站的其他工具" class="headerlink" title="类似 github 网站的其他工具"></a>类似 github 网站的其他工具</h2><ul><li>腾讯云开发者平台(coding)：是一个和 github 类似的网站，服务器是国内的，所以操作起来速度很快。</li><li>码云：一般需要从github上下载项目，可以通过码云来下载。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Git </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB学习笔记</title>
      <link href="posts/10293/"/>
      <url>posts/10293/</url>
      
        <content type="html"><![CDATA[<h1 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h1><p>数据库是按照数据结构来组织、存储和管理数据的仓库。<br>我们的程序都是在内存中运行的，一旦程序运行结束或者计算机断电，程序运行中的数据都会丢失。所以我们就需要将一些程序运行的数据持久化到硬盘之中，以确保数据的安全性。而数据库就是数据持久化的最佳选择。说白了，数据库就是存储数据的仓库。</p><p><strong>数据库分类</strong><br>数据库主要分成两种︰</p><p>一、关系型数据库(RDBMS)</p><ul><li>MySQL、Oracle、DB2、SQL Server …..</li><li>关系数据库中全都是表</li></ul><p>二、非关系型数据库(No SQL)</p><ul><li>MongoDB、Redis …..</li><li>键值对数据库</li><li>文档数据库MongoDB</li></ul><h2 id="MongoDB-1"><a href="#MongoDB-1" class="headerlink" title="MongoDB"></a>MongoDB</h2><p>MongoDB是为快速开发互联网Web应用而设计的数据库系统。</p><p>MongoDB的数据模型是面向文档的，所谓文档是一种类似于JSON的结构，简单理解MongoDB这个数据库中存的是各种各样的JSON。(BSON )</p><h3 id="安装MongoDB"><a href="#安装MongoDB" class="headerlink" title="安装MongoDB"></a>安装MongoDB</h3><p>1、安装</p><p>2、配置环境变量：D:\mongoDB\Server\3.4\bin</p><p>3、打开cmd窗口，启动服务器，输入：<code>mongod --dbpath 数据库路径 (--port 端口号)</code>，默认端口号<code>27017</code></p><p>4、再打开一个cmd窗口，输入<code>mongo</code>，连接mongodb，出现<code>&gt;</code></p><h3 id="将MongoDB设置为系统服务"><a href="#将MongoDB设置为系统服务" class="headerlink" title="将MongoDB设置为系统服务"></a>将MongoDB设置为系统服务</h3><p>安装路径D盘mongoDB文件夹内</p><p>1、在mongoDB内创建一个data文件夹，在data内新建db文件夹和log文件夹</p><p>2、创建配置文件：在目录D:\mongoDB\Server\3.4下添加一个配置文件mongod.cfg(bin文件夹所在的位置)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemLog:</span><br><span class="line">    destination: file</span><br><span class="line">    path: D:\mongoDB\data\log\mongod.log</span><br><span class="line">storage:</span><br><span class="line">    dbPath: D:\mongoDB\data\db</span><br></pre></td></tr></table></figure><p>3、以管理员身份打开命令行窗口，执行以下命令</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod --dbpath=D:\mongodb\data\db  --logpath=D:\mongodb\data\log\MongoDB.log --install --serviceName <span class="string">&quot;MongoDB&quot;</span></span><br></pre></td></tr></table></figure><p>4、启动mongod服务</p><p>5、如果启动失败，证明上边的操作有误，在控制台输入<code>sc delete MongoDB</code>删除之前的配置服务，重新再来一次</p><h3 id="数据库-database"><a href="#数据库-database" class="headerlink" title="数据库(database)"></a>数据库(database)</h3><ul><li>数据的服务器<ul><li>服务器用来保存数据</li><li><code>mongod</code>用来启动服务器</li></ul></li><li>数据库的客户端<ul><li>客户端用来操作服务器，对数据进行增删改查的操作</li><li><code>mongo</code>用来启动客户端</li></ul></li></ul><h3 id="三个概念"><a href="#三个概念" class="headerlink" title="三个概念"></a>三个概念</h3><ul><li>数据库( database )：是一个仓库，在仓库中可以存放集合。</li><li>集合( collection )：类似于数组，在集合中可以存放文档。</li><li>文档( document )：数据库中的最小单位，我们存储和操作的内容都是文档。</li></ul><p>数据库和集合都不需要手动创建，当我们创建文档时，如果文档所在的集合或数据库不存在，会自动创建数据库和集合。</p><h3 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h3><p><code>show dbs</code> <code>show databases</code>：显示当前的所有数据库</p><p><code>use 数据库名</code>：进入到指定的数据库中</p><p><code>db</code>：当前所在的数据库</p><p><code>show collections</code>：显示数据库中所有的集合</p><h3 id="数据库的CRUD的操作"><a href="#数据库的CRUD的操作" class="headerlink" title="数据库的CRUD的操作"></a>数据库的CRUD的操作</h3><h4 id="插入文档"><a href="#插入文档" class="headerlink" title="插入文档"></a>插入文档</h4><p><code>db.集合名.insert()</code>：向集合中插入一个或多个 文档</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例：向stus集合中插入一个新的学生对象&#123;name: &#x27;hahah&#x27;,age: 18&#125;</span></span><br><span class="line">db.stus.insert(&#123;<span class="attr">name</span>: <span class="string">&#x27;hahah&#x27;</span>,<span class="attr">age</span>: <span class="number">18</span>&#125;)</span><br><span class="line"><span class="comment">//例：插入多个(数组)</span></span><br><span class="line">db.stus.insert([&#123;&#125;,&#123;&#125;,&#123;&#125;])</span><br></pre></td></tr></table></figure><p> <code>db.集合名.insertOne()</code>：插入一个文档对象</p><p><code>db.集合名.insertMany()</code>：插入多个文档对象</p><p>当我们向集合中插入文档时，如果没有给文档指定_id属性，则数据库会自动为文档添加_id属性<br>该属性用来作为文档的唯一标识。使用<code>ObjectId()</code>生成_id。</p><p>_id属性可以自己指定，如果我们指定了，数据库就不会再添加了，如果自己指定_id，也要确保唯一性。</p><h4 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h4><p><code>db.集合名.find()</code>：查询当前集合中所有符合条件的文档。</p><p>find()可以接收一个对象作为条件参数，返回值是一个数组。</p><p>find({})：表示查询集合中的所有文档</p><p>{ 属性：值 }：查询属性是指定值的文档</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例：查询名字是猪八戒并且年龄18的信息</span></span><br><span class="line">db.stus.find(&#123;<span class="attr">name</span>:<span class="string">&#x27;猪八戒&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;)</span><br></pre></td></tr></table></figure><p><code>db.集合名.findOne()</code>：用来查询集合中符合条件的第一个文档，返回值是一个文档对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例：查询年龄28的的姓名</span></span><br><span class="line">db.stus.findOne(&#123;<span class="attr">age</span>:<span class="number">28</span>&#125;).name;</span><br></pre></td></tr></table></figure><p><code>db.集合名.find(&#123;&#125;).count()</code>：查询所有结果的数量</p><h4 id="修改文档"><a href="#修改文档" class="headerlink" title="修改文档"></a>修改文档</h4><p><code>db.集合名.update(查询条件，新对象，配置选项)</code></p><p>update()默认情况下会使用新对象去替换旧对象</p><p>如果需要修改指定的属性，而不是替换的话，需要使用<strong>操作符</strong>来完成修改。</p><p>update()默认只会修改一个，如果想多个同时修改，使用<code>db.集合名.updateMany()</code>或者给<code>update()</code>配置选项。</p><p>当一个文档的属性值是一个文档时，我们称这个文档叫做<strong>内嵌文档</strong>。</p><p><code>$set</code>：用来修改文档中的指定属性</p><p><code>$unset</code>：用来删除文档中的指定属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例：为姓名为孙悟空的添加(删除)属性：性别。</span></span><br><span class="line">db.stus.update(&#123;<span class="attr">name</span>:<span class="string">&#x27;孙悟空&#x27;</span>&#125;,&#123;<span class="attr">$set</span>:&#123;<span class="attr">gender</span>:<span class="string">&#x27;男&#x27;</span>&#125;&#125;</span><br><span class="line">db.stus.update(&#123;<span class="attr">name</span>:<span class="string">&#x27;孙悟空&#x27;</span>&#125;,&#123;<span class="attr">$unset</span>:&#123;<span class="attr">gender</span>:<span class="string">&#x27;男&#x27;</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><p><code>$push</code>：用于向数组中添加一个新的元素</p><p><code>$addToSet</code>：向数组中添加一个新元素，如果数组中已经存在了该元素，则不会添加。</p><p><code>db.集合名.updateMany()</code>：同时修改多个符合条件的文档</p><p><code>db.集合名.updateOne()</code>：修改一个符合条件的文档</p><p><code>db.集合名.replaceOne()</code>：替换一个文档</p><h4 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h4><p><code>db.collection.remove()</code>：可以根据条件删除符合条件的所有文档，传递条件的方式和find()一样。</p><p>remove()默认删除多个，如果传递的第二个参数值为true，则只会删除一个。</p><p>如果只传递一个空对象，则会删除所有。</p><p><code>db.集合名.deleteOne()</code></p><p><code>db.集合名.deleteMany()</code></p><h4 id="删除集合、数据库"><a href="#删除集合、数据库" class="headerlink" title="删除集合、数据库"></a>删除集合、数据库</h4><p><code>db.集合名.remove(&#123;&#125;)</code>：清空集合(性能略差)</p><p><code>db.集合名.drop</code>：删除集合</p><p><code>db.dropDatabase()</code>：删除数据库</p><p>一般数据库中的数据不会删除，所以删除的方法很少调用，一般会在数据中添加一个字段，来表示数据是否被删除。</p><p>MongoDB支持通过内嵌文档的属性进行查询，如果要查询内嵌文档则可以通过<code>.</code>的形式来匹配。需要注意的是属性名必须加引号。</p><h4 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h4><p><code>$eq</code>：等于</p><p><code>$gt</code>：大于</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例：查询numbers中num大于1996的文档</span></span><br><span class="line">db.numbers.find(&#123;<span class="attr">num</span>: &#123;<span class="attr">$gt</span>: <span class="number">1996</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><p><code>gte</code>：大于等于</p><p><code>lt</code>：小于</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例：查询numbers中num大于40小于50的文档</span></span><br><span class="line">db.numbers.find(&#123;<span class="attr">num</span>: &#123;<span class="attr">$gt</span>: <span class="number">40</span>, <span class="attr">$lt</span>: <span class="number">50</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><p><code>lte</code>：小于等于</p><p><code>ne</code>：不等于</p><p><code>$or</code>：或</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例：查询工资小于1000或大于2500的员工</span></span><br><span class="line">dp.emp.find(&#123;<span class="attr">$or</span>: [&#123;<span class="attr">sal</span>:&#123;<span class="attr">$lt</span>:<span class="number">1000</span>&#125;&#125;,&#123;<span class="attr">sal</span>:&#123;<span class="attr">$gt</span>:<span class="number">2500</span>&#125;&#125;]&#125;)</span><br></pre></td></tr></table></figure><p><code>$inc</code>：自增</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例：为所有薪资低于1000的员工增加工资400元</span></span><br><span class="line">dp.emp.updateMany(&#123;<span class="attr">sal</span>:&#123;<span class="attr">$lte</span>:<span class="number">1000</span>&#125;,&#123;<span class="attr">$inc</span>:&#123;<span class="attr">sal</span>:<span class="number">400</span>&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p><code>limit()</code>：设置显示数据的上限</p><p><code>skip()</code>：用于跳过指定数量的数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例：查看numbers集合中的第11条到20条的文档</span></span><br><span class="line">db.numbers.find().skip().limit(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>向numbers集合中插入2000条数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = []</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">20000</span>; i++)&#123;</span><br><span class="line">arr.push(&#123;<span class="attr">num</span>:i&#125;)</span><br><span class="line">&#125;</span><br><span class="line">db.numbers.insert(arr)</span><br></pre></td></tr></table></figure><h3 id="文档之间的关系"><a href="#文档之间的关系" class="headerlink" title="文档之间的关系"></a>文档之间的关系</h3><p>1、一对一(one to one)：可以通过内嵌文档的形式来体现出一对一的关系</p><p>2、一对多(one to many) / 多对一(many to one)：用户—订单     文章—评论</p><p>3、多对多(many to many)：老师—学生</p><h3 id="sort和投影"><a href="#sort和投影" class="headerlink" title="sort和投影"></a>sort和投影</h3><p>查询文档时，默认情况下时按照_id的值进行排序(升序)</p><p>sort()可以用来指定文档的排序规则，需要传递一个对象来指定排序规则  <code>1表示升序  -1表示降序</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.emp.find(&#123;&#125;).sort(&#123;<span class="attr">sal</span>:<span class="number">1</span>,<span class="attr">empno</span>:-<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><p><code>limit</code> 、<code>skip</code>、<code>sort</code> 可以任意的顺序进行调用</p><p><code>sort()</code>可以指定多个排序的字段</p><p>在查询时，可以在第二个参数的位置来设置查询结果的投影</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.emp.find(&#123;&#125;,&#123;<span class="attr">ename</span>:<span class="number">1</span>,\_id:<span class="number">0</span>,<span class="attr">sal</span>:<span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure><h2 id="Mongoose"><a href="#Mongoose" class="headerlink" title="Mongoose"></a>Mongoose</h2><p>之前我们都是通过shell来完成对数据库的各种操作的，在开发中大部分时候我们都需要通过程序来完成对数据库的操作。而Mongoose就是一个让我们可以通过Node来操作MongoDB的模块。</p><p>Mongoose是一个对象文档模型(ODM)库，它对Node原生的MongoDB模块进行了进一步的优化封装，并提供了更多的功能。</p><h3 id="mongoose的对处"><a href="#mongoose的对处" class="headerlink" title="mongoose的对处"></a>mongoose的对处</h3><p>1、可以为文档创建一个模式结构(Schema)</p><p>2、可以对模型中的对象/文档进行验证 </p><p>3、数据可以通过类型转换转换为对象模型</p><p>4、可以使用中间件来应用业务逻辑挂钩</p><p>5、比Node原生的MongoDB驱动更容易</p><h3 id="mongoose中提供的新对象"><a href="#mongoose中提供的新对象" class="headerlink" title="mongoose中提供的新对象"></a>mongoose中提供的新对象</h3><p>Schema(模式对象)：Schema对象定义约束了数据库中的文档结构</p><p>Model：Model对象作为集合中的所有文档的表示，相当于MongoDB数据库中的集合collection</p><p>Document：Document表示集合中的具体文档，相当于集合中的一个具体的文档</p><h3 id="mongoose的使用"><a href="#mongoose的使用" class="headerlink" title="mongoose的使用"></a>mongoose的使用</h3><p>1、下载安装Mongoose</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i mongoose --save</span><br></pre></td></tr></table></figure><p>2、在项目引入mongoose</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">&#x27;mongoose&#x27;</span>);</span><br></pre></td></tr></table></figure><p>3、连接MongoDB数据库</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connect(<span class="string">&#x27;mongodb://localhost/mongoose_test&#x27;</span>);</span><br></pre></td></tr></table></figure><p>4、创建Schema(模式)对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Schema = mongoose.Schema;</span><br><span class="line"><span class="keyword">var</span> stuSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    name: <span class="built_in">String</span>,</span><br><span class="line">    age: <span class="built_in">Number</span>,</span><br><span class="line">    gender: &#123;</span><br><span class="line">        type: <span class="built_in">String</span>,</span><br><span class="line">        <span class="keyword">default</span>: <span class="string">&#x27;female&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    address: <span class="built_in">String</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>5、通过schema来创建Model</p><p>Model代表的是数据库中的集合，通过Model才能对数据库进行操作</p><p><code>mongoose.model (modelName, schema )</code></p><p>modelName就是要映射的集合名，mongoose会自动将集合名变成复数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> StuModel = mongoose.model(<span class="string">&quot;student&quot;</span>,stuSchema)</span><br></pre></td></tr></table></figure><p>6、向数据库中插入一个文档</p><p><code>集合名.create(文档名,function(err)&#123;&#125;)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">StuModel.create(&#123;</span><br><span class="line">    name:<span class="string">&#x27;孙悟空&#x27;</span>,</span><br><span class="line">    age:<span class="number">18</span>,</span><br><span class="line">    gender:<span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">    address:<span class="string">&#x27;花果山&#x27;</span></span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;插入成功&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>执行完以上步骤，数据库就已经连接成功了！</p><p><strong>监听MongoDB数据库的连接状态</strong></p><p>在mongoose对象中，有一个属性叫做connection，该对象表示的就是数据库连接，通过监听该对象的状态，可以来监听数据库的连接与断开</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//连接</span></span><br><span class="line">mongoose.connection.once(<span class="string">&#x27;open&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;数据库连接成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//断开</span></span><br><span class="line">mongoose.connection.once(<span class="string">&#x27;close&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;数据库已经断开&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>断开数据库连接</strong></p><p>MongoDB数据库，一般情况下，只需要连接一次，连接一次以后，除非此昂木停止，服务器关闭，否则连接一般不会断开。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoose.disconnect()</span><br></pre></td></tr></table></figure><h4 id="Model的方法"><a href="#Model的方法" class="headerlink" title="Model的方法"></a>Model的方法</h4><p>有了Model，我们就可以对数据库进行增删改查的操作了。</p><p><code>Model.create(doc(s),[callback])</code>：用来创建一个或多个文档并添加到数据库中。</p><ul><li>doc(s)：可以是一个文档对象或多个文档对象组成的数组</li><li>callback：当操作完成以后调用的回调函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">StuModel.create([</span><br><span class="line">    &#123;</span><br><span class="line">    name:<span class="string">&#x27;孙悟空&#x27;</span>,</span><br><span class="line">    age:<span class="number">18</span>,</span><br><span class="line">    gender:<span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">    address:<span class="string">&#x27;花果山&#x27;</span></span><br><span class="line">&#125;,&#123;</span><br><span class="line">        name:<span class="string">&#x27;猪八戒&#x27;</span>,</span><br><span class="line">    age:<span class="number">28</span>,</span><br><span class="line">    gender:<span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">    address:<span class="string">&#x27;高老庄&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">],<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;插入成功&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>Model.find(conditions,[projection],[options],[callback])</code>：查询所有符合条件的文档，返回一个数组</p><p><code>Model.findById(id,[projection],[options],[callback])</code>：根据文档的id属性查询文档</p><p><code>Model.findOne([conditions],[projection],[options],[callback])</code>：查询符合条件的第一个文档，返回一个具体的文档对象</p><p>参数：</p><ul><li>conditions：查询的条件</li><li>projection：投影<ul><li>两种方式   1、{name:1, age:0}    2、”name  -_id”</li></ul></li><li>options：查询选项(skip limit)<ul><li>回调函数，查询结果会通过回调函数返回，回调函数必须传，如果不传回调函数，压根不会查询</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">StuModel.find(&#123;<span class="attr">name</span>:<span class="string">&#x27;孙悟空&#x27;</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,docs</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(docs)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">StuModel.find(&#123;<span class="attr">name</span>:<span class="string">&#x27;孙悟空&#x27;</span>&#125;,&#123;<span class="attr">name</span>:<span class="number">1</span>,<span class="attr">_id</span>:<span class="number">0</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,docs</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(docs)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">StuModel.find(&#123;<span class="attr">name</span>:<span class="string">&#x27;孙悟空&#x27;</span>&#125;,<span class="string">&quot;name -age&quot;</span>,&#123;<span class="attr">skip</span>:<span class="number">3</span>,<span class="attr">limit</span>:<span class="number">1</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,docs</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(docs)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>Model.update(conditions,doc,[options],[callback])</code></p><p><code>Model.updateMany(conditions,doc,[options],[callback])</code></p><p><code>Model.updateOne(conditions,doc,[options],[callback])</code></p><p><code>Model.replaceOne(conditions,doc,[options],[callback])</code></p><p>参数：</p><ul><li><p>condition：查询条件</p></li><li><p>doc：修改后的对象</p></li><li><p>options：配置参数</p></li><li><p>callback：回调函数</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">StuModel.updateOne(&#123;<span class="attr">name</span>:<span class="string">&#x27;孙悟空&#x27;</span>&#125;,&#123;<span class="attr">$set</span>:&#123;<span class="attr">age</span>:<span class="number">20</span>&#125;&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,doc</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;修改成功&quot;</span>,doc)</span><br><span class="line">        doc.update(&#123;<span class="attr">$set</span>:&#123;<span class="attr">age</span>:<span class="number">60</span>&#125;&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;修改成功&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>Module.remove(conditions,[callback])</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StuModel.remove(&#123;<span class="attr">age</span>:<span class="number">20</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;删除成功&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>Module.deleteOne(conditions,[callback])</code></p><p><code>Module.deleteMany(conditions,[callback])</code></p><p><code>Module.count(conditions,[callback])</code>：统计文档的数量</p><h4 id="Document的方法"><a href="#Document的方法" class="headerlink" title="Document的方法"></a>Document的方法</h4><p>通过find()查询的结果，返回的对象就是Document</p><p>Document和集合中的文档一一对应，Document对象是Model的实例</p><h5 id="创建一个Document"><a href="#创建一个Document" class="headerlink" title="创建一个Document"></a>创建一个Document</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stu = <span class="keyword">new</span> StuModel(&#123;</span><br><span class="line">    name:<span class="string">&#x27;奔波霸&#x27;</span>，</span><br><span class="line">    age:<span class="number">48</span>,</span><br><span class="line">    gender:<span class="string">&#x27;male&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//document的方法：save([options],[fn])</span></span><br><span class="line">stu.save(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;保存成功&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>update(update,[options],[callback])</code>：修改对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">doc.update(&#123;<span class="attr">$set</span>:&#123;<span class="attr">age</span>:<span class="number">20</span>&#125;&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;修改成功&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>该法同上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">doc.age=<span class="number">20</span></span><br><span class="line">doc.save()</span><br></pre></td></tr></table></figure><p><code>remove([callback])</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">doc.remove(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>get(属性名)</code>：获取文档中的指定属性值</p><p><code>set(属性名)</code>：设置文档的指定属性值</p><p><code>id</code>：获取文档的_id属性值</p><p><code>toObject</code> :将Document对象转换为一个普通的Js对象，转换为普通的js对象以后，所有的Document对象的方法或属性都不能使用了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">doc.set(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;haah&#x27;</span>)</span><br><span class="line"><span class="comment">//相当于doc.name</span></span><br><span class="line">doc.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">doc.id(doc.\_id)</span><br><span class="line"><span class="keyword">var</span> o = doc.toObject()</span><br><span class="line"><span class="comment">//通过.的方式进行修改的话，只有save()才会修改数据库</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
            <tag> Mongoose </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数内的this指向</title>
      <link href="posts/22291/"/>
      <url>posts/22291/</url>
      
        <content type="html"><![CDATA[<h1 id="普通函数和箭头函数的this指向"><a href="#普通函数和箭头函数的this指向" class="headerlink" title="普通函数和箭头函数的this指向"></a>普通函数和箭头函数的this指向</h1><h2 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h2><p>普通函数中的this总是代表它的直接调用者，在默认情况下，this指向的是window。</p><p><strong>a.如果是一般函数，this指向全局对象window</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);   <span class="comment">//window</span></span><br><span class="line">&#125;</span><br><span class="line">fun(); <span class="comment">//相当于window.fun()</span></span><br></pre></td></tr></table></figure><p><strong>b.对象的方法里调用，this指向调用该方法的对象</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// obj</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.fn();</span><br></pre></td></tr></table></figure><p><strong>c.构造函数里的this，指向创建出来的实例</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age, name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)  <span class="comment">// 此处 this 分别指向 Person 的实例对象 p1 p2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="number">20</span>, <span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="number">18</span>, <span class="string">&#x27;李四&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>d. 事件中的this，绑定事件的元素</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&#x27;button&#x27;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);   <span class="comment">//button</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>箭头函数是ES6新增的，通俗的讲，箭头函数没有自己的this，它的this是继承而来；它指向的是外层的this，如果外层仍为箭头函数，则再指向外层，也就是说箭头函数的this指向箭头函数外面第一个不是箭头函数的那个函数的this。</p><p>看下面这段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj=&#123;</span><br><span class="line">    num:<span class="number">10</span>;</span><br><span class="line">    fun:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);  <span class="comment">//obj</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">//window</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.fun();</span><br></pre></td></tr></table></figure><p>第一个this指向obj对象，而setTimeout里面的匿名函数没有直接调用者，this指向window.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj=&#123;</span><br><span class="line">    num:<span class="number">10</span>;</span><br><span class="line">    fun:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);  <span class="comment">//obj</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">//obj</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.fun();</span><br></pre></td></tr></table></figure><p>而如果将setTimeout里面的普通函数，改成箭头函数，里面的this指向就会指向它外层的this。就是obj对象。</p><p>需要注意的是：<code>call、apply、bind</code>等方法也不能改变箭头函数this的指向。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> this指向 </tag>
            
            <tag> 箭头函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>promise以及promise的实现</title>
      <link href="posts/17885/"/>
      <url>posts/17885/</url>
      
        <content type="html"><![CDATA[<h1 id="Promise入门到自定义"><a href="#Promise入门到自定义" class="headerlink" title="Promise入门到自定义"></a>Promise入门到自定义</h1><h2 id="Promise介绍与基本使用"><a href="#Promise介绍与基本使用" class="headerlink" title="Promise介绍与基本使用"></a>Promise介绍与基本使用</h2><h3 id="对Promise的理解："><a href="#对Promise的理解：" class="headerlink" title="对Promise的理解："></a>对Promise的理解：</h3><p><strong>抽象表达</strong></p><p>1、Promise是一门新的技术(ES6规范)</p><p>2、Promise是Js中进行异步编程的新解决方案。旧方案是单纯使用回调函数。</p><p><strong>异步编程</strong>：fs文件操作、数据库操作、AJAX、定时器</p><p><strong>具体表达</strong></p><p>1、从语法上来说: Promise是一个构造函数</p><p>2、从功能上来说: promise对象用来封装一个异步操作并可以获取其成功/失败的结果值</p><h3 id="使用Promise的好处"><a href="#使用Promise的好处" class="headerlink" title="使用Promise的好处"></a>使用Promise的好处</h3><p>1、指定回调函数的方式更加灵活</p><p>2、支持链式调用，可以解决回调地狱问题</p><p>回调地狱：回调函数嵌套调用，外部回调函数异步执行的结果是嵌套的回调执行的条件</p><p><strong>回调地狱的缺点：</strong></p><p>1、不便于阅读</p><p>2、不便于异常处理</p><h3 id="util-promisify"><a href="#util-promisify" class="headerlink" title="util.promisify"></a>util.promisify</h3><p>传入一个遵循常见错误优先的回调风格的函数(即以(err,value)=&gt;…回调作为最后一个参数)，并返回一个返回promise的版本。</p><p>有了这个方法，我们不需要每次都对promise进行封装，而是可以借助这个方法将回调风格的转换为promise风格的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入until模块</span></span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>);</span><br><span class="line"><span class="comment">//引入fs模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="comment">//返回一个新的函数</span></span><br><span class="line"><span class="keyword">let</span> mineReadFile = util.promisify(fs.readFile);</span><br><span class="line">mineReadFile(<span class="string">&#x27;./resource/content.txt&#x27;</span>).then(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value.toString());</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Promise封装AJAX请求"><a href="#Promise封装AJAX请求" class="headerlink" title="Promise封装AJAX请求"></a>Promise封装AJAX请求</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendAJAX</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        xhr.responseType = <span class="string">&#x27;json&#x27;</span>;</span><br><span class="line">        xhr.open(<span class="string">&#x27;GET&#x27;</span>,url);</span><br><span class="line">        xhr.send();</span><br><span class="line">        xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(xhr.status &gt;=<span class="number">200</span> &amp;&amp; xhr.status &lt;<span class="number">300</span>)&#123;</span><br><span class="line">                    resolve(xhr.response);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    reject(xhr.status);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">sendAJAX(<span class="string">&#x27;https://api.apiopen.top/getJok&#x27;</span>)</span><br><span class="line">.then(value-&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;,<span class="function"><span class="params">reason</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.warn(reason)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Promise的状态和对象结果值属性"><a href="#Promise的状态和对象结果值属性" class="headerlink" title="Promise的状态和对象结果值属性"></a>Promise的状态和对象结果值属性</h3><p><img src="https://img2.jimu98.cn/haley/20210117154041.png" alt=""></p><h4 id="Promise的状态"><a href="#Promise的状态" class="headerlink" title="Promise的状态"></a>Promise的状态</h4><p>实例对象中的一个属性<code>PromiseState</code></p><p>1、pending：未决定的</p><p>2、resolved / fullfilled：成功</p><p>3、rejected：失败</p><p>promise只能从<code>pending 变为resolved</code>或者从<code>pending变为rejected</code>这两种情况，且一个promise对象只能改变一次，改变过就不能再改变了。</p><p>无论变为成功还是失败，都会有一个结果数据，成功的结果数据一般称为value，失败的结果数据一般称为reason。</p><h4 id="Promise对象的值"><a href="#Promise对象的值" class="headerlink" title="Promise对象的值"></a>Promise对象的值</h4><p>实例对象中的另一个属性<code>PromiseResult</code></p><p>保存着异步任务<code>成功/失败</code>的结果，只能通过resolve()和reject()改变。</p><h3 id="promise的工作流程"><a href="#promise的工作流程" class="headerlink" title="promise的工作流程"></a>promise的工作流程</h3><p><img src="https://img2.jimu98.cn/haley/20210117153240.png" alt="image-20210117153240501"></p><h2 id="Promise-API"><a href="#Promise-API" class="headerlink" title="Promise API"></a>Promise API</h2><h3 id="Promise构造函数"><a href="#Promise构造函数" class="headerlink" title="Promise构造函数"></a>Promise构造函数</h3><p>1、executor函数：执行器(resolve, reject)=&gt;{}</p><p>2、resolve函数：内部定义成功时我们调用的函数value =&gt;{}</p><p>3、reject函数:内部定义失败时我们调用的函数reason =&gt;{}</p><p>说明: executor会在 Promise内部立即同步调用，异步操作在执行器中执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//同步调用的</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">111</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">222</span>);</span><br><span class="line"><span class="comment">//输出：111 222</span></span><br></pre></td></tr></table></figure><h3 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then"></a>Promise.prototype.then</h3><p>1、onResolved函数：成功的回调函数(value)=&gt;{}</p><p>2、onRejected函数：失败的回调函数(reason)=&gt; {}</p><p>说明：指定用于得到成功value的成功回调和用于得到失败reason的失败回调，返回一个新的promise对象。</p><h3 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch"></a>Promise.prototype.catch</h3><p>1、onRejected函数：失败的回调函数(reason)=&gt;{}</p><p>说明：then()的语法糖，相当于：then(undefined,onRejected)</p><p>catch是进行的独立封装，内部也是通过then方法实现的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    reject(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p.catch(<span class="function"><span class="params">reason</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(reason);<span class="comment">//error</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Promise-resolve方法"><a href="#Promise-resolve方法" class="headerlink" title="Promise.resolve方法"></a>Promise.resolve方法</h3><p>value：成功的数据或promise对象</p><p>说明：返回一个成功/失败的promise对象</p><p>如果传入的参数为非promise类型的对象，返回的结果为成功的promise对象，如果传入的参数为promise对象，则参数的结果决定了resolve的结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">521</span>) <span class="comment">//成功</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.resolve(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    reject(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">&#125;))</span><br><span class="line"><span class="comment">//如果没有回调处理错误的话，会有一个报错</span></span><br><span class="line">p2.catch(<span class="function"><span class="params">reason</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(reason);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Promise-reject方法"><a href="#Promise-reject方法" class="headerlink" title="Promise.reject方法"></a>Promise.reject方法</h3><p>reason:失败的原因</p><p>说明:无论是什么类型的数据，返回一个失败的 promise对象</p><p>状态永远都是失败的，结果是传入的promise对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = Promisereject(<span class="number">522</span>) <span class="comment">//失败  </span></span><br></pre></td></tr></table></figure><h3 id="Promise-all方法"><a href="#Promise-all方法" class="headerlink" title="Promise.all方法"></a>Promise.all方法</h3><p>promises:包含n 个promise的数组</p><p>说明:返回一个新的 promise，只有所有的 promise都成功才成功，只要有一个失败了就直接失败</p><p>成功的结果是每一个promise成功的结果组成的数组，失败的结果是在这个promise数组中失败的那个Promsie的失败的结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//成功</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;Success&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;oh yeah&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> result = <span class="built_in">Promise</span>.all([p1,p2,p3])</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br><span class="line"><span class="comment">// promiseState:fulfilled</span></span><br><span class="line"><span class="comment">// promiseResult: Array(3) ok Success oh yeah</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//失败</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.reject(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;oh yeah&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> result = <span class="built_in">Promise</span>.all([p1,p2,p3])</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br><span class="line"><span class="comment">// promiseState:rejected</span></span><br><span class="line"><span class="comment">// promiseResult: error</span></span><br></pre></td></tr></table></figure><h3 id="Promise-race方法"><a href="#Promise-race方法" class="headerlink" title="Promise.race方法"></a>Promise.race方法</h3><p>promises：包含n个promise的数组<br>说明：返回一个新的promise，第一个完成的promise的结果状态就是最终的结果状态</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//失败</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        resolve(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;oh yeah&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> result = <span class="built_in">Promise</span>.race([p1,p2,p3])</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br><span class="line"><span class="comment">// promiseState:rejected</span></span><br><span class="line"><span class="comment">// promiseResult: success</span></span><br></pre></td></tr></table></figure><h2 id="Promise关键问题"><a href="#Promise关键问题" class="headerlink" title="Promise关键问题"></a>Promise关键问题</h2><h3 id="1、如何改变promise的状态"><a href="#1、如何改变promise的状态" class="headerlink" title="1、如何改变promise的状态?"></a>1、如何改变promise的状态?</h3><p>resolve(value)：如果当前是pending，就会变resolved</p><p>reject(reason)：如果当前是pending，就会变为rejected</p><p>抛出异常：如果当前是pending，就会变为rejected</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">    reject(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&#x27;error&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="2、一个promise指定多个成功-失败回调函数，都会调用吗"><a href="#2、一个promise指定多个成功-失败回调函数，都会调用吗" class="headerlink" title="2、一个promise指定多个成功/失败回调函数，都会调用吗?"></a>2、一个promise指定多个成功/失败回调函数，都会调用吗?</h3><p>当promise改变为对应状态时都会调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p.then(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br><span class="line">p.then(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">    alert(value)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//两个回调都会执行</span></span><br></pre></td></tr></table></figure><h3 id="3、改变promise状态和指定回调函数谁先谁后"><a href="#3、改变promise状态和指定回调函数谁先谁后" class="headerlink" title="3、改变promise状态和指定回调函数谁先谁后?"></a>3、改变promise状态和指定回调函数谁先谁后?</h3><p>都有可能，正常情况下是先指定回调再改变状态，但也可以先改状态再指定回调</p><h4 id="如何先改状态再指定回调"><a href="#如何先改状态再指定回调" class="headerlink" title="如何先改状态再指定回调?"></a>如何先改状态再指定回调?</h4><p>在执行器中直接调用resolve() / reject()</p><p>延迟更长时间才调用then()</p><h4 id="什么时候才能得到数据"><a href="#什么时候才能得到数据" class="headerlink" title="什么时候才能得到数据?"></a>什么时候才能得到数据?</h4><p>如果先指定的回调，那当状态发生改变时，回调函数就会调用，得到数据</p><p>如果先改变的状态，那当指定回调时，回调函数就会调用，得到数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        rsolve(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line">p.then(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="4、promise-then-返回的新promise的结果状态由什么决定"><a href="#4、promise-then-返回的新promise的结果状态由什么决定" class="headerlink" title="4、promise.then()返回的新promise的结果状态由什么决定?"></a>4、promise.then()返回的新promise的结果状态由什么决定?</h3><p>简单表达：由.then()指定的回调函数执行的结果决定</p><p>详细表达：</p><p>(1) 如果抛出异常，新 promise变为rejected, reason为抛出的异常</p><p>(2) 如果返回的是非promise的任意值，新 promise变为resolved, value为返回的值</p><p>(3) 如果返回的是另一个新promise，此promise的结果就会成为新promise的结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//1 抛出错误</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&#x27;error&#x27;</span>   <span class="comment">//reject &#x27;error&#x27;</span></span><br><span class="line">    <span class="comment">//2 返回结果是非Promise类型对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">521</span>    <span class="comment">//fulfilled 521</span></span><br><span class="line">    <span class="comment">// 3 返回结果是Promise对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        resolve(<span class="string">&#x27;success&#x27;</span>)  <span class="comment">//fulfilled &#x27;success&#x27;</span></span><br><span class="line">        reject(<span class="string">&#x27;error&#x27;</span>)   <span class="comment">//reject &#x27;error&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> result = p.then(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;,<span class="function"><span class="params">reason</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.warn(reason)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="5、promise如何串连多个操作任务"><a href="#5、promise如何串连多个操作任务" class="headerlink" title="5、promise如何串连多个操作任务?"></a>5、promise如何串连多个操作任务?</h3><p>prornise的 then()返回一个新的 promise，可以开成then()的链式调用</p><p>通过then的链式调用串连多个同步/异步任务</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        rsolve(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line">p.then(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        resolve(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)  <span class="comment">//success</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)  <span class="comment">//undefined</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="6、promise异常传透"><a href="#6、promise异常传透" class="headerlink" title="6、promise异常传透"></a>6、promise异常传透</h3><p>(1) 当使用promise的then链式调用时，可以在最后指定失败的回调</p><p>(2) 前面任何操作出了异常，都会传到最后失败的回调中处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        resolve(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p.then(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&#x27;失败了&#x27;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">222</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">333</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">reason</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.warn(reason);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="7、中断promise链"><a href="#7、中断promise链" class="headerlink" title="7、中断promise链"></a>7、中断promise链</h3><p>(1) 当使用promise的 then链式调用时，在中间中断，不再调用后面的回调函数</p><p>(2) 办法：在回调函数中返回一个pending状态的promise对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        resolve(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p.then(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">111</span>);</span><br><span class="line">    <span class="comment">//有且只有一个方式</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">()=&gt;</span>&#123;&#125;)  <span class="comment">// 111</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">222</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">333</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">reason</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.warn(reason);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Promise自定义封装"><a href="#Promise自定义封装" class="headerlink" title="Promise自定义封装"></a>Promise自定义封装</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//添加属性</span></span><br><span class="line">    <span class="built_in">this</span>.PromiseState = <span class="string">&quot;pending&quot;</span>;</span><br><span class="line">    <span class="built_in">this</span>.PromiseResult = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//声明一个保存异步任务回调函数的属性</span></span><br><span class="line">    <span class="comment">// this.callback = &#123;&#125;;</span></span><br><span class="line">    <span class="comment">//当then方法回调时，只要状态改变了，就会都触发，而使用对象保存时，后者会覆盖前者，这样是不合适的，所以我们可以选择用一个数组保存，而数组的元素是一个对象，保存每一个回调</span></span><br><span class="line">    <span class="built_in">this</span>.callbacks = [];</span><br><span class="line">    <span class="comment">//保存实例对象的this的值</span></span><br><span class="line">    <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">//resolve 函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">      <span class="comment">//promise的状态只能修改一次,只能从pending-resolve或者pending-reject</span></span><br><span class="line">      <span class="keyword">if</span> (self.PromiseState !== <span class="string">&quot;pending&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">      <span class="comment">//1. 修改对象的状态</span></span><br><span class="line">      self.PromiseState = <span class="string">&quot;fulfilled&quot;</span>;</span><br><span class="line">      <span class="comment">//2. 设置对象结果值</span></span><br><span class="line">      self.PromiseResult = data;</span><br><span class="line">      <span class="comment">//调用异步任务成功的回调函数</span></span><br><span class="line">      <span class="comment">// if(self.callback.onResolved)&#123;</span></span><br><span class="line">      <span class="comment">//     self.callback.onResolved(data);</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        self.callbacks.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">          item.onResolved(data);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//reject 函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">      <span class="comment">//promise的状态只能修改一次,只能从pending-resolve或者pending-reject</span></span><br><span class="line">      <span class="keyword">if</span> (self.PromiseState !== <span class="string">&quot;pending&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">      <span class="comment">//1. 修改对象的状态</span></span><br><span class="line">      self.PromiseState = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line">      <span class="comment">//2. 设置对象结果值</span></span><br><span class="line">      self.PromiseResult = data;</span><br><span class="line">      <span class="comment">//调用异步任务失败的回调函数</span></span><br><span class="line">      <span class="comment">// if(self.callback.onRejected)&#123;</span></span><br><span class="line">      <span class="comment">//     self.callback.onRejected(data);</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        self.callbacks.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">          item.onRejected(data);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//抛出异常的处理</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//执行器函数同步调用</span></span><br><span class="line">      executor(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="comment">//修改promise对象状态为失败</span></span><br><span class="line">      reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//添加then方法</span></span><br><span class="line">  <span class="function"><span class="title">then</span>(<span class="params">onResolved, onRejected</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">//处理异常穿透，如果没有传第二个函数，就默认指定一个</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> onRejected !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      onRejected = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> reason;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理值传递的问题，如果没传递值，promise也是可以向下穿透的</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> onResolved !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      onResolved = <span class="function">(<span class="params">value</span>) =&gt;</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//因为then方法的返回值是一个promise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//这里的try catch 用于处理then内抛出异常</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//这里可以使用this，是因为then()就是实例对象调用的</span></span><br><span class="line">          <span class="keyword">let</span> result = type(self.PromiseResult);</span><br><span class="line">          <span class="comment">//判断then()的返回值是什么类型</span></span><br><span class="line">          <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">            result.then(</span><br><span class="line">              (v) =&gt; &#123;</span><br><span class="line">                resolve(v);</span><br><span class="line">              &#125;,</span><br><span class="line">              (r) =&gt; &#123;</span><br><span class="line">                reject(r);</span><br><span class="line">              &#125;</span><br><span class="line">            );</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//结果的对象状态为成功</span></span><br><span class="line">            resolve(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//then方法同步任务回调函数的处理</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === <span class="string">&quot;fulfilled&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">//then方法的回调是异步的，所以要加setTimeout</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          callback(onResolved);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === <span class="string">&quot;rejected&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">//   onRejected(this.PromiseResult);</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          callback(onRejected);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//then方法异步任务回调函数的处理</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">//保存回调函数</span></span><br><span class="line">        <span class="comment">// this.callback = &#123;</span></span><br><span class="line">        <span class="comment">//     onResolved:onResolved,</span></span><br><span class="line">        <span class="comment">//     onRejected</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="built_in">this</span>.callbacks.push(&#123;</span><br><span class="line">          <span class="comment">// onResolved,</span></span><br><span class="line">          onResolved: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            callback(onResolved);</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="comment">// onRejected,</span></span><br><span class="line">          onRejected: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            callback(onRejected);</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//添加catch方法</span></span><br><span class="line">  <span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>, onRejected);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//添加resolve方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">resolve</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//属于类，而不属于实例对象，用static声明静态变量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">        value.then(</span><br><span class="line">          (v) =&gt; &#123;</span><br><span class="line">            resolve(v);</span><br><span class="line">          &#125;,</span><br><span class="line">          (r) =&gt; &#123;</span><br><span class="line">            reject(r);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//添加reject方法，返回的结果都是失败的</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      reject(reason);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//添加all方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">all</span>(<span class="params">promises</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//返回的结果为promise对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//count是成功的个数</span></span><br><span class="line">      <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//arr是存放成功的值</span></span><br><span class="line">      <span class="keyword">let</span> arr = [];</span><br><span class="line">      <span class="comment">//遍历</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">        promises[i].then(</span><br><span class="line">          (v) =&gt; &#123;</span><br><span class="line">            <span class="comment">//这里说明当前对象的状态是成功的</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">//将当前promise对象成功的结果存入到数组中，因为不知道什么时候改变promise的状态，用push可能会顺序不一样，所以选择当前下标赋值的方式保存</span></span><br><span class="line">            arr[i] = v;</span><br><span class="line">            <span class="keyword">if</span> (count === promises.length) &#123;</span><br><span class="line">              <span class="comment">//修改状态</span></span><br><span class="line">              resolve(arr);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          (r) =&gt; &#123;</span><br><span class="line">            reject(r);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//添加race方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">race</span>(<span class="params">promises</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">        promises[i].then(</span><br><span class="line">          (v) =&gt; &#123;</span><br><span class="line">            <span class="comment">//修改返回对象的状态为成功</span></span><br><span class="line">            resolve(v);</span><br><span class="line">          &#125;,</span><br><span class="line">          (r) =&gt; &#123;</span><br><span class="line">            <span class="comment">//修改返回对象的状态为失败</span></span><br><span class="line">            reject(r);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="async与await"><a href="#async与await" class="headerlink" title="async与await"></a>async与await</h2><h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p>1、函数的返回值为promise对象</p><p>2、promise对象的结果由async函数执行的返回值决定</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回结果的情况和then()相同</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//1 如果返回值是一个非promise类型的数据</span></span><br><span class="line">    <span class="comment">//return 521   //成功的promise,值为521</span></span><br><span class="line">    <span class="comment">//2 如果返回值是一个promise对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        resolve(<span class="string">&#x27;ok&#x27;</span>);  <span class="comment">//成功 ok</span></span><br><span class="line">        reject(<span class="string">&#x27;error&#x27;</span>) <span class="comment">//失败 error</span></span><br><span class="line">        <span class="comment">//3 抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&#x27;出错了&#x27;</span>  <span class="comment">//失败了 出错了    </span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = main();</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure><h3 id="await表达式"><a href="#await表达式" class="headerlink" title="await表达式"></a>await表达式</h3><p>1、await右侧的表达式一般为promise对象，但也可以是其它的值</p><p>2、如果表达式是promise对象，await返回的是promise成功的值</p><p>3、如果表达式是其它值，直接将此值作为await的返回值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        resolve(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">await</span> p;</span><br><span class="line">    <span class="keyword">let</span> res1 = awiat <span class="number">20</span>;</span><br><span class="line">    consolt.log(res,res1)  <span class="comment">// ok 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>1、await 必须写在async函数中，但async函数中可以没有await</p><p>2、如果 await的promise失败了，就会抛出异常，需要通过try…catch捕获处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        reject(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> res = <span class="keyword">await</span> p;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e);  <span class="comment">//error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue组件间通信</title>
      <link href="posts/40442/"/>
      <url>posts/40442/</url>
      
        <content type="html"><![CDATA[<h1 id="vue组件间通信"><a href="#vue组件间通信" class="headerlink" title="vue组件间通信"></a>vue组件间通信</h1><p>对于vue来说，组件之间的通信是非常重要的，下面我对vue组件间的通信做了总结。</p><h2 id="一、props-emit"><a href="#一、props-emit" class="headerlink" title="一、props/$emit"></a>一、props/$emit</h2><h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><p>父组件通过指令<code>v-bind</code>(可以简写为<code>:</code>)向子组件传递一个值，子组件通过props接收，在子组件内可以直接使用。</p><p><strong>父组件内</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Son :num&#x3D;&quot;num&quot;&gt;&lt;&#x2F;Son&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Son from &quot;.&#x2F;Son&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Parent&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Son,</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      num: 100,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><strong>子组件内</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">  &lt;div&gt;子组件的data：&#123;&#123; num &#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Son&quot;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    num: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="emit"><a href="#emit" class="headerlink" title="$emit"></a>$emit</h3><p>子组件想要修改父组件data的值时，如果直接在子组件内修改，就会报错，这时我们可以通过在父组件内定义好一个方法，通过指令<code>v-on</code>(可以简写为<code>@</code>)传给子组件，子组件传参进行修改</p><p><strong>父组件内</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">  &lt;Son @change-num&#x3D;&quot;changeNum&quot;&gt;&lt;&#x2F;Son&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Son from &quot;.&#x2F;Son&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Parent&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Son,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    changeNum(num) &#123;</span><br><span class="line">      this.num &#x3D; num;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><strong>子组件内</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;$emit(&#39;change-num&#39;, 99)&quot;&gt;修改&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><p>除了在这里使用<code>$emit</code>接收之外，如果还要进行其他的操作，可以写在js内</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;handleClick&quot;&gt;修改&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default&#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleClick() &#123;</span><br><span class="line">      &#x2F;&#x2F; 接收父组件传递过来的函数并调用,传参的方式可以在父组件内直接传递，也可以在子组件内传递</span><br><span class="line">        this.$emit(&#39;change-num&#39;, 99)</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>以上这种形式，我们使用下面这样方法也是一样的。</p><p><strong>父组件内</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">      &lt;Son :num&#x3D;&quot;num&quot; @update:num&#x3D;&quot;num&#x3D;$event&quot;&gt;&lt;&#x2F;Son&gt;</span><br><span class="line">      &#x2F;&#x2F;以上可以直接使用&#39;.sync&#39;进行简化</span><br><span class="line">      &lt;Son :num.sync&#x3D;&quot;num&quot;&gt;&lt;&#x2F;Son&gt;</span><br><span class="line">      &#x2F;&#x2F;如果传过去的是一个对象，那么就是将obj内的属性全都传递给了子组件，并且每个属性都有.sync功能，</span><br><span class="line">      &lt;Son v-bind.sync&#x3D;&quot;obj&quot;&gt;&lt;&#x2F;Son&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Son from &quot;.&#x2F;Son&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Parent&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Son,</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      num: 100,</span><br><span class="line">      obj: &#123;</span><br><span class="line">        num1: 100,</span><br><span class="line">        num2: 100,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><strong>子组件内</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;$emit(&#39;update:num&#39;, 99)&quot;&gt;修改&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;$emit(&#39;update:num1&#39;, 99)&quot;&gt;修改&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Son&quot;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    num: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">    &#125;,</span><br><span class="line">    num1: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h2 id="二、v-model"><a href="#二、v-model" class="headerlink" title="二、v-model"></a>二、v-model</h2><p>父组件通过<code>v-model</code>传递值给子组件时，会自动传递一个value的prop属性，在子组件中通过this.$emit(‘input’,val)自动修改v-model绑定的值</p><p><strong>父组件内</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Son v-model&#x3D;&quot;num&quot;&gt;&lt;&#x2F;Son&gt;</span><br><span class="line">&#x2F;&#x2F;v-model其实就相当于通过以下这种方式向子组件传递</span><br><span class="line">&lt;Son :value&#x3D;&quot;num&quot; @input&#x3D;&quot;changeNum&quot;&gt;&lt;&#x2F;Son&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Son from &quot;.&#x2F;Son&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Parent&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Son,</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      num: 100,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><strong>子组件内</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;$emit(&#39;input&#39;, 999)&quot;&gt;修改&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Son&quot;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    value: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h2 id="三、provide和inject"><a href="#三、provide和inject" class="headerlink" title="三、provide和inject"></a>三、provide和inject</h2><p>在 Vue.js 的 <code>2.2.0+</code> 版本中新添加<code>provide</code>和<code>inject</code>选项。他们成对出现，用于父级组件向下传递数据。</p><p>父组件中通过provider来提供变量，然后在子组件中通过inject来注入变量。不论子组件有多深，只要调用了inject，那么就可以注入provider中的数据。</p><p><code>provide</code>提供的数据是不可响应的，如果想提供响应的数据，可以使用<code>Vue.observable</code></p><p>当提供的数据并不是data里的死数据，需要在create 或者是 mounted 生命周期里获取的，直接提供是不行的，不会响应变化，此时可以在父组件内提供一个方法，该方法返回需要的数据，然后将此方法当做provide提供的值</p><p><strong>父组件内</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import Son1 from &quot;.&#x2F;Son1&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Parent1&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Son1,</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      obj: null,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      this.obj &#x3D; &#123; name: &quot;小红&quot;, age: 10 &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  provide() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      x: this.getObj,</span><br><span class="line">      &#x2F;&#x2F;可以将值直接写成一个函数：x: () &#x3D;&gt; this.obj,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">  getObj() &#123;</span><br><span class="line">  return this.obj;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><strong>子组件内</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;子组件的data：&#123;&#123; $parent.num &#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div&gt;使用父组件provide的数据：&#123;&#123; x() &#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Son1&quot;,</span><br><span class="line">  inject: [&quot;x&quot;],</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h2 id="四、-attrs和-listeners"><a href="#四、-attrs和-listeners" class="headerlink" title="四、$attrs和$listeners"></a>四、$attrs和$listeners</h2><p>第一种方式处理父子组件之间的数据传输有一个问题：如果父组件A下面有子组件B，组件B下面有组件C,这时如果组件A想传递数据给组件C怎么办呢？ 如果采用第一种方法，我们必须让组件A通过prop传递消息给组件B，组件B在通过prop传递消息给组件C；要是组件A和组件C之间有更多的组件，那采用这种方式就很复杂了。Vue 2.4开始提供了$attrs和$listeners来解决这个问题，能够让组件A之间传递消息给组件C。</p><p><strong>A组件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Parent2 :a&#x3D;&quot;10&quot; :obj&#x3D;&quot;&#123; naem: &#39;小花儿&#39; &#125;&quot; @x&#x3D;&quot;() &#x3D;&gt; console.log(1)&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p><strong>B组件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Son2 v-bind&#x3D;&quot;$attrs&quot; v-on&#x3D;&quot;$listeners&quot;&gt;&lt;&#x2F;Son2&gt;</span><br></pre></td></tr></table></figure><p><strong>C组件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Son2&quot;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    console.log(this.$attrs, this.$listeners);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h2 id="五-parent和-children"><a href="#五-parent和-children" class="headerlink" title="五$parent和$children"></a>五$parent和$children</h2><p>在组件内部可以直接通过子组件<code>$parent</code>对父组件进行操作，父组件通过<code>$children</code>对子组件进行操作。</p><p><strong>子组件内使用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&#123;&#123; $parent.num &#125;&#125;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p><strong>父组件内使用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&#123;&#123; $children.num &#125;&#125;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><h2 id="六、vuex"><a href="#六、vuex" class="headerlink" title="六、vuex"></a>六、vuex</h2><p>如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候才有上面这一些方法可能不利于项目的维护，vuex的做法就是将这一些公共的数据抽离出来，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的。</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL注入 </tag>
            
            <tag> DDOS </tag>
            
            <tag> SYN </tag>
            
            <tag> 组件通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES7、ES8、ES9、ES10、ES11的一些常用特性</title>
      <link href="posts/16452/"/>
      <url>posts/16452/</url>
      
        <content type="html"><![CDATA[<h1 id="ES7、ES8、ES9、ES10、ES11常用特性"><a href="#ES7、ES8、ES9、ES10、ES11常用特性" class="headerlink" title="ES7、ES8、ES9、ES10、ES11常用特性"></a>ES7、ES8、ES9、ES10、ES11常用特性</h1><h2 id="ES7-ES2016-新特性"><a href="#ES7-ES2016-新特性" class="headerlink" title="ES7(ES2016)新特性"></a>ES7(ES2016)新特性</h2><p>1、<code>Array.prototype.includes</code>：用来检测数组中是否包含某个元素，返回布尔类型值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mingzhu = [<span class="string">&#x27;西游记&#x27;</span>,‘红楼梦’,<span class="string">&#x27;三国演义&#x27;</span>]</span><br><span class="line"><span class="built_in">console</span>.log(mingzhu.includes(<span class="string">&#x27;西游记&#x27;</span>))  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(mingzhu.includes(<span class="string">&#x27;水浒传&#x27;</span>))  <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>2、<strong>指数运算符`</strong><code>**：实现幂运算，功能与</code>Math.pow()`相同</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span> ** <span class="number">10</span>)     <span class="comment">//1024</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.pow(<span class="number">2</span>,<span class="number">10</span>))   <span class="comment">//1024</span></span><br></pre></td></tr></table></figure><h2 id="ES8-ES2017-新特性"><a href="#ES8-ES2017-新特性" class="headerlink" title="ES8(ES2017)新特性"></a>ES8(ES2017)新特性</h2><h3 id="async和await"><a href="#async和await" class="headerlink" title="async和await"></a>async和await</h3><p>async和await两种语法结合，可以让异步代码像同步代码一样。</p><p>当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p><h4 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h4><p>1、async函数的返回值为Promise对象</p><p>2、promise对象的结果由async函数执行的返回值决定</p><ul><li>这个对象的状态由函数内部的return语句来决定，如果返回的结果不是一个Promise类型的对象或者返回的是一个成功的promised对象，返回的结果就是成功的Promise对象，如果返回的是一个失败的promise对象或者函数内部抛出错误，返回的结果就是失败的promise。</li></ul><h4 id="await表达式"><a href="#await表达式" class="headerlink" title="await表达式"></a>await表达式</h4><p>1、await必须写在async函数中</p><p>2、await右侧的表达式一般为promise对象</p><p>3、await返回的是promise成功的值</p><p>4、await的promise失败了，就会抛出异常，需要通过try…catch捕获处理</p><p><strong>成功</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建promise对象</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="string">&#x27;用户数据&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//await要放在async函数中</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> p;</span><br><span class="line">    <span class="built_in">console</span>.log(result);   <span class="comment">//用户数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用函数</span></span><br><span class="line">main();</span><br></pre></td></tr></table></figure><p><strong>失败</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    reject(<span class="string">&#x27;失败了&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="keyword">await</span> p;</span><br><span class="line">    <span class="built_in">console</span>.log(result); </span><br><span class="line">    &#125; <span class="keyword">catch</span>(e)&#123;</span><br><span class="line">        conole.log(e); <span class="comment">//失败了</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用函数</span></span><br><span class="line">main();</span><br></pre></td></tr></table></figure><h3 id="对象方法扩展"><a href="#对象方法扩展" class="headerlink" title="对象方法扩展"></a>对象方法扩展</h3><p><code>Object.values()</code>：返回一个给定对象的所有可枚举属性值的数组</p><p><code>Object.entries()</code>：返回一个给定对象自身可遍历属性[key,value]的数组</p><p><code>Object.getOwnPropertyDescriptors()</code>：返回指定对象自身属性的描述对象，如果没有任何自身属性，则返回空对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> animal = &#123;</span><br><span class="line">    name:<span class="string">&#x27;animal&#x27;</span>,</span><br><span class="line">    type:[<span class="string">&#x27;猫&#x27;</span>，<span class="string">&#x27;狗&#x27;</span>，<span class="string">&#x27;鸡&#x27;</span>,<span class="string">&#x27;鸭&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取对象所有的键</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(anmial))  <span class="comment">// name type</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(anmial))  <span class="comment">// [&#x27;animal&#x27;,Array[4]]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(anmial))  <span class="comment">// [[&#x27;name&#x27;,&#x27;anmimal&#x27;],[&#x27;type&#x27;,Array(4)]]</span></span><br><span class="line"><span class="comment">//创建Map</span></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">Object</span>.entries(animal));</span><br><span class="line"><span class="built_in">console</span>.log(m.get(<span class="string">&#x27;type&#x27;</span>)); <span class="comment">// [&#x27;猫&#x27;，&#x27;狗&#x27;，&#x27;鸡&#x27;,&#x27;鸭&#x27;]</span></span><br></pre></td></tr></table></figure><h2 id="ES9-ES2018-新特性"><a href="#ES9-ES2018-新特性" class="headerlink" title="ES9(ES2018)新特性"></a>ES9(ES2018)新特性</h2><h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><p>Rest参数与spread扩展运算符在ES6中已经引入，不过 ES6中只针对于数组，在ES9中为对象提供了像数组一样的rest参数和扩展运算符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myObject = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> &#123; a, ...x &#125; = myObject;</span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// x = &#123; b: 2, c: 3 &#125;</span></span><br><span class="line"></span><br><span class="line">restParam(&#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: <span class="number">3</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">restParam</span>(<span class="params">&#123; a, ...x &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// a = 1</span></span><br><span class="line">  <span class="comment">// x = &#123; b: 2, c: 3 &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; ...obj1, <span class="attr">z</span>: <span class="number">26</span> &#125;;</span><br><span class="line"><span class="comment">// obj2 is &#123; a: 1, b: 2, c: 3, z: 26 &#125;</span></span><br></pre></td></tr></table></figure><h3 id="正则扩展"><a href="#正则扩展" class="headerlink" title="正则扩展"></a>正则扩展</h3><h4 id="1、命名捕获分组"><a href="#1、命名捕获分组" class="headerlink" title="1、命名捕获分组"></a><strong>1、命名捕获分组</strong></h4><p>ES2018允许命名捕获组使用符号<code>?&lt;name&gt;</code>，在打开捕获括号(后立即命名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;&lt;a href=&quot;https://www.baidu.com&quot;&gt;百度&lt;/a&gt;&#x27;</span></span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/&lt;a href=&quot;(?&lt;url&gt;.*)&quot;&gt;(?&lt;text&gt;.*)&lt;\/a&gt;/</span></span><br><span class="line"><span class="keyword">const</span> result = reg.exec(str);</span><br><span class="line"><span class="built_in">console</span>.log(result.groups.url); <span class="comment">// https://www.baidu.com</span></span><br><span class="line"><span class="built_in">console</span>.log(result.groups.text); <span class="comment">// 百度</span></span><br></pre></td></tr></table></figure><h4 id="2、反向断言"><a href="#2、反向断言" class="headerlink" title="2、反向断言"></a><strong>2、反向断言</strong></h4><p>断言：判断这次的匹配结果是否正确。</p><p>正向断言（目标的后面）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;JS555555你知道么555啦啦啦&#x27;</span></span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/\d+(?=啦)/</span>;</span><br><span class="line"><span class="keyword">const</span> result = reg.exec(str);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure><p>反向断言（目标的前面）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;JS555555你知道么555啦啦啦&#x27;</span></span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/(?&lt;=么)\d+/</span>;</span><br><span class="line"><span class="keyword">const</span> result = reg.exec(str);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure><h4 id="3、dotAll模式"><a href="#3、dotAll模式" class="headerlink" title="3、dotAll模式"></a><strong>3、dotAll模式</strong></h4><p><code>.</code>(元字符)：匹配出换行符之外的任意单个字符。</p><p>标记<code>s</code>改变这种行为，允许行终止符的出现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/hello.world/.test(<span class="string">&#x27;hello\nworld&#x27;</span>);  <span class="comment">// false</span></span><br><span class="line">/hello.world/s.test(<span class="string">&#x27;hello\nworld&#x27;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="ES10-ES2019-新特性"><a href="#ES10-ES2019-新特性" class="headerlink" title="ES10(ES2019)新特性"></a>ES10(ES2019)新特性</h2><h3 id="1、对象扩展方法"><a href="#1、对象扩展方法" class="headerlink" title="1、对象扩展方法"></a><strong>1、对象扩展方法</strong></h3><p><code>Object.fromEntries()</code>：将二维数组转化为对象，Object.entries()的逆操作。</p><p><code>Object.entries()</code>：ES8引入的，将对象转化为二维数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.fromEntries([</span><br><span class="line">  [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;baz&#x27;</span>, <span class="number">42</span>]</span><br><span class="line">])</span><br><span class="line"><span class="comment">// &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span></span><br></pre></td></tr></table></figure><h3 id="2、字符串扩展方法"><a href="#2、字符串扩展方法" class="headerlink" title="2、字符串扩展方法"></a><strong>2、字符串扩展方法</strong></h3><p><code>trimStart()</code>和<code>trimEnd()</code>这两个方法的行为与trim()一致。</p><p><code>trimStart()</code>：消除字符串头部的空格</p><p><code>trimEnd()</code>：消除尾部的空格</p><p>它们返回的都是新字符串，不会修改原始字符串。</p><p>除了空格键，这两个方法对字符串头部（或尾部）的 tab 键、换行符等不可见的空白符号也有效。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="string">&#x27;  abc  &#x27;</span>;</span><br><span class="line">s.trim() <span class="comment">// &quot;abc&quot;</span></span><br><span class="line">s.trimStart() <span class="comment">// &quot;abc  &quot;</span></span><br><span class="line">s.trimEnd() <span class="comment">// &quot;  abc&quot;</span></span><br></pre></td></tr></table></figure><h3 id="3、数组扩展方法"><a href="#3、数组扩展方法" class="headerlink" title="3、数组扩展方法"></a><strong>3、数组扩展方法</strong></h3><p><code>flat()</code>：默认只会拉平一层，如果想要拉平多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1。</p><p><code>flatMap()</code>：只能展开一层数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].flat()</span><br><span class="line"><span class="comment">// [1, 2, 3, [4, 5]]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].flat(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果不管有多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数</span></span><br><span class="line">[<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>]]].flat(<span class="literal">Infinity</span>)</span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于 [[[2]], [[4]], [[6]], [[8]]].flat()</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [[x * <span class="number">2</span>]])</span><br><span class="line"><span class="comment">// [[2], [4], [6], [8]]</span></span><br></pre></td></tr></table></figure><p><code>Symbol.prototype.description</code>：描述信息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Symbol</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>(<span class="string">&#x27;HAHAH&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s.description) <span class="comment">//HAHAH</span></span><br></pre></td></tr></table></figure><h2 id="ES11-ES2020-新特性"><a href="#ES11-ES2020-新特性" class="headerlink" title="ES11(ES2020)新特性"></a>ES11(ES2020)新特性</h2><h3 id="1、私有属性"><a href="#1、私有属性" class="headerlink" title="1、私有属性"></a><strong>1、私有属性</strong></h3><p>前面加<code>#</code>，代表私有属性</p><p>只能在类里面进行访问，外面访问会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    name;</span><br><span class="line">    #age;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.#age = age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="title">intro</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.#age)  <span class="comment">//18</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> girl = <span class="keyword">new</span> Person(<span class="string">&#x27;小红&#x27;</span>，<span class="number">18</span>)；</span><br><span class="line"><span class="built_in">console</span>.log(girl.name); <span class="comment">//小红</span></span><br><span class="line"><span class="built_in">console</span>.log(girl.#age); <span class="comment">// 报错</span></span><br><span class="line">girl.intro();</span><br></pre></td></tr></table></figure><h3 id="2、Promise-allSettled"><a href="#2、Promise-allSettled" class="headerlink" title="2、Promise.allSettled()"></a><strong>2、Promise.allSettled()</strong></h3><p><code>all()</code>和<code>allSettled()</code>都是用来处理批量的异步任务的，<code>all</code>是所有的异步都成功，all才会返回成功。<code>allSettled</code>的返回始终是成功的，但是会返回每个异步的结果和状态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明两个promise对象</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        resolve(<span class="string">&#x27;商品数据-1&#x27;</span>)</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        resolve(<span class="string">&#x27;商品数据-2&#x27;</span>)</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//调用allSettled方法</span></span><br><span class="line"><span class="keyword">const</span> res = <span class="built_in">Promise</span>.allSettled([p1,p2])</span><br><span class="line"><span class="comment">//调用all方法</span></span><br><span class="line"><span class="keyword">const</span> result = <span class="built_in">Promise</span>.all([p1,p2])</span><br><span class="line"><span class="built_in">console</span>.log(res,result)</span><br></pre></td></tr></table></figure><h3 id="3、String-prototype-matchAll"><a href="#3、String-prototype-matchAll" class="headerlink" title="3、String.prototype.matchAll()"></a><strong>3、String.prototype.matchAll()</strong></h3><p>matchAll()：可以一次性取出所有匹配。不过它返回的是一个遍历器(Iterator)，而不是数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> string = <span class="string">&#x27;test1test2test3&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/t(e)(st(\d?))/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> match <span class="keyword">of</span> string.matchAll(regex)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(match);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&quot;test1&quot;, &quot;e&quot;, &quot;st1&quot;, &quot;1&quot;, index: 0, input: &quot;test1test2test3&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;test2&quot;, &quot;e&quot;, &quot;st2&quot;, &quot;2&quot;, index: 5, input: &quot;test1test2test3&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;test3&quot;, &quot;e&quot;, &quot;st3&quot;, &quot;3&quot;, index: 10, input: &quot;test1test2test3&quot;]</span></span><br></pre></td></tr></table></figure><h3 id="4、可选链操作符"><a href="#4、可选链操作符" class="headerlink" title="4、可选链操作符"></a><strong>4、可选链操作符</strong></h3><p>当我们正在访问一个不属于对象的属性时，JavaScript 引擎会抛出错误。</p><p>某些情况下值是否存在并不重要，因为我们知道它会存在。于是可选链式调用就派上用场了！我们可以使用由一个问号和一个点组成的可选链式操作符去表示不应该引发错误。如果没有值，返回 undefined。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params">config</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//const dbHost = config &amp;&amp; config.db &amp;&amp; config.db.host;</span></span><br><span class="line">    <span class="keyword">const</span> dbHost = config?.db?.host;</span><br><span class="line">    <span class="built_in">console</span>.log(dbHost);</span><br><span class="line">&#125;</span><br><span class="line">main(&#123;</span><br><span class="line">    db: &#123;</span><br><span class="line">        host:<span class="string">&#x27;192.168.1.100&#x27;</span>,</span><br><span class="line">        username:<span class="string">&#x27;root&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="5、动态import"><a href="#5、动态import" class="headerlink" title="5、动态import"></a><strong>5、动态import</strong></h3><p>在使用的时候通过import方法导入，提高加载的速度，它的返回值是一个promise对象，成功的回调就是导入的内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Alert.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">show</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 Alert.js 的文件</span></span><br><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;/components/Alert.js&#x27;</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">Alert</span> =&gt;</span> &#123;</span><br><span class="line">        Alert.show()</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h3 id="6、BigInt类型"><a href="#6、BigInt类型" class="headerlink" title="6、BigInt类型"></a><strong>6、BigInt类型</strong></h3><p>JavaScript 所有数字都保存成 64 位浮点数，这给数值的表示带来了两大限制。</p><ul><li><p>数值的精度只能到 53 个二进制位(相当于 16 个十进制位)，大于这个范围的整数，JavaScript 是无法精确表示的，这使得 JavaScript 不适合进行科学和金融方面的精确计算。</p></li><li><p>大于或等于2的1024次方的数值，JavaScript 无法表示，会返回Infinity。ES2020引入了一种新的数据类型 BigInt(大整数)来解决这个问题，这是 ECMAScript 的第八种数据类型。BigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。</p></li></ul><p>为了与 Number 类型区别，BigInt 类型的数据必须添加后缀n。BigInt 与普通整数是两种值，它们之间并不相等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> n = <span class="number">521n</span></span><br><span class="line"><span class="built_in">console</span>.log(n,<span class="keyword">typeof</span>(n));  <span class="comment">// 521n BigInt</span></span><br><span class="line"><span class="comment">// BigInt 的运算</span></span><br><span class="line"><span class="number">1n</span> + <span class="number">2n</span> <span class="comment">// 3n</span></span><br><span class="line"><span class="number">42n</span> === <span class="number">42</span> <span class="comment">// false</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">123n</span> <span class="comment">// &#x27;bigint&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>函数BigInt</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> n = <span class="number">123</span>;</span><br><span class="line"><span class="built_in">console</span>.log(BigInt(n));  <span class="comment">//123n</span></span><br><span class="line"><span class="comment">//BigInt不能对浮点数进行操作</span></span><br><span class="line"><span class="built_in">console</span>.log(BigInt(<span class="number">1.2</span>));  <span class="comment">// 出错</span></span><br></pre></td></tr></table></figure><h3 id="7、globalThis-全局对象"><a href="#7、globalThis-全局对象" class="headerlink" title="7、globalThis 全局对象"></a><strong>7、globalThis 全局对象</strong></h3><p>JavaScript可以在不同环境中运行，比如浏览器或者Node.js。浏览器中可用的全局对象是变量 <code>window</code>，但在Node.js 中是一个叫做 <code>global</code>的对象。为了在不同环境中都使用统一的全局对象，引入了<code>globalThis</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浏览器</span></span><br><span class="line"><span class="built_in">window</span> == globalThis <span class="comment">// true</span></span><br><span class="line"><span class="comment">// node.js</span></span><br><span class="line"><span class="built_in">global</span> == globalThis <span class="comment">// true</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES7 </tag>
            
            <tag> ES8 </tag>
            
            <tag> ES9 </tag>
            
            <tag> ES10 </tag>
            
            <tag> ES11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ajax学习笔记</title>
      <link href="posts/32852/"/>
      <url>posts/32852/</url>
      
        <content type="html"><![CDATA[<h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><h2 id="ajax简介"><a href="#ajax简介" class="headerlink" title="ajax简介"></a>ajax简介</h2><p><code>AJAX</code>全称为 Asynchronous JavaScript And XML，就是异步的JS和 XML。</p><p>通过AJAX可以在浏览器中向服务器发送异步请求，最大的优势：<strong>无刷新获取数据</strong>。</p><p>传统的网页（不使用 AJAX）如果需要更新内容，必须重载整个页面。AJAX可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页内容。现在已经进阶成 Asynchronous JavaScript and JSON(ajaj)</p><p>AJAX不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式。</p><h3 id="XML简介"><a href="#XML简介" class="headerlink" title="XML简介"></a>XML简介</h3><p>XML可扩展标记语言。</p><p>XML被设计用来传输和存储数据，而HTML用来在网页上呈现数据。</p><p>XML和HTML类似，不同的是HTML中都是预定义标签，而XML中没有预定义标签，全都是自定义标签，用来表示一些数据。</p><p>XML现在已经被JSON取代了，灵活度要远胜于XML。</p><h3 id="AJAX的特点"><a href="#AJAX的特点" class="headerlink" title="AJAX的特点"></a>AJAX的特点</h3><p><strong>优点</strong></p><p>1、可以无需刷新页面而与服务器端进行通信。</p><p>2、允许你根据用户事件来更新部分页面内容。<br><strong>缺点</strong><br>1、没有浏览历史，不能回退</p><p>2、存在跨域问题(同源)</p><p>3、SEO不友好，爬虫爬取不到</p><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>HTTP协议『超文本传输协议』，协议详细规定了浏览器和万维网服务器之间互相通信的规则。</p><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><p>可以分为以下四个部分</p><p>发送get请求时，请求体是空的，发送post请求时，请求体可以不为空</p><p><img src="C:%5CUsers%5Cyanjiao%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210110154144509.png" alt="image-20210110154144509"></p><h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><p><img src="C:%5CUsers%5Cyanjiao%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210110154109157.png" alt="image-20210110154109157"></p><h2 id="原生发送ajax请求"><a href="#原生发送ajax请求" class="headerlink" title="原生发送ajax请求"></a>原生发送ajax请求</h2><h3 id="get请求"><a href="#get请求" class="headerlink" title="get请求"></a>get请求</h3><h4 id="1、创建-xhr-对象"><a href="#1、创建-xhr-对象" class="headerlink" title="1、创建 xhr 对象"></a>1、创建 xhr 对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr=<span class="keyword">new</span> XMLHttpRequest();</span><br></pre></td></tr></table></figure><h4 id="2、使用对象创建请求"><a href="#2、使用对象创建请求" class="headerlink" title="2、使用对象创建请求"></a>2、使用对象创建请求</h4><p>创建请求：open(‘请求的类型’,’地址’,’是否异步’)</p><p>请求的类型(后台规定的)：GET  POST  PUT  PATCH DELETE …</p><p>是否异步：true为异步，false为同步</p><p><strong>设置url参数的方式</strong>：在请求地址的后面写一个问号，请求字段=请求值，多个参数使用&amp;，例：<code>http://localhost:8000/server?a=100&amp;b=200&amp;c=300</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;http://localhost:8000/server&#x27;</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h4 id="3、使用-send-发出请求"><a href="#3、使用-send-发出请求" class="headerlink" title="3、使用 send 发出请求"></a>3、使用 send 发出请求</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><h4 id="4、使用-onreadystatechange-函数监听请求的过程，获取响应"><a href="#4、使用-onreadystatechange-函数监听请求的过程，获取响应" class="headerlink" title="4、使用 onreadystatechange 函数监听请求的过程，获取响应"></a>4、使用 onreadystatechange 函数监听请求的过程，获取响应</h4><p>监听整个请求过程</p><p><code>xhr.readyState</code>请求状态 0-4    4：请求成功，响应就绪</p><p><code>xhr.status</code> 请求状态码  200：ok</p><p><code>xhr.responseText</code>   返回的数据</p><p>获取到的数据类似数组字符串(json 串)</p><p>json串：属性名和属性值必须使用双引号，数字和布尔值不需要，最后一项没有逗号</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>)&#123;</span><br><span class="line">       <span class="keyword">if</span>(xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>)&#123;</span><br><span class="line">           <span class="built_in">console</span>.log(xhr.status) <span class="comment">//状态码</span></span><br><span class="line">           <span class="built_in">console</span>.log(xhr.statusText) <span class="comment">//状态字符串</span></span><br><span class="line">           <span class="built_in">console</span>.log(xhr.getAllResponseHeaders()) <span class="comment">//所有响应头</span></span><br><span class="line">           <span class="built_in">console</span>.log(xhr.response) <span class="comment">//响应体</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 创建对象</span></span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">//2. 初始化 设置请求方法和url </span></span><br><span class="line">xhr.open(<span class="string">&#x27;POST&#x27;</span>,<span class="string">&#x27;http://localhost:8000/server&#x27;</span>);</span><br><span class="line"><span class="comment">//3. 发送</span></span><br><span class="line">xhr.send();</span><br><span class="line"><span class="comment">// 4. 处理服务器端返回的结果</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//判断</span></span><br><span class="line">    <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(xhr.status)</span><br><span class="line">            <span class="built_in">console</span>.log(xhr.statusText)</span><br><span class="line">            <span class="built_in">console</span>.log(xhr.getAllResponseHeaders())</span><br><span class="line">            <span class="built_in">console</span>.log(xhr.response)</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>post设置请求体</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xhr.send(<span class="string">&#x27;a=100&amp;b=200&amp;c=300&#x27;</span>)</span><br><span class="line">xhr.send(<span class="string">&#x27;a:100&amp;6:200&amp;c:300&#x27;</span>)</span><br><span class="line">xhr.send(<span class="string">&#x27;1234567&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>ajax设置请求头</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xhr.setRequestHeader(<span class="string">&#x27;Content-type&#x27;</span>,<span class="string">&#x27;applicaton/x-www-form-urlencoded&#x27;</span>)</span><br><span class="line"><span class="comment">//自定义请求头</span></span><br><span class="line">xhr.setRequestHeader(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;hahhaahha&#x27;</span>)</span><br></pre></td></tr></table></figure><p>原生 ajax 不能接收对象为参数，只能接收 json 串，使用 <code>xhr.setRequestHeader()</code> 设置请求头，添加 json 为可传递数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xhr.setRequestHeader(<span class="string">&quot;Content-type&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">xhr.send(</span><br><span class="line">  <span class="built_in">JSON</span>.stringify(&#123; <span class="attr">accesstoken</span>: <span class="string">&quot;ecf878d1-6052-476a-8262-824760c7872b&quot;</span> &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="ie缓存问题"><a href="#ie缓存问题" class="headerlink" title="ie缓存问题"></a>ie缓存问题</h3><p>ie浏览器会对ajax请求的结果进行缓存，当我们再发送请求时，它会从本地读取，而不会再次发送请求，我们可以使用如下方式解决</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置一个时间戳，在实际的工作中，不需要我们进行操作</span></span><br><span class="line">xhr.open(<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;http://localhost:8000/ie?t=&#x27;</span>+<span class="built_in">Date</span>.now());</span><br></pre></td></tr></table></figure><h4 id="请求超时与网络异常处理"><a href="#请求超时与网络异常处理" class="headerlink" title="请求超时与网络异常处理"></a>请求超时与网络异常处理</h4><p>项目在上线后，肯定会出现请求超时的情况，我们不能保证服务端能及时的做出响应。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//超时设置2s</span></span><br><span class="line">hr.timeout = <span class="number">2000</span>;</span><br><span class="line"><span class="comment">//超时回调</span></span><br><span class="line">xhr.ontimeout = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;网络异常，请稍后重试！！&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//网络异常回调</span></span><br><span class="line">xhr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;你的网络似乎出了一些问题！！&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="手动取消请求"><a href="#手动取消请求" class="headerlink" title="手动取消请求"></a>手动取消请求</h3><p>使用<code>abort()</code>方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.abort()</span><br></pre></td></tr></table></figure><h3 id="重复发送请求"><a href="#重复发送请求" class="headerlink" title="重复发送请求"></a>重复发送请求</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isSending = <span class="literal">false</span> <span class="comment">//标识变量</span></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//判断标识变量</span></span><br><span class="line">    <span class="keyword">if</span>(isSending) x.abort();<span class="comment">//如果正在发送，则取消该请求</span></span><br><span class="line">    x = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    isSending = <span class="literal">true</span>; <span class="comment">//修改标识变量的值</span></span><br><span class="line">    x.open(<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;...&#x27;</span>);</span><br><span class="line">    x.send();</span><br><span class="line">    x.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x.readyState === <span class="number">4</span>)&#123;</span><br><span class="line">            isSending = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JQuery发送AJAX请求"><a href="#JQuery发送AJAX请求" class="headerlink" title="JQuery发送AJAX请求"></a>JQuery发送AJAX请求</h2><h3 id="get-post请求"><a href="#get-post请求" class="headerlink" title="get/post请求"></a>get/post请求</h3><p>$ .get/post（地址，参数，回调函数，返回内容的格式）</p><p>地址：后台接口地址</p><p>参数：要求传送的参数，不需要可省略</p><p>回调函数：载入成功时的回调函数，默认接收一个参数，就是返回的结果</p><p>返回内容的格式：默认json，不需要设置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;.btn1&#x27;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $.get(<span class="string">&#x27;http://localhost:8000/jquery-server&#x27;</span>,&#123;<span class="attr">a</span>:<span class="number">100</span>,<span class="attr">b</span>:<span class="number">200</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data)</span><br><span class="line">    &#125;,<span class="string">&#x27;json&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">$(<span class="string">&#x27;.btn1&#x27;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $.post(<span class="string">&#x27;http://localhost:8000/jquery-server&#x27;</span>,&#123;<span class="attr">a</span>:<span class="number">100</span>,<span class="attr">b</span>:<span class="number">200</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data)</span><br><span class="line">    &#125;,<span class="string">&#x27;json&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="通用方法-ajax-发送ajax请求"><a href="#通用方法-ajax-发送ajax请求" class="headerlink" title="通用方法$.ajax()发送ajax请求"></a>通用方法<code>$.ajax()</code>发送ajax请求</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;.btn2&quot;</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     $.ajax(&#123;</span><br><span class="line">       <span class="comment">//请求地址</span></span><br><span class="line">       url: <span class="string">&quot;http://localhost:8000/jquery-server&quot;</span>,</span><br><span class="line">       <span class="comment">//请求参数</span></span><br><span class="line">       data: &#123; <span class="attr">a</span>: <span class="number">100</span>, <span class="attr">b</span>: <span class="number">200</span> &#125;,</span><br><span class="line">       <span class="comment">//请求类型</span></span><br><span class="line">       type: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">       <span class="comment">//响应体结果</span></span><br><span class="line">       dataType: <span class="string">&quot;json&quot;</span>,</span><br><span class="line">       <span class="comment">//请求成功的回调</span></span><br><span class="line">       success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(data);</span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="comment">//超时时间</span></span><br><span class="line">       timeout: <span class="number">2000</span>,</span><br><span class="line">       <span class="comment">//失败的回调</span></span><br><span class="line">       error: <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">           <span class="built_in">console</span>.log(<span class="string">&#x27;出错了！！！&#x27;</span>)</span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="comment">// 请求结束的回调</span></span><br><span class="line">       complete: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">       <span class="comment">//请求头的设置:需要配合后台做一些设置</span></span><br><span class="line">       Headers: &#123;</span><br><span class="line">           c: <span class="number">300</span>,</span><br><span class="line">           d: <span class="number">400</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 发给后台的内容类型 默认支持对象类型</span></span><br><span class="line">  <span class="comment">// contentType: &quot;&quot;</span></span><br><span class="line"> <span class="comment">// 请求是否同域，false代表同域请求，true 代表跨域请求，默认为false</span></span><br><span class="line"> <span class="comment">// 一般来说后台独立解决了跨域请求的问题，不需要前端进行配置,也有前后端一起解决跨域问题，后台需要前端做一些简单的配置</span></span><br><span class="line"> <span class="comment">// crossDomain: 布尔值</span></span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><h4 id="请求的地址"><a href="#请求的地址" class="headerlink" title="请求的地址"></a>请求的地址</h4><p><a href="http://localhost:3008/posts?id=1：地址栏的问号部分就是查询部分">http://localhost:3008/posts?id=1：地址栏的问号部分就是查询部分</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url: <span class="string">&quot;http://localhost:3008/posts?_limit=10&amp;_page=1&quot;</span>,</span><br><span class="line">    <span class="comment">//   url: &quot;http://localhost:3008/posts&quot;,      </span></span><br><span class="line">    <span class="comment">//   data: &#123; _limit: 10, _page: 1 &#125;,      </span></span><br><span class="line">    <span class="function"><span class="title">success</span>(<span class="params">res</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="axios发送AJAX请求"><a href="#axios发送AJAX请求" class="headerlink" title="axios发送AJAX请求"></a>axios发送AJAX请求</h2><p>axios 是专门的 ajax 请求插件，它里面的异步解决方案使用的是 promise。文档<a href="https://www.kancloud.cn/yunye/axios/234845">参考网址</a></p><p>axios就是使用 promise封装了异步操作</p><p>axios.get(‘地址’).then(res=&gt;{}).catch(err=&gt;{}）</p><p>then是成功函数，res是成功的返回值，axios会将后台的数据存储到一个对象的data属性内</p><p>catch是失败函数，err是失败的信息</p><p>首先需要引入axios</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cdn：</span><br><span class="line">&lt;script src=<span class="string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="get请求-1"><a href="#get请求-1" class="headerlink" title="get请求"></a>get请求</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">&quot;http://localhost:3008/posts&quot;</span>, &#123;</span><br><span class="line">    <span class="comment">//url参数</span></span><br><span class="line">    params: &#123;</span><br><span class="line">      _limit: <span class="number">20</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//请求头信息</span></span><br><span class="line">    headers: &#123;</span><br><span class="line">    name:<span class="string">&#x27;hahahah&#x27;</span>,</span><br><span class="line">        age:<span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="post请求-1"><a href="#post请求-1" class="headerlink" title="post请求"></a>post请求</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.baseURL = <span class="string">&#x27;http://localhost:8000&#x27;</span></span><br><span class="line">axios.post(<span class="string">&#x27;/axios-server&#x27;</span>,&#123;</span><br><span class="line"><span class="comment">//请求体</span></span><br><span class="line">    username:<span class="string">&#x27;admin&#x27;</span>,</span><br><span class="line">    password:<span class="string">&#x27;admin&#x27;</span></span><br><span class="line">&#125;,&#123;</span><br><span class="line"><span class="comment">//url参数</span></span><br><span class="line">    params: &#123;</span><br><span class="line">    id:<span class="number">200</span>,</span><br><span class="line">        vip:<span class="number">8</span></span><br><span class="line">    &#125;,</span><br><span class="line">   <span class="comment">//请求头信息</span></span><br><span class="line">    headers: &#123;</span><br><span class="line">    height:<span class="number">180</span>,</span><br><span class="line">        weight:<span class="number">180</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="通用方法"><a href="#通用方法" class="headerlink" title="通用方法"></a>通用方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line"><span class="comment">//请求方法</span></span><br><span class="line">    method:<span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="comment">//url</span></span><br><span class="line">    url:<span class="string">&#x27;/axios-server&#x27;</span>,</span><br><span class="line">    <span class="comment">//url参数</span></span><br><span class="line">   parames&#123;</span><br><span class="line">    vip:<span class="number">10</span>,</span><br><span class="line">        level:<span class="number">30</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//头信息</span></span><br><span class="line">    headers: &#123;</span><br><span class="line">    a:<span class="number">100</span>,</span><br><span class="line">        b:<span class="number">100</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//请求体参数</span></span><br><span class="line">data: &#123;</span><br><span class="line">    username:<span class="string">&#x27;admin&#x27;</span>,</span><br><span class="line">    password: <span class="string">&#x27;admin&#x27;</span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">response</span>=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(response.status)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="fetch函数发送AJAX请求"><a href="#fetch函数发送AJAX请求" class="headerlink" title="fetch函数发送AJAX请求"></a>fetch函数发送AJAX请求</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    fetch(<span class="string">&#x27;http://localhost:8000/fetch-server?vip=10&#x27;</span>,&#123;</span><br><span class="line">        <span class="comment">//请求方法</span></span><br><span class="line">        method:<span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">        <span class="comment">//请求头</span></span><br><span class="line">        headers: &#123;</span><br><span class="line">            name:<span class="string">&#x27;hhahaha&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//请求体</span></span><br><span class="line">        body:<span class="string">&#x27;username=admin&amp;password=admin&#x27;</span></span><br><span class="line">    &#125;).then(<span class="function"><span class="params">response</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//return response.text();</span></span><br><span class="line">        <span class="keyword">return</span> response.json();</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">response</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(response)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Express的基本使用"><a href="#Express的基本使用" class="headerlink" title="Express的基本使用"></a>Express的基本使用</h2><p>Express：基于node.js平台，快速、开放、极简的web开发框架。</p><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i express</span><br></pre></td></tr></table></figure><p>新建一个文件夹，初始化为node项目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init --yes</span><br></pre></td></tr></table></figure><p>新建一个express.js文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 引入express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 创建应用对象</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 创建路由规则</span></span><br><span class="line"><span class="comment">//request是对请求报文的封装</span></span><br><span class="line"><span class="comment">//response是对响应报文的封装</span></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>,<span class="function">(<span class="params">request,response</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//设置响应</span></span><br><span class="line">    response.send(<span class="string">&#x27;HELLO EXPRESS&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 监听端口启动服务</span></span><br><span class="line">app.listen(<span class="number">8000</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;服务已经启动，8000端口监听中...&#x27;</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在命令行执行<code>node express.js</code>，当前数据就跑在本地服务器的8000端口了。</p><p>服务端响应JSON数据</p><p>如果从服务端请求回来的数据是一个JSON对象，前端可以有两种方式对数据进行转化</p><p>1、手动对数据转化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="built_in">JSON</span>.parse(xhr.response)</span><br></pre></td></tr></table></figure><p>2、自动转化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置响应体数据的类型</span></span><br><span class="line">xhr.responseType = <span class="string">&#x27;json&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(xhr.response)</span><br></pre></td></tr></table></figure><h3 id="nodemon工具"><a href="#nodemon工具" class="headerlink" title="nodemon工具"></a>nodemon工具</h3><p>当文件的内容进行了修改的时候，nodemon可以自动重启服务。</p><p>安装</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g nodemon</span><br></pre></td></tr></table></figure><p>启动服务</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nodemon 文件名.js</span><br></pre></td></tr></table></figure><h2 id="使用-json-server-模拟后台数据库"><a href="#使用-json-server-模拟后台数据库" class="headerlink" title="使用 json-server 模拟后台数据库"></a>使用 json-server 模拟后台数据库</h2><ul><li><p>全局安装 json-server <code>npm i -g json-server</code> </p></li><li><p>在需要的地方新建 xxx.json 文件，该文件内写法如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;users&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;id&quot;: 121,</span><br><span class="line">      &quot;username&quot;: &quot;小王&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;id&quot;: 21,</span><br><span class="line">      &quot;username&quot;: &quot;小二&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的 json 文件生成的数据代表 users 列表数据</p></li><li><p>在该 json 文件所在的地方打开命令行工具，启动数据库服务。<code>json-server --watch xxx.json -p 3000</code>，命令执行完毕之后，数据库就启动了，不要关闭该服务。启动的服务可以使用 ‘<a href="http://localhost:3000/users&#39;">http://localhost:3000/users&#39;</a> 接口就能访问用户列表了。</p></li><li><p>ctrl+c关闭服务器</p></li><li><p>更详细的接口文档说明参考<a href="https://github.com/typicode/json-server">json-server</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> ajax </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ES6学习笔记</title>
      <link href="posts/38921/"/>
      <url>posts/38921/</url>
      
        <content type="html"><![CDATA[<h1 id="ES6学习笔记"><a href="#ES6学习笔记" class="headerlink" title="ES6学习笔记"></a>ES6学习笔记</h1><h2 id="const-和-let命令"><a href="#const-和-let命令" class="headerlink" title="const 和 let命令"></a>const 和 let命令</h2><p>const ：声明常量(不可修改的，例如 π)，常量的名称都是全大写的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pI = <span class="number">3.14</span></span><br><span class="line">PI++</span><br><span class="line"><span class="built_in">console</span>.log(PI)</span><br><span class="line"><span class="comment">//会报错</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：const 对于数组和对象的元素修改，不算做对常量的修改，不会报错，因为地址没变。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;吕布&#x27;</span>,</span><br><span class="line">  age: <span class="number">28</span>,</span><br><span class="line">&#125;</span><br><span class="line">obj.level = <span class="number">15</span></span><br><span class="line"><span class="comment">//不会报错</span></span><br></pre></td></tr></table></figure><p>let：声明的变量是可以被修改的</p><h3 id="let-、const-和-var-的不同"><a href="#let-、const-和-var-的不同" class="headerlink" title="let 、const 和 var 的不同"></a>let 、const 和 var 的不同</h3><ul><li><p>不能重复声明</p></li><li><p>没有声明提升</p></li><li><p>存在块级作用域(作用域被定义在 {} 内)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; <span class="number">10</span>; index++) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(index)</span><br><span class="line"><span class="comment">//会报错</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h2><p>ES6允许按照一定模式从数组和对象中提取值，对变量进行赋值，这被称为解构赋值。</p><h3 id="1、对象解构赋值"><a href="#1、对象解构赋值" class="headerlink" title="1、对象解构赋值"></a>1、对象解构赋值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  username: <span class="string">&#x27;貂蝉&#x27;</span>,</span><br><span class="line">  userage: <span class="number">18</span>,</span><br><span class="line">  level: <span class="number">10</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123; username, <span class="attr">userage</span>: age &#125; = obj</span><br><span class="line"><span class="built_in">console</span>.log(username, age)</span><br><span class="line"><span class="comment">//貂蝉 18</span></span><br></pre></td></tr></table></figure><h3 id="2、数组的解构赋值"><a href="#2、数组的解构赋值" class="headerlink" title="2、数组的解构赋值"></a>2、数组的解构赋值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> [a, b, c] = arr</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c)</span><br><span class="line"><span class="comment">// 1,2,3</span></span><br></pre></td></tr></table></figure><h3 id="3、函数参数的解构赋值"><a href="#3、函数参数的解构赋值" class="headerlink" title="3、函数参数的解构赋值"></a>3、函数参数的解构赋值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  username: <span class="string">&#x27;貂蝉&#x27;</span>,</span><br><span class="line">  userage: <span class="number">18</span>,</span><br><span class="line">  level: <span class="number">10</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showInfo</span>(<span class="params">&#123; username, level &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// const &#123; username, level &#125; = obj</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`该英雄的名称是<span class="subst">$&#123;username&#125;</span>`</span>, <span class="string">`等级<span class="subst">$&#123;level&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">showInfo(obj)</span><br><span class="line"><span class="comment">//该英雄的名称是貂蝉, 等级10</span></span><br></pre></td></tr></table></figure><h3 id="4、技巧-交换变量的值"><a href="#4、技巧-交换变量的值" class="headerlink" title="4、技巧: 交换变量的值"></a>4、技巧: 交换变量的值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line">[x, y] = [y, x];</span><br><span class="line"><span class="built_in">console</span>.log(x, y);</span><br><span class="line"><span class="comment">// 2 1</span></span><br></pre></td></tr></table></figure><h2 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h2><h3 id="模版字符串"><a href="#模版字符串" class="headerlink" title="模版字符串"></a>模版字符串</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> username = <span class="string">&#x27;lucy&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`my name is <span class="subst">$&#123;username&#125;</span>`</span>)</span><br></pre></td></tr></table></figure><h3 id="新增的字符串方法"><a href="#新增的字符串方法" class="headerlink" title="新增的字符串方法"></a>新增的字符串方法</h3><ul><li><p>includes()：返回布尔值，表示是否找到了参数字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Hello world!&#x27;</span>;</span><br><span class="line">s.includes(<span class="string">&#x27;o&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Hello world!&#x27;</span>;</span><br><span class="line">s.startsWith(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Hello world!&#x27;</span>;</span><br><span class="line">s.endsWith(<span class="string">&#x27;!&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>trimStart()：消除字符串头部的空格，返回的是新字符串，不会修改原始字符串。</p></li><li><p>trimEnd()：消除尾部的空格，返回的是新字符串，不会修改原始字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="string">&#x27;  abc  &#x27;</span>;</span><br><span class="line">s.trim() <span class="comment">// &quot;abc&quot;</span></span><br><span class="line">s.trimStart() <span class="comment">// &quot;abc  &quot;</span></span><br><span class="line">s.trimEnd() <span class="comment">// &quot;  abc&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>padStart()：用于头部补全</p></li><li><p>padEnd()：用于尾部补全</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;x&#x27;</span>.padStart(<span class="number">5</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;ababx&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.padStart(<span class="number">4</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;abax&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.padEnd(<span class="number">5</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;xabab&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.padEnd(<span class="number">4</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;xaba&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>matchAll()：返回一个正则表达式在当前字符串的所有匹配，相当于match()加了全局匹配。</p></li></ul><h2 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h2><p>ES6允许给函数参数赋值：初始值</p><h3 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h3><h4 id="普通方式：参数非对象"><a href="#普通方式：参数非对象" class="headerlink" title="普通方式：参数非对象"></a>普通方式：参数非对象</h4><p>如果该参数具有默认值并且没有为它传递实参，那么它的位置要在最后，否则的话会报错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fun = <span class="function"><span class="keyword">function</span> (<span class="params">color = <span class="string">&#x27;黑色&#x27;</span>, bgColor = <span class="string">&#x27;红色&#x27;</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;颜色:::&#x27;</span>, color)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;背景色:::&#x27;</span>, bgColor)</span><br><span class="line">&#125;</span><br><span class="line">fun(<span class="string">&#x27;蓝色&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="参数为对象"><a href="#参数为对象" class="headerlink" title="参数为对象"></a>参数为对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fun = <span class="function"><span class="keyword">function</span> (<span class="params">&#123; color = <span class="string">&#x27;黑色&#x27;</span>, bgColor = <span class="string">&#x27;蓝色&#x27;</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;颜色:::&#x27;</span>, color)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;背景色:::&#x27;</span>, bgColor)</span><br><span class="line">&#125;</span><br><span class="line">fun(&#123; <span class="attr">color</span>: <span class="string">&#x27;粉色&#x27;</span> &#125;)</span><br><span class="line"><span class="comment">// 不能什么都不传，最起码传递一个空对象</span></span><br></pre></td></tr></table></figure><h2 id="rest参数-剩余"><a href="#rest参数-剩余" class="headerlink" title="rest参数(剩余)"></a>rest参数(剩余)</h2><p>ES6引入rest参数，用于获取函数的实参，用来代替arguments</p><h3 id="ES5引入实参的方式"><a href="#ES5引入实参的方式" class="headerlink" title="ES5引入实参的方式"></a>ES5引入实参的方式</h3><ul><li>arguments是一个类数组，实际上是一个对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">date</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">date(<span class="string">&#x27;白芷&#x27;</span>，<span class="string">&#x27;阿娇&#x27;</span>，<span class="string">&#x27;思慧&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="ES6的rest参数"><a href="#ES6的rest参数" class="headerlink" title="ES6的rest参数"></a>ES6的rest参数</h3><ul><li>rest是一个数组，我们可以使用数组的方法进行操作</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...rest</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(rest)</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：如果有多个参数时，rest参数必须要放到参数的最后</p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>ES6允许使用箭头(=&gt;)定义函数。</p><h3 id="普通函数的写法"><a href="#普通函数的写法" class="headerlink" title="普通函数的写法"></a>普通函数的写法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> res = add(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br><span class="line"><span class="comment">//30</span></span><br></pre></td></tr></table></figure><h3 id="箭头函数的写法"><a href="#箭头函数的写法" class="headerlink" title="箭头函数的写法"></a>箭头函数的写法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> res = add(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br><span class="line"><span class="comment">//30</span></span><br></pre></td></tr></table></figure><h3 id="箭头函数的简写"><a href="#箭头函数的简写" class="headerlink" title="箭头函数的简写"></a>箭头函数的简写</h3><p>1、箭头左边是函数的参数部分，使用小括号包裹参数、逗号拼接，当形参有且只有一个的时候，可以省略小括号。</p><p>2、箭头右边是函数主体，使用花括号包裹，当代码体只有一条语句的时候，此时return必须省略，而且语句的执行结果就是函数的返回值时，此时可以省略花括号</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2</span><br><span class="line"><span class="keyword">const</span> res = add(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br><span class="line"><span class="comment">//30</span></span><br></pre></td></tr></table></figure><h3 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="headerlink" title="箭头函数和普通函数的区别"></a>箭头函数和普通函数的区别</h3><ul><li><p>箭头函数定义只能使用变量式定义</p></li><li><p>函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</p></li><li><p>不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误。</p></li><li><p>不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用<code>rest</code>参数代替。</p></li><li><p>不可以使用 yield 命令，因此箭头函数不能用作Generator函数。</p></li></ul><h2 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h2><h3 id="1、Array-from"><a href="#1、Array-from" class="headerlink" title="1、Array.from()"></a>1、Array.from()</h3><p><code>Array.from()</code>  将类数组转化为数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fun1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(<span class="built_in">arguments</span>))</span><br><span class="line">&#125;</span><br><span class="line">fun1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure><h3 id="2、Array-of"><a href="#2、Array-of" class="headerlink" title="2、Array.of"></a>2、Array.of</h3><p><code>Array.of</code>   用于将一组值，转换为数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3,11,8]</span></span><br></pre></td></tr></table></figure><h3 id="3、find-和-findIndex"><a href="#3、find-和-findIndex" class="headerlink" title="3、find() 和 findIndex()"></a>3、find() 和 findIndex()</h3><p><code>find</code>   用于找出第一个符合条件的数组成员。</p><p><code>findIndex</code>  返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].find(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;) <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].findIndex(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="4、entries-、keys-和-values"><a href="#4、entries-、keys-和-values" class="headerlink" title="4、entries()、keys() 和 values()"></a>4、entries()、keys() 和 values()</h3><p><code>entries()</code>，<code>keys()</code>和<code>values()</code>用于遍历数组，可以用<code>for...of</code>循环进行遍历。</p><p><code>keys()</code>是对键名的遍历</p><p><code>values()</code>是对键值的遍历</p><p><code>entries()</code>是对键值对的遍历</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 &quot;a&quot;</span></span><br><span class="line"><span class="comment">// 1 &quot;b&quot;</span></span><br></pre></td></tr></table></figure><h3 id="5、flat-和-flatMap"><a href="#5、flat-和-flatMap" class="headerlink" title="5、flat() 和 flatMap()"></a>5、flat() 和 flatMap()</h3><p><code>flat()</code>  用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]].flat()</span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p><code>flat()</code>默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将<code>flat()</code>方法的参数写成一个整数，表示想要拉平的层数，默认为1。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].flat()</span><br><span class="line"><span class="comment">// [1, 2, 3, [4, 5]]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].flat(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><p><code>flatMap()</code>  对原数组的每个成员执行一个函数（相当于执行<code>map()</code>），然后对返回值组成的数组执行<code>flat()</code>方法。该方法返回一个新数组，不改变原数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相当于 [[2, 4], [3, 6], [4, 8]].flat()</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].flatMap(<span class="function">(<span class="params">x</span>) =&gt;</span> [x, x * <span class="number">2</span>])</span><br><span class="line"><span class="comment">// [2, 4, 3, 6, 4, 8]</span></span><br></pre></td></tr></table></figure><h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><p>[…]：扩展运算符能够将数组转换为逗号分隔的参数序列</p><h3 id="扩展运算符的应用"><a href="#扩展运算符的应用" class="headerlink" title="扩展运算符的应用"></a>扩展运算符的应用</h3><h4 id="对象的拷贝或者数组的拷贝-浅拷贝，无法拷贝原型内的方法"><a href="#对象的拷贝或者数组的拷贝-浅拷贝，无法拷贝原型内的方法" class="headerlink" title="对象的拷贝或者数组的拷贝(浅拷贝，无法拷贝原型内的方法)"></a>对象的拷贝或者数组的拷贝(浅拷贝，无法拷贝原型内的方法)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;庄周&#x27;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj1 = &#123; ...obj &#125;</span><br><span class="line">obj1.hobby = <span class="string">&#x27;浪&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj, obj1)</span><br><span class="line"><span class="comment">//&#123;name: &quot;庄周&quot;, age: 18&#125; &#123;name: &quot;庄周&quot;, age: 18, hobby: &quot;浪&quot;&#125;</span></span><br></pre></td></tr></table></figure><h4 id="将伪数组转为真正的数组"><a href="#将伪数组转为真正的数组" class="headerlink" title="将伪数组转为真正的数组"></a>将伪数组转为真正的数组</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> arr1 = [...arr]</span><br><span class="line">arr1.push(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr, arr1)</span><br><span class="line"><span class="comment">// [1, 2, 3] [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><h4 id="数组的合并"><a href="#数组的合并" class="headerlink" title="数组的合并"></a>数组的合并</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> kuaizi =[王太利<span class="string">&#x27;，&#x27;</span>肖央<span class="string">&#x27;];</span></span><br><span class="line"><span class="string">const fenghuang =[曾毅&#x27;</span>，<span class="string">&#x27;玲花&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> zuixuanxiaopingguo = [...kuaizi， ...fenghuang];</span><br><span class="line"><span class="built_in">console</span>.log(zuixuanxiaopingguo);</span><br><span class="line"><span class="comment">//&#x27;王太利&quot;，&#x27;肖央&#x27;，‘曾毅&quot;，&#x27;玲花</span></span><br></pre></td></tr></table></figure><h2 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h2><h3 id="对象的简洁表示法"><a href="#对象的简洁表示法" class="headerlink" title="对象的简洁表示法"></a>对象的简洁表示法</h3><p>当对象的属性名和作为该属性的属性值的变量名相同时，我们就可以使用对象的简洁表示法</p><p>函数可以省略function，但只有普通函数可以省略</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> username = <span class="string">&#x27;哈哈&#x27;</span></span><br><span class="line"><span class="keyword">const</span> userage = <span class="number">20</span></span><br><span class="line"><span class="keyword">const</span> sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;this.username&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  username,</span><br><span class="line">  userage,</span><br><span class="line">  sayName,</span><br><span class="line">  <span class="function"><span class="title">say</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br></pre></td></tr></table></figure><h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>第七种数据类型，生成独一无二的数据</p><h3 id="创建Symbol"><a href="#创建Symbol" class="headerlink" title="创建Symbol"></a>创建Symbol</h3><p>1、let s = Symbol()</p><p>2、let s2 = Symbol(‘aa’)</p><ul><li>aa仅仅是标志，没有实际意义，通过这种方法创建两个一模一样的，===判断时是false</li></ul><p>3、let s3 = Symbol.for(‘aa’)</p><ul><li>通过这种方式创建的两个一模一样的，===判断是true</li></ul><h2 id="set-数据结构"><a href="#set-数据结构" class="headerlink" title="set 数据结构"></a>set 数据结构</h2><p>类似于数组，但是不能存在重复的值</p><p>Set本身是一个构造函数，用来生成 Set 数据结构。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ary = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">131</span>, <span class="number">312</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">131</span>])</span><br><span class="line"><span class="built_in">console</span>.log(ary)</span><br><span class="line"><span class="comment">//[1,2,131,312]</span></span><br></pre></td></tr></table></figure><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p><code>size</code>  返回Set实例的成员总数</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><code>add()</code>   向set数据内添加一个成员，返回数据本身<br><code>delete()</code>   删除某个值，返回一个布尔值<br><code>has()</code>   查看该值是否为Set的成员，返回一个布尔值<br><code>clear()</code>   清除所有成员</p><h3 id="如何将-set-数据转化成数组："><a href="#如何将-set-数据转化成数组：" class="headerlink" title="如何将 set 数据转化成数组："></a>如何将 set 数据转化成数组：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([...ary])</span><br></pre></td></tr></table></figure><h3 id="实现数组去重"><a href="#实现数组去重" class="headerlink" title="实现数组去重"></a>实现数组去重</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newArr = [<span class="number">1</span>, <span class="number">1231</span>, <span class="number">23</span>, <span class="number">12</span>, <span class="number">31</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">12</span>, <span class="number">31</span>, <span class="number">23</span>, <span class="number">12</span>]</span><br><span class="line"><span class="built_in">console</span>.log([...new <span class="built_in">Set</span>(newArr)])</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：可以使用Set实现搜索历史记录的展示</p><h3 id="Set-结构的实例有四个遍历方法，可以用于遍历成员。"><a href="#Set-结构的实例有四个遍历方法，可以用于遍历成员。" class="headerlink" title="Set 结构的实例有四个遍历方法，可以用于遍历成员。"></a>Set 结构的实例有四个遍历方法，可以用于遍历成员。</h3><ul><li>Set.prototype.keys()：返回键名的遍历器</li><li>Set.prototype.values()：返回键值的遍历器</li><li>Set.prototype.entries()：返回键值对的遍历器</li><li>Set.prototype.forEach()：使用回调函数遍历每个成员</li></ul><p>还有一个额外的 WeakSet 数据结构，内部成员只能是对象类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> 因为是对象类型，所以地址相等，才是重复</span><br><span class="line"> <span class="keyword">const</span> ary1 = <span class="keyword">new</span> <span class="built_in">WeakSet</span>([<span class="number">1</span>, <span class="number">2</span>],[<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"> <span class="built_in">console</span>.log(ary1)</span><br><span class="line"><span class="comment">//[1,2][1,2]</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"> <span class="keyword">const</span> ary1 = <span class="keyword">new</span> <span class="built_in">WeakSet</span>([arr, arr])</span><br><span class="line"> <span class="built_in">console</span>.log(ary1)</span><br><span class="line"><span class="comment">//[1,2]</span></span><br></pre></td></tr></table></figure><h2 id="class-类的基本语法"><a href="#class-类的基本语法" class="headerlink" title="class 类的基本语法"></a>class 类的基本语法</h2><p>类的花括号内默认一般只写方法，而且方法之间不需要逗号</p><p>constructor 是 class 自带函数，该函数被称作构造器，和以前的构造函数类似</p><p>constructor 函数当创建实例化类的时候自动触发，除了 constructor 函数之外定义的函数都相当于原来的 prototype 内的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  say = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我是王者荣耀的英雄&#x27;</span> + <span class="built_in">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> Hero(<span class="string">&#x27;牛&#x27;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> Hero(<span class="string">&#x27;小乔&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="built_in">console</span>.log(b)</span><br><span class="line">a.say()</span><br></pre></td></tr></table></figure><h3 id="class的继承"><a href="#class的继承" class="headerlink" title="class的继承"></a>class的继承</h3><p>Class 可以通过<code>extends</code>关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarryHero</span> <span class="keyword">extends</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name, age)</span><br><span class="line">    <span class="comment">// super 调用了才真正实现了继承</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> CarryHero(<span class="string">&#x27;赵云&#x27;</span>, <span class="number">19</span>)</span><br><span class="line"><span class="built_in">console</span>.log(c)</span><br></pre></td></tr></table></figure><h2 id="module"><a href="#module" class="headerlink" title="module"></a>module</h2><h3 id="模块的导出"><a href="#模块的导出" class="headerlink" title="模块的导出"></a>模块的导出</h3><p>默认导出和命名导出可以同时存在。</p><h4 id="1、命名导出"><a href="#1、命名导出" class="headerlink" title="1、命名导出"></a>1、命名导出</h4><p>命名导出可以使用多次</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1008</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">export</span>&#123; a &#125;;</span><br><span class="line"><span class="keyword">export</span>&#123; b &#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>导出多个使用花括号，中间用逗号隔开即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; a，b &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> school =<span class="string">&quot;实验&#x27;;</span></span><br><span class="line"><span class="string">function findob(&#123;</span></span><br><span class="line"><span class="string">console.log(&quot;</span>我们可以帮助你找工作!!<span class="string">&quot;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">export &#123;school，findob&#125;;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><h4 id="2、默认导出"><a href="#2、默认导出" class="headerlink" title="2、默认导出"></a>2、默认导出</h4><p>默认导出只能使用一次</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1008</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">school: <span class="string">&#x27;实验&#x27;</span>,</span><br><span class="line">change: <span class="function"><span class="keyword">function</span>(<span class="params">i</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="built_in">console</span>.log(<span class="string">&quot;我们可以改变你!!&quot;</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span></span></span><br></pre></td></tr></table></figure><h3 id="模块的导入"><a href="#模块的导入" class="headerlink" title="模块的导入"></a>模块的导入</h3><p>模块路径第三方和核心模块直接写包名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">&quot;jquery&quot;</span>;</span><br><span class="line"><span class="comment">//导入jQuery</span></span><br></pre></td></tr></table></figure><h4 id="1、命名导入"><a href="#1、命名导入" class="headerlink" title="1、命名导入"></a>1、命名导入</h4><p>命名导入的名称必须和导出的名称一致，但是可以使用as换名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;a,b <span class="keyword">as</span> x&#125; <span class="keyword">from</span> <span class="string">&quot;./about&quot;</span>;</span><br></pre></td></tr></table></figure><h4 id="2、默认导入"><a href="#2、默认导入" class="headerlink" title="2、默认导入"></a>2、默认导入</h4><p>默认导入，导入的名称可以和导出的名称不一致</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> x <span class="keyword">from</span> <span class="string">&#x27;./about&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> xxx，&#123; a <span class="keyword">as</span> x,b &#125;<span class="keyword">from</span> <span class="string">&quot;./about&quot;</span>;</span><br></pre></td></tr></table></figure><h4 id="3、全部导入"><a href="#3、全部导入" class="headerlink" title="3、全部导入"></a>3、全部导入</h4><p>全部导入，会将该js文件内的所有导出的变量全部导入，可以采用<code>obj.变量名</code>的形式读取值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> obj <span class="keyword">from</span> <span class="string">&quot;./about&quot;</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是事件委托？</title>
      <link href="posts/42773/"/>
      <url>posts/42773/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是事件委托？"><a href="#什么是事件委托？" class="headerlink" title="什么是事件委托？"></a>什么是事件委托？</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>那什么叫事件委托呢？它还有一个名字叫事件代理，事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。</p><p>那这是什么意思呢？网上的各位大牛们讲事件委托基本上都用了同一个例子，就是取快递来解释这个现象，我仔细揣摩了一下，这个例子还真是恰当，我就不去想别的例子来解释了，借花献佛，我摘过来，大家认真领会一下事件委托到底是一个什么原理：</p><p>有三个同事预计会在周一收到快递。为签收快递，有两种办法：一是三个人在公司门口等快递；二是委托给前台MM代为签收。现实当中，我们大都采用委托的方案（公司也不会容忍那么多员工站在门口就为了等快递）。前台MM收到快递后，她会判断收件人是谁，然后按照收件人的要求签收，甚至代为付款。这种方案还有一个优势，那就是即使公司里来了新员工（不管多少），前台MM也会在收到寄给新员工的快递后核实并代为签收。</p><p>这里其实还有2层意思的：</p><p>第一，现在委托前台的同事是可以代为签收的，即程序中的现有的dom节点是有事件的；</p><p>第二，新员工也是可以被前台MM代为签收的，即程序中新添加的dom节点也是有事件的。</p><h2 id="事件委托的原理"><a href="#事件委托的原理" class="headerlink" title="事件委托的原理"></a>事件委托的原理</h2><p>事件委托是利用事件的冒泡原理来实现的，何为事件冒泡呢？就是事件从最深的节点开始，然后逐步向上传播事件，举个例子：页面上有这么一个节点树，div&gt;ul&gt;li&gt;a;比如给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a&gt;li&gt;ul&gt;div，有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul，li，a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件委托，委托它们父级代为执行事件。</p><h2 id="事件委托的实现"><a href="#事件委托的实现" class="headerlink" title="事件委托的实现"></a>事件委托的实现</h2><p>这里用父级ul做事件处理，当li被点击时，由于冒泡原理，事件就会冒泡到ul上，因为ul上有点击事件，所以事件就会触发。</p><p>Event对象提供了一个属性叫 <code>target</code>，可以返回事件的目标节点，我们成为事件源，也就是说，target就可以表示为当前的事件操作的dom，但是不是真正操作dom，当然，这个是有兼容性的，标准浏览器用 <code>event.target</code> ，IE浏览器用<code>event.srcElement</code>，此时只是获取了当前节点的位置，并不知道是什么节点名称，这里我们用tagName来获取具体是什么标签名，这个返回的是一个大写的，我们需要转成小写再做比较:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=<span class="string">&quot;parent&quot;</span>&gt;</span><br><span class="line">    &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;child&quot;</span>&gt;one&lt;/li&gt;</span><br><span class="line">&lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;child&quot;</span>&gt;two&lt;/li&gt;</span><br><span class="line">&lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;child&quot;</span>&gt;three&lt;/li&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt; </span><br><span class="line">    <span class="comment">//⽗元素 </span></span><br><span class="line">    <span class="keyword">var</span> dom= <span class="built_in">document</span>.getElementById(<span class="string">&#x27;parent&#x27;</span>); </span><br><span class="line"><span class="comment">//⽗元素绑定事件，代理⼦元素的点击事件 </span></span><br><span class="line">dom.onclick= <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123; </span><br><span class="line">        <span class="keyword">var</span> event= event || <span class="built_in">window</span>.event;</span><br><span class="line">        <span class="keyword">var</span> curTarget= event.target || event.srcElement;</span><br><span class="line">        <span class="keyword">if</span> (curTarget.tagName.toLowerCase() == <span class="string">&#x27;li&#x27;</span>) &#123; </span><br><span class="line">            <span class="comment">//事件处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>这样做的好处就是：</p><p>1、节省内存占用，减少事件注册</p><p>2、新增子元素时也不需要再次对其绑定事件，适合动态添加元素</p><p>但它也有一定的局限性：</p><p>1、focus、blur之类的事件本身没有事件冒泡的机制，所以没法委托</p><p>2、mousemove、mouseout这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗比较高，不适合事件委托。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DOM </tag>
            
            <tag> 事件委托 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOM事件流</title>
      <link href="posts/48335/"/>
      <url>posts/48335/</url>
      
        <content type="html"><![CDATA[<h1 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h1><p><strong>事件</strong>就是文档或浏览器窗口中发⽣的⼀些特定的交互瞬间。</p><p><strong>事件流</strong>(又叫时间传播)描述的是从页面中接收事件的顺序。</p><h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><p>时间冒泡，即事件开始时由最具体的元素(文档中嵌套层次最深的那个节点)接收，然后逐级向上传播到较为不具体的节点。</p><p>例子如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果单击了如上例子中的<code>&lt;div&gt;</code>元素，那么这个click事件会沿着DOM树向上传播，在每一级的节点上都会发生。所以以上代码按照如下顺序传播：</p><p>1、div</p><p>2、body</p><p>3、html</p><p>4、document</p><h3 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a>阻止事件冒泡</h3><p>事件冒泡是可以被阻止的。防止因为事件冒泡而带来不必要的错误和困扰。</p><p>w3c的方法是：<code>e.stopPropagation()</code></p><p>stopPropagation也是事件对象(Event)的一个方法，作用是阻止目标元素的冒泡事件，但是会不阻止默认行为。</p><p>IE则是：<code>e.cancelBubble = true</code></p><h2 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h2><p>事件捕获的思想就是不太具体的节点应该更早接收到事件，而最具体的节点应该是最后接收到事件。</p><p>事件捕获的用意就在于在事件到达预定目标之前就捕获它。</p><p>还是以上一节的html结构为例：</p><p>在事件捕获的过程中，document对象会首先接收到click事件，然后事件沿DOM树一次向下，一直传播到事件的实际目标，即触发单击事件的div元素。</p><p>所以以上代码按照如下顺序传播：</p><p>1、document</p><p>2、html</p><p>3、body</p><p>4、div</p><h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p>DOM2级事件规定的事件流包括三个阶段：</p><p>1、事件捕获阶段：事件从Document节点自上而下向目标节点传播的阶段；</p><p>2、处于目标阶段：真正的目标节点正在处理事件的阶段；</p><p>3、时间冒泡阶段：事件从目标节点自下而上向Document节点传播的阶段；</p><p><img src="https://img2.jimu98.cn/haley/20210307215657.jpeg" alt="如图："></p><p><strong>注意：</strong></p><p>1、JS代码只能执行捕获或者冒泡其中一个阶段(要么是捕获要么是冒泡)；</p><p>2、onclick和attachEvent(ie)只能得到冒泡阶段；</p><p>3、addEventListener(type, listener[, useCapture]) 第三个参数如果是true，表示在事件捕获阶段调用事件处理程序；如果是false(不写默认是false)，表示在事件冒泡阶段调用事件处理程序；</p><p>4、实际开发中，我们很少使用事件捕获，我们更关注事件冒泡；</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 事件流 </tag>
            
            <tag> 事件冒泡 </tag>
            
            <tag> 事件捕获 </tag>
            
            <tag> DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器的重绘与回流</title>
      <link href="posts/40189/"/>
      <url>posts/40189/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览器的重绘与回流"><a href="#浏览器的重绘与回流" class="headerlink" title="浏览器的重绘与回流"></a>浏览器的重绘与回流</h1><h2 id="浏览器的运行机制"><a href="#浏览器的运行机制" class="headerlink" title="浏览器的运行机制"></a>浏览器的运行机制</h2><p>1、构建DOM树：渲染引擎解析HTML文档，首先将标签转换成DOM树中的DOM node(包括js生成的标签)，生成内容树(Content Tree/DOM Tree)；</p><p>2、构建渲染树：解析对应的CSS样式文件信息(包括js生成的样式和外部css文件)，而这些文件信息以及HTML中可见的指令(如<b></b>)<strong>，构建渲染树</strong>(Rendering Tree/Frame Tree)；render tree中每个node都有自己的style，而且render tree不包含隐藏的节点(比如display:none的节点，还有head节点)，因为这些节点不会用于呈现</p><p>3、布局渲染树（reflow/layout）：从根节点递归调用，计算每一个元素的大小、位置等，给出每个节点所应该在屏幕上出现的精确坐标；</p><p>4、绘制渲染树（paint/repaint）：遍历渲染树，使用UI 层来绘制每个节点。</p><p><img src="https://img2.jimu98.cn/haley/20210309160505.png" alt="image-20210309160502353"></p><h2 id="重绘-repaint或redraw"><a href="#重绘-repaint或redraw" class="headerlink" title="重绘(repaint或redraw)"></a>重绘(repaint或redraw)</h2><p>当盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来之后，浏览器便把这些原色都按照各自的特性绘制一遍，将内容呈现在页面上。</p><p><strong>重绘是指一个元素外观的改变</strong>所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。</p><p><strong>触发重绘的条件</strong>：改变元素外观属性。如：color，background-color等.</p><p><strong>注意：</strong>table及其内部元素可能需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多花两倍时间，这就是我们尽量避免使用table布局页面的原因之一。</p><h2 id="重排重-构-回流-reflow"><a href="#重排重-构-回流-reflow" class="headerlink" title="重排重(构/回流/reflow)"></a>重排重(构/回流/reflow)</h2><p>当渲染树中的一部分(或全部)因为元素的规模、尺寸、布局、隐藏等改变而需要重新构建, 这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。</p><p><strong>重绘和重排的关系</strong>：在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为重绘。</p><p>所以，<strong>重排必定会引发重绘</strong>，但重绘不一定会引发重排。</p><p><strong>触发重排的条件：任何页面布局和几何属性的改变都会触发重排，比如：</strong></p><p>1、页面渲染初始化；(无法避免)</p><p>2、添加或删除可见的DOM元素；</p><p>3、元素位置的改变，或者使用动画；</p><p>4、元素尺寸的改变——大小，外边距，边框；</p><p>5、浏览器窗口尺寸的变化(resize事件发生时)；</p><p>6、填充内容的改变，比如文本的改变或图片大小改变而引起的计算值宽度和高度的改变；</p><p>7、读取某些元素属性：(offsetLeft/Top/Height/Width,　clientTop/Left/Width/Height,　scrollTop/Left/Width/Height,　width/height,　getComputedStyle(),　currentStyle(IE))</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h3 id="浏览器自己的优化"><a href="#浏览器自己的优化" class="headerlink" title="浏览器自己的优化"></a>浏览器自己的优化</h3><p>浏览器会维护1个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会flush队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。</p><h3 id="注意的优化"><a href="#注意的优化" class="headerlink" title="注意的优化"></a>注意的优化</h3><p>减少重绘和重排，就是要减少对渲染树的操作，则我们可以合并多次的DOM和样式的修改。并减少对style样式的请求。</p><p>1、<strong>直接改变元素的className</strong></p><p>2、<strong>display:none</strong>，先设置元素为display:none；然后进行页面布局等操作；设置完成后将元素设置为display:block；这样的话就只引发两次重绘和重排；</p><p>3、使用cloneNode(true or false) 和 replaceChild 技术，引发一次回流和重绘；</p><p>4、<strong>将需要多次重排的元素，position属性设为absolute或fixed</strong>，元素脱离了文档流，它的变化不会影响到其他元素；</p><p>5、如果需要创建多个DOM节点，可以使用DocumentFragment<strong>创建完后一次性的加入document；</strong></p><h3 id="结合项目中使用"><a href="#结合项目中使用" class="headerlink" title="结合项目中使用"></a>结合项目中使用</h3><p>代码例子：不要边循环边渲染</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> li = <span class="built_in">document</span>.createElement(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">    li.innerHTML = <span class="string">&#x27;apple&#x27;</span>+i;</span><br><span class="line">    fragment.appendChild(li);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;fruit&#x27;</span>).appendChild(fragment);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重绘 </tag>
            
            <tag> 回流 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
