<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>浏览器常见的攻击手段</title>
      <link href="posts/21053/"/>
      <url>posts/21053/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览器常见的攻击手段"><a href="#浏览器常见的攻击手段" class="headerlink" title="浏览器常见的攻击手段"></a>浏览器常见的攻击手段</h1><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p><code>XSS</code> 全称是 <code>Cross Site Scripting</code>，为了与<code>CSS</code>区分开来，故简称 <code>XSS</code>，翻译过来就是“跨站脚本攻击”。XSS 攻击是指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。</p><p><code>XSS</code>的攻击目标是为了盗取存储在客户端的cookie或者其他网站用于识别客户端身份的敏感信息。一旦获取到合法用户的信息后，攻击者甚至可以假冒合法用户与网站进行交互。</p><h3 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h3><h4 id="存储型XSS攻击"><a href="#存储型XSS攻击" class="headerlink" title="存储型XSS攻击"></a>存储型XSS攻击</h4><p>主要出现在让用户输入数据，供其他浏览此页的用户进行查看的地方，包括留言、评论、博客日志和各类表单等。应用程序从数据库中查询数据，在页面中显示出来，攻击者在相关页面输入恶意的脚本数据后，用户浏览此类页面时就可能受到攻击。</p><p>比如说我写了一个网站，然后攻击者在上面发布了一个文章，内容是这样的 <code>&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code>，如果我没有对他的内容进行处理，直接存储到数据库，那么下一次当其他用户访问他的这篇文章的时候，服务器从数据库读取后然后响应给客户端，浏览器执行了这段脚本，就会将cookie展现出来，这就是典型的存储型XSS。</p><h4 id="反射型XSS攻击"><a href="#反射型XSS攻击" class="headerlink" title="反射型XSS攻击"></a>反射型XSS攻击</h4><p>主要做法是将脚本代码加入URL地址的请求参数里，请求参数进入程序后在页面直接输出，用户点击类似的恶意链接就可能受到攻击。</p><h3 id="预防XSS攻击"><a href="#预防XSS攻击" class="headerlink" title="预防XSS攻击"></a>预防XSS攻击</h3><p>1、将输入的数据进行转义处理</p><p>2、将用户所提供的内容进行过滤(如上面的<code>script</code>标签)</p><p>3、纯前端渲染</p><p>4、使用HTTP头指定类型<br><code>w.Header().Set(&quot;Content-Type&quot;,&quot;text/javascript&quot;)</code><br>这样就可以让浏览器解析javascript代码，而不会是html输出</p><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p><code>CSRF</code> 的全称是 Cross-site request forgery，翻译过来就是“跨站请求伪造”：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站 执行某项操作的目的。</p><h3 id="一个典型的CSRF攻击流程"><a href="#一个典型的CSRF攻击流程" class="headerlink" title="一个典型的CSRF攻击流程"></a>一个典型的CSRF攻击流程</h3><p>1、受害者登录 a.com ，并保留了登录凭证(Cookie)</p><p>2、攻击者引诱受害者访问了 b.com</p><p>3、b.com 向 a.com 发送了一个请求：a.com/act=xx，浏览器会默认携带a.com的Cookie</p><p>4、a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求 </p><p>5、a.com，以受害者的名义执行了act=xx </p><p>6、攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作</p><h3 id="预防CSRF"><a href="#预防CSRF" class="headerlink" title="预防CSRF"></a>预防CSRF</h3><p>CSRF通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对CSRF的防护能力来提升安全性。 </p><h4 id="一、阻止不明外域的访问"><a href="#一、阻止不明外域的访问" class="headerlink" title="一、阻止不明外域的访问"></a>一、阻止不明外域的访问</h4><h5 id="1、同源检测"><a href="#1、同源检测" class="headerlink" title="1、同源检测"></a>1、同源检测</h5><p>既然CSRF大多来自第三方网站，那么我们就直接禁止外域(或者不受信任的域名)对我们发起请求：</p><p>1、使用Origin Header确定来源域名：在部分与CSRF有关的请求中，请求的Header中会携带<code>Origin</code>字段,如果Origin存在，那么直接使用Origin中的字段确认来源域名就可以</p><p>2、使用Referer Header确定来源域名：根据HTTP协议，在HTTP头中有一个字段叫<code>Referer</code>，记录了该HTTP请求的来源地址</p><h5 id="2、Samesite-Cookie属性"><a href="#2、Samesite-Cookie属性" class="headerlink" title="2、Samesite Cookie属性"></a>2、Samesite Cookie属性</h5><p>Google起草了一份草案来改进HTTP协议，那就是为 <code>Set-Cookie</code> 响应头新增 <code>Samesite</code> 属性，它用来标明这个 Cookie是个“同站 Cookie”，同站Cookie只能作为第一方Cookie，不能作为第三方Cookie。</p><p>Samesite 有两个属性值：</p><p>Samesite=Strict: 这种称为严格模式，表明这个 Cookie 在任何情况下都不可能作为第三方 Cookie</p><p>Samesite=Lax: 这种称为宽松模式，比 Strict 放宽了点限制，假如这个请求是这种请求且同时是个GET请求，则这个 Cookie可以作为第三方Cookie</p><h4 id="二、提交时要求附加本域才能获取的信息"><a href="#二、提交时要求附加本域才能获取的信息" class="headerlink" title="二、提交时要求附加本域才能获取的信息"></a>二、提交时要求附加本域才能获取的信息</h4><h5 id="1、CSRF-Token"><a href="#1、CSRF-Token" class="headerlink" title="1、CSRF Token"></a>1、CSRF Token</h5><p>CSRF的另一个特征是攻击者无法直接窃取到用户的信息(Cookie，Header，网站内容等)，仅仅是冒用Cookie中的信息。</p><p>而CSRF攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户自己的请求。那么我们可以要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token。服务器通过校验请求是否携带正确的Token，来把正常的请求和攻击的请求区分开，从而防范CSRF的攻击。</p><p>CSRF Token的防护策略分为三个步骤：</p><ul><li><p>将CSRF Token输出到页面中 </p></li><li><p>页面提交的请求携带这个Token </p></li><li><p>服务器验证Token是否正确</p></li></ul><h5 id="2、双重Cookie验证"><a href="#2、双重Cookie验证" class="headerlink" title="2、双重Cookie验证"></a>2、双重Cookie验证</h5><p>在会话中存储CSRF Token比较繁琐，而且不能在通用的拦截上统一处理所有的接口。那么另一种防御措施是使用双重提交Cookie。利用CSRF攻击不能获取到用户Cookie的特点，我们可以要求Ajax和表单请求携带一个Cookie中的值</p><p>双重Cookie的流程如下：</p><ul><li><p>在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串</p></li><li><p>在前端向后端发起请求时，取出Cookie，并添加到URL的参数中</p></li><li><p>后端接口验证Cookie中的字段与URL参数中的字段是否一致，不一致则拒绝</p></li></ul><h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><p>攻击者成功的向服务器提交恶意的SQL查询代码，程序在接收后错误的将攻击者的输入作为查询语句的一部分执行，导致原始的查询逻辑被改变，额外的执行了攻击者精心构造的恶意代码。</p><p>例一：<code>&#39; OR &#39;1&#39;=&#39;1</code></p><p>这是最常见的 SQL注入攻击，当我们输如用户名 admin ，然后密码输如<code>&#39; OR &#39;1&#39;=1=&#39;1</code>的时候，我们在查询用户名和密码是否正确的时候，本来要执行的是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM user WHERE username=<span class="string">&#x27;&#x27;</span> and password=<span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>经过参数拼接后，会执行 SQL语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM user WHERE username=<span class="string">&#x27;&#x27;</span> and password=<span class="string">&#x27;&#x27;</span> OR <span class="string">&#x27;1&#x27;</span>=<span class="string">&#x27;1&#x27;</span></span><br></pre></td></tr></table></figure><p>这个时候1=1是成立，自然就跳过验证了。</p><p>例二：<code>&#39;;DROP TABLE user;--</code></p><p>这个时候SQL命令就被变成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM user WHERE username=<span class="string">&#x27;admin&#x27;</span> and password=<span class="string">&#x27;&#x27;</span>;drop table user;--<span class="string">&#x27; </span></span><br></pre></td></tr></table></figure><p>会直接将整个表给删除了。</p><h3 id="如何预防SQL注入"><a href="#如何预防SQL注入" class="headerlink" title="如何预防SQL注入"></a>如何预防SQL注入</h3><p>1、对进入数据库的特殊字符（<code>&#39;&quot;\尖括号&amp;*</code>等）进行转义处理，或编码转换</p><p>2、在应用发布之前建议使用专业的SQL注入检测工具进行检测，以及时修补被发现的SQL注入漏洞。</p><p>3、避免网站打印出SQL错误信息，比如类型错误、字段不匹配等，把代码里的SQL语句暴露出来，防止攻击者利用讴歌这些错误信息进行SQL注入。</p><h2 id="DDOS"><a href="#DDOS" class="headerlink" title="DDOS"></a>DDOS</h2><p><code>DDOS</code>：分布式拒绝服务攻击（Distributed Denial of Service），简单说就是发送大量请求使服务器瘫痪。DDOS攻击是在DOS攻击基础上的，可以通俗理解，DOS是单挑，而DDOS是群殴，因为现代技术的发展，DOS攻击的杀伤力降低，所以出现了DDOS，攻击者借助公共网络，将大数量的计算机设备联合起来，向一个或多个目标进行攻击。</p><h2 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h2><p><code>SYN</code>攻击指的是，攻击客户端通过三次握手向服务器发出请求，请求建立连接，然后服务器返回一个报文，表明请求以被接受，然后客户端也会返回一个报文，最后建立连接。那么如果有这么一种情况，攻击者伪造ip地址，发出报文给服务器请求连接，这个时候服务器接收到了，根据tcp三次握手的规则，服务器也要回应一个报文，可是这个ip是伪造的，报文回应给谁呢，第二次握手出现错误，第三次自然也就不能顺利进行了，这个时候服务器收不到第三次握手时客户端发出的报文，又再重复第二次握手的操作。如果攻击者伪造了大量的ip地址并发出请求，这个时候服务器将维护一个非常大的半连接等待列表，占用了大量的资源，最后服务器瘫痪。</p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XSS </tag>
            
            <tag> CSRF </tag>
            
            <tag> SQL注入 </tag>
            
            <tag> DDOS </tag>
            
            <tag> SYN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数的节流与防抖</title>
      <link href="posts/2443/"/>
      <url>posts/2443/</url>
      
        <content type="html"><![CDATA[<h1 id="函数的节流与防抖"><a href="#函数的节流与防抖" class="headerlink" title="函数的节流与防抖"></a>函数的节流与防抖</h1><h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><p>在前端开发的过程中，我们经常会需要绑定一些持续触发的事件，如 resize、scroll、mousemove 等等，但有些时候我们并不希望在事件持续触发的过程中那么频繁地去执行函数。</p><p>函数节流和函数防抖，两者都是优化高频率执行js代码的一种手段。</p><p><strong>函数节流</strong>是指一定时间内js方法只跑一次。比如人的眨眼睛，就是一定时间内眨一次。</p><p><strong>函数防抖</strong>是指频繁触发的情况下，只有足够的空闲时间，才执行代码一次。比如生活中的坐公交，就是一定时间内，如果有人陆续刷卡上车，司机就不会开车。只有别人没刷卡了，司机才开车。</p><h2 id="二、函数防抖"><a href="#二、函数防抖" class="headerlink" title="二、函数防抖"></a>二、函数防抖</h2><p>所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timer; <span class="comment">// 维护一个 timer</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> _this = <span class="built_in">this</span>; <span class="comment">// 取debounce执行作用域的this</span></span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        &#125;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            fn.apply(_this, args);</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>连续的时间，只需触发一次回调：</p><p>1、搜索框搜索输入，只需要再用户最后一次输入完，再发送请求</p><p>2、手机号或者邮箱验证</p><h2 id="三、函数节流"><a href="#三、函数节流" class="headerlink" title="三、函数节流"></a>三、函数节流</h2><p>所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。节流会稀释函数的执行频率。</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> run = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!run) &#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="comment">// 如果开关关闭了，那就直接不执行下边的代码</span></span><br><span class="line">      &#125;</span><br><span class="line">      run = <span class="literal">false</span> <span class="comment">// 持续触发的话，run一直是false，就会停在上边的判断那里</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        func.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">        run = <span class="literal">true</span> <span class="comment">// 定时器到时间之后，会把开关打开，我们的函数就会被执行</span></span><br><span class="line">      &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p>间隔一段时间执行一次回调：</p><p>1、滚动加载，加载更多或者是滚动到底部进行监听</p><p>2、高频的点击提交，表单重复提交</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 节流 </tag>
            
            <tag> 防抖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flex</title>
      <link href="posts/10238/"/>
      <url>posts/10238/</url>
      
        <content type="html"><![CDATA[<h1 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h1><p>flex是CSS中 的又一种布局手段，它主要用来代替浮动完成页面的布局。</p><p>flex可以使元素具有弹性，让元素可以跟随页面大小的改变而改变。</p><p>flex是一种弹性盒子的布局方式，抛弃原来的float布局方式，<code>float、clear、vertical-align</code>禁止使用。</p><h2 id="flex核心"><a href="#flex核心" class="headerlink" title="flex核心"></a>flex核心</h2><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>如果要使用弹性盒，必须先将一个元素设置为弹性容器。</p><ul><li>我们通过display来设置弹性容器</li><li><code>display:flex</code> 设置为块级弹性容器</li><li><code>display:inline-flex</code> 设置为行内的弹性容器</li></ul><h3 id="容器的轴线"><a href="#容器的轴线" class="headerlink" title="容器的轴线"></a>容器的轴线</h3><p>分横向和纵向，默认主轴线是横轴</p><h3 id="项目-弹性元素"><a href="#项目-弹性元素" class="headerlink" title="项目(弹性元素)"></a>项目(弹性元素)</h3><p>弹性容器的子元素就是弹性元素（弹性项）</p><p>弹性元素可以同时是弹性容器</p><p>项目在主轴方向上并不会超出盒子，而且项目按照容器的主轴线进行排列。</p><p>项目会自动转换为块元素。</p><p>项目如果没有设置高度，默认和容器的高度一致。</p><h2 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h2><h3 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h3><p><code>flex-direction</code>：指定容器中弹性元素的排列方式</p><ul><li><p><code>row</code>：默认值，弹性元素在容器中水平排列（左向右）主轴：自左向右</p></li><li><p><code>row-reverse</code>：弹性元素在容器中反向水平排列（右向左）主轴：自右向左</p></li><li><p><code>column</code>：弹性元素纵向排列（自上向下）</p></li><li><p><code>column-reverse</code>：反向纵向排列（自下向上）</p></li></ul><h3 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h3><p><code>flex-wrap</code>：设置弹性元素是否在弹性容器中自动换行</p><ul><li><p><code>nowwrap</code>：默认值，元素不会自动换行</p><p><img src="https://img2.jimu98.cn/haley/20201018164527.png" alt="image-20201018164526922"></p></li><li><p><code>wrap</code>：元素沿着辅轴方向自动换行(第一行在上方)</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201018164347522.png" alt="image-20201018164347522">)<code>reverse</code>：元素沿着辅轴的反方向换行(第一行在下方)</p><p><img src="https://img2.jimu98.cn/haley/20201018164438.png" alt="image-20201018164438357"></p></li></ul><h3 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h3><p><code>flex-flow</code>是<code>flex-wrap</code>和<code>flex-direction</code>的简写属性</p><p>例：flex-flow：row  wrap-reverse</p><h3 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h3><p><code>justify-content</code>：主轴上的元素的排列方式</p><ul><li><p><code>flex-start</code>（默认值）：左对齐</p></li><li><p><code>flex-end</code>：右对齐</p></li><li><p><code>center</code>： 居中</p></li><li><p><code>space-between</code>：两端对齐，项目之间的间隔都相等。</p></li><li><p><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</p></li><li><p><code>space-evenly</code>：空白部分分布到元素的单侧</p></li></ul><h3 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h3><p><code>align-items</code>：元素在副轴上对齐的对齐方式</p><ul><li><p><code>stretch</code> ：默认值，将元素的长度设置为相同的值</p></li><li><p><code>flex-start</code> ：元素不会拉伸，沿着辅轴的起边对齐</p></li><li><p><code>flex-end</code> ：沿着辅轴的终边对齐</p></li><li><p><code>center</code> ：居中对齐</p></li><li><p><code>baseline</code> ：基线对齐</p></li></ul><p>如果项目没有设置副轴方向上的大小默认和容器副轴的大小一致，设置了align-items项目的大小，就是项目本身的大小。</p><h3 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h3><p><code>align-content</code>：多轴线(换行)行在副轴上的对齐方式</p><ul><li><code>flex-start</code>：与交叉轴的起点对齐。</li><li><code>flex-end</code>：与交叉轴的终点对齐。</li><li><code>center</code>：与交叉轴的中点对齐。</li><li><code>space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布。</li><li><code>space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li><li><code>stretch</code>（默认值）：轴线占满整个交叉轴。</li></ul><h2 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h2><h3 id="order"><a href="#order" class="headerlink" title="order"></a>order</h3><p><code>order</code>： 决定弹性元素的排列顺序，值越小，排列越前，默认为0</p><h3 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h3><p><code>flex-grow</code>：定义弹性元素的放大比例。</p><ul><li>0：默认值，即有空余空间，也不放大。</li><li>1：占满容器的剩余空间，如果多个弹性元素都设置了，根据比例放大。</li><li>1以上：会按照比例分配剩余空间</li></ul><h3 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h3><p><code>flex-shrink</code>：定义弹性元素的缩小比例</p><ul><li>1：默认值，空间不足时，等比例收缩</li><li>0：不允许缩小</li><li>值越大，收缩的越多</li></ul><h3 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h3><p><code>flex-basis</code>：指定的是元素在主轴上的基础长度</p><ul><li><p>如果主轴是横向的，则该值指定的就是元素的宽度</p></li><li><p>如果主轴是纵向的，则该值指定的就是元素的高度</p></li><li><p>默认值是auto，表示参考元素自身的高度和宽度</p></li><li><p>如果传递了一个具体的数值，则以该值为准。</p></li></ul><h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><p><code>flex</code>属性是<code>flex-grow</code>、 <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code></p><h3 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h3><p><code>align-self</code>：用来覆盖当前弹性元素上的align-items，值和align-items一样，可以给单个的弹性元素指定样式。</p><p>注意：如果是移动端就可以用，如果是Pc端就要考虑兼容问题。</p>]]></content>
      
      
      <categories>
          
          <category> 布局 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flex </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js</title>
      <link href="posts/5063/"/>
      <url>posts/5063/</url>
      
        <content type="html"><![CDATA[<h1 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h1><h2 id="node简介"><a href="#node简介" class="headerlink" title="node简介"></a>node简介</h2><p>Node.js是一个基于Chrome V8引擎的JavaScript运行时。 </p><p>通过node，可以使js代码在服务器端执行。</p><p>Node仅仅对Es标准进行了实现，所以在Node中不包含DOM和BOM</p><ul><li>node中可以使用所有的内建对象(String Number Boolean Math Date RegExp Function object Array)。而BOM和DOM都不能使用，但是可以使用console，也可以使用定时器(setTimeout()、setInterval())</li></ul><p>Node可以在后台用来编写服务器。Node编写服务器都是单线程的服务器。</p><p>进程和线程</p><ul><li>进程就是—个一个的工作计划(工厂中的车间)</li><li>线程是计算机最小的运算单位(工厂中的工人)</li></ul><p>传统的服务器都是多线程的，每进来一个请求，就创建—个线程去处理请求。</p><p>node的请求是单线程的，node处理请求时是单线程，但是在后台拥有一个I/O线程池</p><h2 id="node-js的安装"><a href="#node-js的安装" class="headerlink" title="node.js的安装"></a>node.js的安装</h2><p>百度node，进入中文网直接下载安装包，直接进行安装不需要做任何的选择，一直下一步即可。任意位置打开命令行工具，输入 <code>node -v</code> 和 <code>npm -v</code> 查看 node 和 npm 的版本号，如果有就安装好了，如果命令出错尝试重启电脑再次执行。</p><p>npm：安装好node之后，npm就附带安装好了。它是node包管理工具(node package manager)</p><h2 id="node-模块使用"><a href="#node-模块使用" class="headerlink" title="node 模块使用"></a>node 模块使用</h2><ul><li>新建文件夹，将该文件夹初始化为 node(npm) 项目，执行 <code>npm init -y</code></li><li>新建 index.html 页面</li><li>安装 jquery 插件。执行 <code>npm install jquery</code></li><li>安装完毕之后，项目内多出两个文件<ul><li>node_modules 文件夹：存储下载的包的文件夹</li><li>package-lock.json 文件：该文件记录安装的包的详细信息</li></ul></li><li>在 html 中使用 jquery 可以按照之前的路径导入(不推荐)。现在我们使用 npm 下载模块。可以使用 node 模块的方式导入安装好的包。 使用 <code>require(包名)</code>，但是当做模块导入之后浏览器会报错。因为模块语法浏览器不支持，需要编译。我们可以使用webpack打包编译。</li><li>但是如果我们只是想运行js文件，则直接在命令行窗口执行<code>node js文件名</code>就可以看到我们导入文件的运行结果了。</li></ul><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><h3 id="1、模块分类"><a href="#1、模块分类" class="headerlink" title="1、模块分类"></a>1、模块分类</h3><p>核心模块：由node引擎提供的模块，核心模块的标识就是模块的名字。</p><p>文件模块：由用户自己创建的模块，文件模块的标识就是文件的路径(绝对路径，相对路径)。</p><h3 id="2、模块的定义"><a href="#2、模块的定义" class="headerlink" title="2、模块的定义"></a>2、模块的定义</h3><p>① 在node中，一个js文件就是一个模块</p><p>② 在Node中，每一个js文件中的js代码都是独立运行在一个函数中，而不是全局作用域，所以一个模块中的变量和函数在其他模块中无法访问。</p><p>③ 在node中有一个全局对象global，它的作用和网页中window类似</p><ul><li><p>在全局中创建的变量都会作为global的属性保存</p></li><li><p>在全局中创建的函数都会作为global的方法保存</p></li><li><p>实际上模块中的代码都是包装在一个函数中执行的，并且在函数执行时，同时传递进了5个实参。</p><ul><li>exports：该对象用来将变量或函数暴露到外部</li><li>require：函数，用来引入外部的模块</li><li>module：代表的是当前模块本身，exports就是module的属性，既可以使用exports导出，也可以使用module.exports导出</li><li>_filename：当前模块的完整路径</li><li>_dirname：当前模块所在文件夹的完整路径</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">exports</span>，<span class="built_in">require</span>，<span class="built_in">module</span>,_filename,_dirname</span>) </span>&#123;</span><br><span class="line"><span class="comment">//arguments.callee：这个属性保存的是当前执行的函数对象</span></span><br><span class="line"><span class="built_in">console</span>.log(argument.callee+<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="④-导出变量和函数"><a href="#④-导出变量和函数" class="headerlink" title="④ 导出变量和函数"></a>④ 导出变量和函数</h4><p>使用exports</p><ul><li>例子：exports.属性=属性值     exports.方法=函数</li></ul><p>使用module.exports</p><ul><li><p>例子：module.exports.属性=属性值     module.exports.方法=函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports.a=<span class="number">1008</span></span><br></pre></td></tr></table></figure></li><li><p>如果导出多个，就使用对象   module.exports={}</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1008</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">1000</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123; a，b&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3、模块的标识-模块的导入"><a href="#3、模块的标识-模块的导入" class="headerlink" title="3、模块的标识(模块的导入)"></a>3、模块的标识(模块的导入)</h3><p>模块的标识就是模块的名字或路径</p><p>node通过模块的标识来寻找模块的，通过require()函数来引入外部的模块</p><p>使用require引入模块以后，该函数会返回一个对象，这个对象代表的是引入的模块。</p><p>对于核心模块(npm中下载的模块)，直接使用模块的名字对其进行引入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> $= <span class="built_in">require</span>(<span class="string">&#x27;jquery&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span> ( <span class="string">&quot;express&quot;</span>)</span><br></pre></td></tr></table></figure><p>对于自定义的文件模块，需要通过文件的路径来对模块进行引入,，路径可以是绝对路径，如果是相对路径必须以./或../开头</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="built_in">require</span>(<span class="string">&#x27; ./about&#x27;</span>)</span><br><span class="line"><span class="comment">//x就是引入的模块</span></span><br></pre></td></tr></table></figure><h3 id="4、exports和module-exports的区别"><a href="#4、exports和module-exports的区别" class="headerlink" title="4、exports和module.exports的区别"></a>4、exports和module.exports的区别</h3><p>通过exports只能使用<code>.</code>的方式来向外暴露内部变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.xxx=xxx</span><br></pre></td></tr></table></figure><p>module.exports既可以通过<code>.</code>的形式，也可以直接赋值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports.xxx=xxx</span><br><span class="line"><span class="built_in">module</span>.exports=&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="npm简介"><a href="#npm简介" class="headerlink" title="npm简介"></a>npm简介</h2><p>NPM(Node Package Manager)</p><p>对于Node而言，NPM帮助其完成了第三方模块的发布、安装和依赖等。借助NPM，Node与第三方模块之间形成了很好的一个生态系统。</p><h3 id="npm的命令"><a href="#npm的命令" class="headerlink" title="npm的命令"></a>npm的命令</h3><p><code>npm -v</code> 查看npm的版本</p><p><code>npm version</code> 查看所有模块的版本</p><p><code>npm search 包名</code> 搜索包</p><p><code>npm remove / r 包名</code> 删除包</p><p><code>npm install</code> 下载当前项目所依赖的包</p><h4 id="npm的下载-三种方式"><a href="#npm的下载-三种方式" class="headerlink" title="npm的下载(三种方式)"></a>npm的下载(三种方式)</h4><p><code>npm i 包名 --save</code>   这种方式一般下载的是项目的必须依赖，记录到 package.json 内的 dependencies 字段内。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install jquery@2.3.4 --save</span><br><span class="line">npm i jquery -S</span><br><span class="line">npm i jquery</span><br></pre></td></tr></table></figure><p><code>npm i 包名 包名 --save-dev</code>   这种方式安装的是项目的非必须依赖(工具类)，记录到 package.json 内的 devDependencies 字段内</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack --save-dev</span><br><span class="line">npm i webpack -D</span><br></pre></td></tr></table></figure><p><code>npm i -g 包名</code>  全局安装包（全局安装的包一般都是一些工具）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g server</span><br></pre></td></tr></table></figure><h5 id="npm-下载包的好处"><a href="#npm-下载包的好处" class="headerlink" title="npm 下载包的好处"></a>npm 下载包的好处</h5><ul><li>可以使用模块导入</li><li>下载的包的信息全部记录在 package.json 内</li><li>同事之间相互传递项目的时候不需要传递 node_modules 文件夹，使用的时候只需要执行 <code>npm i</code> 命令会重新下载将所有的包。</li></ul><h4 id="npm的卸载"><a href="#npm的卸载" class="headerlink" title="npm的卸载"></a>npm的卸载</h4><p>卸载包使用 <code>npm uninstall 包名</code>，通过哪种方式安装的就怎样卸载</p><h3 id="npm-的一些小技巧"><a href="#npm-的一些小技巧" class="headerlink" title="npm 的一些小技巧"></a>npm 的一些小技巧</h3><p>直接在任意位置的命令行执行即可</p><ul><li><p>切换 npm 包的来源，默认的来源是外网服务器，速度比较慢</p></li><li><p>镜像：因为资源都在外国的网站，淘宝把他们都做了一份镜像，所以要修改npm的下载源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure></li><li><p>显示安装的进度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set loglevel&#x3D;http</span><br></pre></td></tr></table></figure></li></ul><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="Buffer-缓冲区"><a href="#Buffer-缓冲区" class="headerlink" title="Buffer(缓冲区)"></a>Buffer(缓冲区)</h3><p>Buffer的结构和数组很像，操作的方法也和数组类似。但是数组中不能存储二进制的文件，而buffer就是专门用来存储二进制数据的。</p><p>在buffer中存储的都是二进制数据，但是在显示时都是以16进制的形式显示。</p><p>buffer中每一个元素的范围是从00—ff (0-255)，如果要添加的值超过了范围，就会把输入的值转换为2进制，然后取后8位，转换为十进制输出。</p><p>Buffer的大小一旦确定，则不能修改，Buffer实际上是对底层内存的直接操作。</p><p>使用buffer不需要引入模块，直接使用即可。</p><p>buffer数据在控制台输出就一定是10进制，如果我们不希望输出10进制，可以使用tostring方法修改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buf2[<span class="number">2</span>].toString(<span class="number">16</span>)</span><br><span class="line"><span class="comment">//这样就修改成了16进制显示</span></span><br></pre></td></tr></table></figure><h4 id="buffer的几种创建方法"><a href="#buffer的几种创建方法" class="headerlink" title="buffer的几种创建方法"></a>buffer的几种创建方法</h4><p>1、将一个字符串转换为buffer</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">varstr=<span class="string">&quot;Hello 尚硅谷&quot;</span> </span><br><span class="line"><span class="keyword">var</span> buf = Buffer.from (str);</span><br><span class="line"><span class="built_in">console</span>.log (buf) ;</span><br><span class="line"><span class="comment">//一个英文字母占一个字节，一个汉字占三个字节</span></span><br><span class="line"><span class="built_in">console</span>.log(buf.length)<span class="comment">//占用内存的大小  15</span></span><br><span class="line"><span class="built_in">console</span>.log(str.length)<span class="comment">//字符串的长度    9</span></span><br></pre></td></tr></table></figure><p>2、创建一个指定大小的buffer</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个10个字节的buffer，数据是空的</span></span><br><span class="line"><span class="keyword">var</span> buf2 = Buffer.alloc(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>3、创建一个指定大小的buffer，但是buffer中可能含有敏感数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个10个字节的buffer，原来的数据还在</span></span><br><span class="line">sar buf3 = Buffer.allocUnsafe(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><h4 id="将缓冲区中的数据转换为字符串"><a href="#将缓冲区中的数据转换为字符串" class="headerlink" title="将缓冲区中的数据转换为字符串"></a>将缓冲区中的数据转换为字符串</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用toString方法</span></span><br><span class="line"><span class="keyword">var</span> buf4 = Buffer.from(<span class="string">&quot;我是一段文本数据&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log (buf4.tostring()) ;</span><br></pre></td></tr></table></figure><h3 id="fs"><a href="#fs" class="headerlink" title="fs"></a>fs</h3><p>文件系统(File system)：文件系统简单来说就是通过Node来操作系统中的文件。</p><p>使用文件系统，需要先引入fs模块，fs是核心模块，直接引入不需要下载</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br></pre></td></tr></table></figure><p>fs模块中所有的操作都有两种形式可供选择：同步和异步。</p><ul><li><p>同步文件系统会阻塞程序的执行，也就是除非操作完毕，否则不会向下执行代码。同步方法带sync。</p></li><li><p>异步文件系统不会阻塞程序的执行，而是在操作完成时，通过回调函数将结果返回。异步方法没有sync，但是都需要回调函数。</p></li></ul><h4 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h4><h5 id="同步文件的写入"><a href="#同步文件的写入" class="headerlink" title="同步文件的写入"></a>同步文件的写入</h5><p>1、打开文件：fs .opensync (path, flags [ , mode])</p><ul><li><p>path：文件的路径</p></li><li><p>flags：打开文件要做的操作的类型</p><ul><li>r：只读的</li><li>w：可写的</li></ul></li><li><p>mode设置文件的操作权限，—般不传</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs .openync(<span class="string">&quot;hello .txt&quot;</span> , <span class="string">&quot;w&quot;</span>);</span><br></pre></td></tr></table></figure><p>返回值：该方法会返回一个文件的描述符作为结果，我们可以通过该描述符来对文件进行各种操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fd = fs.opensync(<span class="string">&quot;hello .txt&quot;</span> , <span class="string">&quot;w&quot;</span>)</span><br><span class="line"><span class="comment">//返回一个文件的编号</span></span><br></pre></td></tr></table></figure><p>2、向文件中写入内容：fs.writesync (fd, string[ , position [ , encoding]])</p><ul><li>fd文件的描述符，需要传递写入文件的描述符</li><li>string要写入的内容</li><li>position写入的起始位置</li><li>encoding写入的编码，默认utf-8</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.writeync(fd , <span class="string">&quot;今天天气真不错～~~&quot;</span>);</span><br></pre></td></tr></table></figure><p>3、保存并关闭文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fs.closesync(fd)</span><br><span class="line"><span class="comment">//fd是要关闭文件的描述符</span></span><br></pre></td></tr></table></figure><h5 id="异步文件的写入"><a href="#异步文件的写入" class="headerlink" title="异步文件的写入"></a>异步文件的写入</h5><p>1、打开文件：fs.open(path, flags[ ,mode] ,callback)</p><p>异步调用的方法，结果都是通过回调函数的参数返回的</p><ul><li><p>回调函数两个参数:</p><ul><li><p>err错误对象，如果没有错误则为null</p></li><li><p>fd文件的描述符</p></li></ul></li></ul><p>2、向文件中写入内容：fs.write(fd,string[,position[ ,encoding]] , callback)</p><p>3、关闭文件：fs.close(fd, callback )</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开文件</span></span><br><span class="line">fs.open(<span class="string">&#x27;hello.tex&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,fd</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//判断是否出错</span></span><br><span class="line">    <span class="keyword">if</span>（！err)&#123;</span><br><span class="line">        <span class="comment">//如果没有出错，则对文件进行写入操作</span></span><br><span class="line">        fs.write(fd,<span class="string">&#x27;这是异步写入的内容&#x27;</span>，<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;写入成功&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//关闭文件</span></span><br><span class="line">            fs.close(fd,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">&#x27;文件已关闭&#x27;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="简单文件的写入"><a href="#简单文件的写入" class="headerlink" title="简单文件的写入"></a>简单文件的写入</h5><p>异步：fs.writeFile(file, data [ , options] , callback)</p><p>同步：fs.writeFilesync(file, data [ , options])</p><ul><li><p>file：要操作文件的路径</p></li><li><p>data：要写入的数据</p></li><li><p>options选项，可以对参数进行一些配置</p></li><li><p>callback：当写入完成以后执行的函数</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入fs模块</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line">fs.writeFile(<span class="string">&#x27;hello.txt&#x27;</span>,<span class="string">&#x27;这是通过writeFile写入的内容&#x27;</span>，<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;写入成功&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="流式文件的写入"><a href="#流式文件的写入" class="headerlink" title="流式文件的写入"></a>流式文件的写入</h5><p>同步、异步、简单文件的写入都不适合大文件的写入，性能较差，容易导致内存溢出。</p><p>1、创建一个可写流：fs.createwritestream(path [, options])</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = fs.createwritestream(<span class="string">&quot;hello.txt&quot;</span>);</span><br></pre></td></tr></table></figure><p>2、通过ws向文件中输出内容(可写入多次)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ws.write(<span class="string">&quot;通过可写流写入文件的内容&quot;</span>）;</span><br><span class="line">ws.write(<span class="string">&quot;通过可写流写入文件的内容&quot;</span>）;</span><br></pre></td></tr></table></figure><p>3、关闭流</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws.end();</span><br></pre></td></tr></table></figure><p><strong>可以通过监听流的open和close事件来监听流的打开和关闭。</strong></p><ul><li><p>on(事件字符串，回调函数)：可以为对象绑定—个事件。</p></li><li><p>once(事件字符串，回调函数)：可以为对象绑定一个一次性的事件，该事件将会在触发一次以后自动失效。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ws.once(<span class="string">&#x27;open&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;流打开了&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">ws.once(<span class="string">&#x27;close&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;流关闭了&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h4 id="文件的读取"><a href="#文件的读取" class="headerlink" title="文件的读取"></a>文件的读取</h4><h5 id="同步文件的读取"><a href="#同步文件的读取" class="headerlink" title="同步文件的读取"></a>同步文件的读取</h5><h5 id="异步文件的读取"><a href="#异步文件的读取" class="headerlink" title="异步文件的读取"></a>异步文件的读取</h5><h5 id="简单文件的读取"><a href="#简单文件的读取" class="headerlink" title="简单文件的读取"></a>简单文件的读取</h5><p>异步：fs.readFile(path [ , options] , callback)</p><p>同步：fs.readFilesync(path [ , options])</p><p>data读取到的数据，会返回一个buffer</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line">fs.readFile(<span class="string">&#x27;hello.txt&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="流式文件的读取"><a href="#流式文件的读取" class="headerlink" title="流式文件的读取"></a>流式文件的读取</h5><p>流式文件的读取也适用于一些比较大的文件，可以分多次将文件读取到内存中。</p><p>如果要读取一个可读流中的数据，必须要为可读流绑定一个data事件，data事件绑定完毕，它会自动开始读取数据</p><p>流式不会一次读取完，每次读取65536个字节。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="comment">//创建一个可读流</span></span><br><span class="line"><span class="keyword">var</span> rs = fs.createReadStream(<span class="string">&#x27;hello.txt&#x27;</span>);</span><br><span class="line">rs.on(<span class="string">&#x27;data&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//结果就在data里</span></span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>将读出的数据写入另一个文件的简单方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="comment">//创建一个可读流</span></span><br><span class="line"><span class="keyword">var</span> rs = fs.createReadStream(<span class="string">&#x27;hello.txt&#x27;</span>);</span><br><span class="line"><span class="comment">//创建一个可写流</span></span><br><span class="line"><span class="keyword">var</span> ws = fs.createWriteStream(<span class="string">&#x27;b.mp3&#x27;</span>);</span><br><span class="line"><span class="comment">//pipe()可以将可读流中的内容，直接输出到可写流中</span></span><br><span class="line">rs.pipe(ws)</span><br></pre></td></tr></table></figure><h4 id="fs中的其他方法"><a href="#fs中的其他方法" class="headerlink" title="fs中的其他方法"></a>fs中的其他方法</h4><p>1、检查一个文件是否存在</p><p>同步：<code>fs.existssync(path)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查是否存在a123.mp3</span></span><br><span class="line"><span class="keyword">var</span> isExists = fs.existssync(<span class="string">&quot;a123.mp3&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log (isExists);</span><br></pre></td></tr></table></figure><p>2、获取文件的信息</p><p>异步：<code>fs.stat(path,callback)</code>   </p><p>同步： <code>fs.statsync(path)</code></p><p>它会给我们返回一个对象，这个对象中保存了当前对象状态的相关信息</p><ul><li><p>这个对象的属性</p><ul><li><p>size：文件的大小</p></li><li><p>isFile()：是否是一个文件</p></li><li><p>isDirectory()：是否是一个文件夹</p></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs.stat(<span class="string">&#x27;a.mp3&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,stat</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(stat);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>3、删除文件：</p><p>异步：<code>fs.unlink(path,callback)</code>  </p><p>同步：   <code>fs.unlinkSync(path)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.unlinkSync ( <span class="string">&quot;hello.txt&quot;</span>);</span><br></pre></td></tr></table></figure><p>4、读取一个目录的目录结构：</p><p>异步：<code>fs.readdir(path[,options],callback)</code></p><p>同步：<code>fs.readdirSync(path[,options])</code></p><p>files是一个字符串数组，每一个元素就是一个文件夹或文件的名字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fs.readdir(<span class="string">&#x27;.&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,files</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(files);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>5、截断文件，将文件修改为指定的大小</p><p>异步：<code>fs.truncate(path,len,callback)</code></p><p>同步：<code>fs.truncateSync(path,len)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.truncateSync(<span class="string">&quot;hello.txt&quot;</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>6、创建一个目录</p><p>异步：<code>fs.mkdir(path[ ,mode],callback)</code></p><p>同步：<code>fs.mkdirSync(path[,mode])</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.mkdirSync(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure><p>7、删除一个目录</p><p>异步：<code>fs.rmdir(path, callback)</code></p><p>同步：<code>fs.rmdirSync(path)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.rmdirSync( <span class="string">&quot;hello.txt&quot;</span>);</span><br></pre></td></tr></table></figure><p>8、对文件进行重命名</p><p>异步：<code>fs.rename(oldPath,newPath,callback)</code></p><p>同步：<code>fs.renameSync(oldPath, newPath)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fs.rename(<span class="string">&#x27;a.mp3&#x27;</span>,<span class="string">&#x27;笔记。mp3&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;修改成功&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>也可以通过该方法实现剪切操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fs.rename(<span class="string">&#x27;笔记.txt&#x27;</span>,<span class="string">&#x27;c:\\Users\\Desktop\\笔记.mp3&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;修改成功&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>9、监视文件的修改</p><p><code>fs.watchFile(filename[,options],listener)</code></p><p>参数：</p><ul><li><p>filename：要监视的文件的名字</p></li><li><p>options：配置选项</p></li><li><p>listener：回调函数，当文件发生变化时，回调函数会执行</p><ul><li><p>在回调函数中会有两个参数:</p><ul><li><p>curr：当前文件的状态</p></li><li><p>prev：修改前文件的状态</p></li><li><p>这两个对象都是stats对象</p></li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fs.watchFile(<span class="string">&#x27;hello.txt&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;文件发生了变化&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;修改前文件大小&#x27;</span>：+prev.size);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;修改后文件大小&#x27;</span>：+curr.size);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 服务器端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="posts/25246/"/>
      <url>posts/25246/</url>
      
        <content type="html"><![CDATA[<h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><p>Git是目前世界上最先进的分布式版本控制系统。</p><h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p>需要使用命令行，安装 git即可。</p><p>git安装的时候不需要选择安装目录，一直下一步，直到出现很多复选框其中有两个是 <code>git bash here</code> 和 <code>git gui here</code> ，将后面的勾选掉(不勾选)，继续一直下一步即可。安装完毕之后在任意空白处点击鼠标右键就会出现 <code>git bash here</code> 命令。</p><h3 id="基本的shell命令"><a href="#基本的shell命令" class="headerlink" title="基本的shell命令"></a>基本的shell命令</h3><ul><li><code>cd</code>  改变目录</li><li><code>cd..</code>  回退到上一个目录，直接cd进入默认目录</li><li><code>pwd</code>  显示当前所在的目录路径</li><li><code>Is(ll)</code>  都是列出当前目录中的所有文件，只不过两个ll列出的内容更为详细<ul><li><code>ls -a</code>  查看当前目录下的所有内容，包括隐藏文件</li></ul></li><li><code>touch</code>  新建一个文件，如touch index.js就会在当前目录下新建一-个index.js文件。</li><li><code>rm</code>  删除一个文件，如rm index.js就会把index.js文件删除。</li><li><code>mkdir</code>  新建一个目录，就是新建一个文件夹。</li><li><code>rm-r</code>  删除一个文件夹  </li><li><code>rm-f</code>  强制删除</li><li><code>cp</code>  复制或重命名   <ul><li><code>-r</code>  可以复制文件夹</li></ul></li><li><code>mv</code>  移动文件， mv index.html test 就是把index.html移动到test文件夹下</li><li><code>cat</code>  查看文件里面的内容</li><li><code>clear</code>  清屏</li><li><code>history</code>  查看命令历史。</li><li><code>exit</code>  退出。</li></ul><h2 id="git的基本理论"><a href="#git的基本理论" class="headerlink" title="git的基本理论"></a>git的基本理论</h2><p>Git本地有三个工作区域：工作目录( Working Directory)、暂存区(Stage/Index)、资源库(Repository或Git Directory)；如果再加上远程的git仓库(Remote Directory)就可以分为四个工作区域。文件在这四个区域之间的转换关系如下：</p><p><img src="http://img8.jimu98.cn/20200720191119.png" alt=""></p><h2 id="git的基本配置"><a href="#git的基本配置" class="headerlink" title="git的基本配置"></a>git的基本配置</h2><p>命令：git config –global –list</p><p>可以查看自己的名字和邮箱，也可以通过该命令设置。如下图。</p><p><img src="http://img8.jimu98.cn/20200721223351.png" alt="image-20200721223351587"></p><h2 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h2><ul><li><code>git config -l</code>  查看配置</li><li><code>git --version</code> 查看 git 版本号,有时候可以简写成 <code>-v</code></li><li><code>git log</code> 查看本地版本</li><li><code>git status</code> 查看当前仓库的状态</li><li><code>git init</code> 将本地项目变成仓库</li><li><code>git clone 仓库地址</code> 克隆仓库到本地</li><li><code>git add .</code>添加所有文件到暂存区  <code>.</code> 代表所有的修改，也可以换成文件名</li><li><code>git commit -m&#39;留言&#39;</code>  提交暂存区中的内容到本地仓库，-m提交信息</li><li><code>git push</code> 将做好的版本提交到远端</li><li><code>git pull</code> 将远端的更新拉取到本地</li><li><code>git branch 分支名称</code> 创建新分支</li><li><code>git branch</code> 查看分支</li><li><code>git checkout 分支名称</code> 切换分支</li><li><code>git merge 分支名称</code> 当前分支合并分支其他分支</li><li><code>git pull origin master</code> 拉取主分支上的更新</li><li><code>git checkout -b 分支名称</code> 创建新的分支并切换过去</li></ul><h2 id="创建远程仓库的方式"><a href="#创建远程仓库的方式" class="headerlink" title="创建远程仓库的方式"></a>创建远程仓库的方式</h2><h3 id="1、创建全新的仓库：git-init-初始化"><a href="#1、创建全新的仓库：git-init-初始化" class="headerlink" title="1、创建全新的仓库：git init 初始化"></a>1、创建全新的仓库：git init 初始化</h3><ul><li><p>网上传建一个项目同名(你的项目文件夹是什么名字，仓库名与之相同)的空仓库(创建的时候不添加 reademe 文件)</p></li><li><p>在你的本地项目文件夹内打开命令行工具</p></li><li><p>将自己本地的项目初始化成 git 仓库，执行 <code>git init</code> 命令</p></li><li><p>在本地的项目里，创建一个README.MD文件，执行 <code>add .</code> 和 <code>git commit -m &#39;留言&#39;</code>命令</p></li><li><p>去网上的空仓库复制代码，第一个提示框的最后两行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/Haley-JJ/first_demo.git</span><br><span class="line">这行命令的作用是给本地的仓库添加一个远端地址， 名称是origin， 地址是后面的地址</span><br><span class="line">git push -u origin master</span><br><span class="line">这行命令的作用是将版本上传到已经添加的远端origin</span><br></pre></td></tr></table></figure></li><li><p>执行完毕之后上传成功，想要修改的话，直接在本地仓库修改，然后执行上传三部曲即可</p></li></ul><h3 id="2、克隆远程仓库：git-clone-地址"><a href="#2、克隆远程仓库：git-clone-地址" class="headerlink" title="2、克隆远程仓库：git clone+地址"></a>2、克隆远程仓库：git clone+地址</h3><ul><li><p>先将网上的仓库下载到本地，需要使用命令 <code>git clone 仓库地址</code></p></li><li><p>将想要托管的项目放到该仓库内，仓库内不必要的东西删除</p></li><li><p>将本地和网上关联起来(将自己本地的修改上传)</p><ul><li><p>将自己对仓库的所有修改添加到 github 远端记录，执行 <code>git add .</code></p></li><li><p>将记录好的修改做成版本，执行命令 <code>git commit -m&#39;留言&#39;</code></p><ul><li><p>如果是第一次和 github 关联的话，会失败，然后会提示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">please tell me who you are ?</span><br><span class="line">让你依次分别执行以下命令</span><br><span class="line">git config --global user.name &quot;yourname&quot;</span><br><span class="line">git config --global user.email &quot;youremail&quot;</span><br></pre></td></tr></table></figure></li><li><p>告诉他之后再次执行 <code>git commit -m&#39;留言&#39;</code></p></li></ul></li><li><p>将新的版本上传，执行命名 <code>git push</code></p><ul><li><p>由于是第一次和网上关联，会失败提示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">让你执行</span><br><span class="line">git push -u origin master</span><br><span class="line">执行完毕之后就成功了</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>上传成功之后，想要修改的话，直接在本地仓库修改，然后执行上传三部曲即可</p></li></ul><h2 id="git-的基本操作"><a href="#git-的基本操作" class="headerlink" title="git 的基本操作"></a>git 的基本操作</h2><h3 id="多个人或者多台电脑对同一仓库的同一分支进行操作"><a href="#多个人或者多台电脑对同一仓库的同一分支进行操作" class="headerlink" title="多个人或者多台电脑对同一仓库的同一分支进行操作"></a>多个人或者多台电脑对同一仓库的同一分支进行操作</h3><p>如果远端存在本地不存在的版本时，本地需要向仓库里上传并执行 git 上传三部曲时，执行到<code>git push</code>命令就会提示失败。可以使用<code>git pull</code>命令</p><p>当执行 <code>git pull</code> 将远端的版本拉取到本地，但是本地已经存在了一个提交的版本</p><ul><li><p>当这两个版本不冲突的时候(不是同一个文件，或者是同一个文件的不同位置)</p><ul><li>git 会自动合并两个版本，并弹出新的命令面板让你提交合并的版本留言，可以直接按住shift +z+z，退出留言面板。</li><li>再次执行 git push，上传更新</li></ul></li><li><p>当这两个版本冲突的时候(修改的是同一个文件的同一个位置)</p><ul><li>git 并不会自动合并，而是将冲突体现在当前的文件内，需要用户自己选择保留哪个更改，选择完毕之后，使用 git 上传三步提交即可。</li></ul></li></ul><h3 id="github-的分支操作"><a href="#github-的分支操作" class="headerlink" title="github 的分支操作"></a>github 的分支操作</h3><p>一个仓库内默认只有一个分支 master，通常称为主分支(用来存放合并后的代码)。可以多个分支。</p><p>一般工作流程是先在主分支将项目的主体框架搭建完毕，然后创建多个分支，每个分支代表不同的功能，不同的程序猿分别在不同分支内进行开发，开发完毕后将代码合并到主分支上。</p><ul><li>创建一个仓库(有README.md文件)，然后克隆到本地，添加公共的内容，然后上传。</li><li>创建新的分支，使用 <code>git branch 分支名称</code>命令。分支创建的时候里面的内容和主分支是一模一样的。</li><li>需要将创建好的分支上传到网上，可能直接使用 <code>git push</code> 命令，但是由于网上并没有新分支，所以需要使用 <code>git push --set-upstream origin yourbranch</code> 上传。此时本地和网上仓库完全同步了。</li><li>主分支分别合并分支的内容，然后上传。需要使用 <code>git merge 分支名称</code> 命令合并分支。合并之后再次使用<code>git push</code>命令上传。</li></ul><p><strong>注意</strong>：如果存在多个分支，会弹出新的命令面板让你提交合并之后的版本留言，可以直接按住shift +z+z，退出留言面板，再次上传。</p><h3 id="github-的特殊分支：gh-pages"><a href="#github-的特殊分支：gh-pages" class="headerlink" title="github 的特殊分支：gh-pages"></a>github 的特殊分支：gh-pages</h3><p>mater 分支内已经存放好了其他分支做好的项目，github 仓库有一个特殊的分支叫 gh-pages，该分支下的内容会被自动托管到github 免费服务器上，也就是说只要该分支下有 index.html 就可以直接使用网址访问。只需要直接创建 gh-pages 分支，并上传到网上即可。</p><h2 id="使用-ssh-key-公钥"><a href="#使用-ssh-key-公钥" class="headerlink" title="使用 ssh-key 公钥"></a>使用 ssh-key 公钥</h2><p>将自己电脑的当前系统和 github 关联，当用户在上传或下载仓库的时候使用 ssh 方式，可以实现用户的免密码登录。</p><h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><ul><li><p>打开命令行工具 输入 <code>cd ~</code> 命令</p></li><li><p>执行 <code>ssh-keygen</code> 命令，生成电脑上的公钥和私钥，一直回车直到出现密码图即可。</p></li><li><p>找到生成的公钥和私钥，位置在 <code>~/.ssh/</code> 文件夹下，使用 cat 命令(<code>cat .ssh/id_rsa.pub</code>)打印出公钥内容并复制</p><ul><li>如果生成的秘钥名称不是<strong>id_rsa.pub</strong>，就需要进行如下操作<ul><li>执行 <code>cd .ssh</code>，再执行 <code>ls -a</code> 查看自己的秘钥名称</li><li>使用 <code>cat 你的公钥名称</code> ，复制打印出的公钥内容</li></ul></li></ul></li><li><p>打开 github 网站，点击头像的下箭头选择 setting，找到 ssh key 新增一个即可。</p></li><li><p>验证 ssh 是否生效的话，需要重新从网上下载(选择 ssh 方式下载)仓库到本地，再次上传更新的时候，如果不需要输入用户名和密码，那就是生效了。</p></li></ul><h4 id="如果觉得太多的命令不容易操作的话，我们就可以使用另一种简单的方法"><a href="#如果觉得太多的命令不容易操作的话，我们就可以使用另一种简单的方法" class="headerlink" title="如果觉得太多的命令不容易操作的话，我们就可以使用另一种简单的方法"></a>如果觉得太多的命令不容易操作的话，我们就可以使用另一种简单的方法</h4><ul><li><p>进入C:\users\Administrator.ssh目录</p></li><li><p>生成公钥：<code>ssh-keygen -t rsa</code> rsa加密</p></li><li><p>找到生成的公钥文件<strong>id_rsa.pub</strong>，去网站粘贴生成的加密文件</p></li></ul><h2 id="仓库根目录下的-gitignore-文件"><a href="#仓库根目录下的-gitignore-文件" class="headerlink" title="仓库根目录下的 .gitignore 文件"></a>仓库根目录下的 .gitignore 文件</h2><p>gitignore文件是一个隐藏文件，该文件的作用是当你将一些文件或文件夹的名称写在 .gitignore 内的话，该仓库执行上传操作的时候，会忽略 .gitignore 内添加的文件或文件夹。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>仓库不能嵌套仓库</li></ul><h2 id="类似-github-网站的其他工具"><a href="#类似-github-网站的其他工具" class="headerlink" title="类似 github 网站的其他工具"></a>类似 github 网站的其他工具</h2><ul><li>腾讯云开发者平台(coding)：是一个和 github 类似的网站，服务器是国内的，所以操作起来速度很快。</li><li>码云：一般需要从github上下载项目，可以通过码云来下载。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Git </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数内的this指向</title>
      <link href="posts/22291/"/>
      <url>posts/22291/</url>
      
        <content type="html"><![CDATA[<h1 id="普通函数和箭头函数的this指向"><a href="#普通函数和箭头函数的this指向" class="headerlink" title="普通函数和箭头函数的this指向"></a>普通函数和箭头函数的this指向</h1><h2 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h2><p>普通函数中的this总是代表它的直接调用者，在默认情况下，this指向的是window。</p><p><strong>a.如果是一般函数，this指向全局对象window</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);   <span class="comment">//window</span></span><br><span class="line">&#125;</span><br><span class="line">fun(); <span class="comment">//相当于window.fun()</span></span><br></pre></td></tr></table></figure><p><strong>b.对象的方法里调用，this指向调用该方法的对象</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// obj</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.fn();</span><br></pre></td></tr></table></figure><p><strong>c.构造函数里的this，指向创建出来的实例</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age, name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)  <span class="comment">// 此处 this 分别指向 Person 的实例对象 p1 p2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="number">20</span>, <span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="number">18</span>, <span class="string">&#x27;李四&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>d. 事件中的this，绑定事件的元素</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&#x27;button&#x27;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);   <span class="comment">//button</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>箭头函数是ES6新增的，通俗的讲，箭头函数没有自己的this，它的this是继承而来；它指向的是外层的this，如果外层仍为箭头函数，则再指向外层，也就是说箭头函数的this指向箭头函数外面第一个不是箭头函数的那个函数的this。</p><p>看下面这段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj=&#123;</span><br><span class="line">    num:<span class="number">10</span>;</span><br><span class="line">    fun:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);  <span class="comment">//obj</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">//window</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.fun();</span><br></pre></td></tr></table></figure><p>第一个this指向obj对象，而setTimeout里面的匿名函数没有直接调用者，this指向window.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj=&#123;</span><br><span class="line">    num:<span class="number">10</span>;</span><br><span class="line">    fun:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);  <span class="comment">//obj</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">//obj</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.fun();</span><br></pre></td></tr></table></figure><p>而如果将setTimeout里面的普通函数，改成箭头函数，里面的this指向就会指向它外层的this。就是obj对象。</p><p>需要注意的是：<code>call、apply、bind</code>等方法也不能改变箭头函数this的指向。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> this指向 </tag>
            
            <tag> 箭头函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6学习笔记</title>
      <link href="posts/38921/"/>
      <url>posts/38921/</url>
      
        <content type="html"><![CDATA[<h1 id="ES6学习笔记"><a href="#ES6学习笔记" class="headerlink" title="ES6学习笔记"></a>ES6学习笔记</h1><h2 id="const-和-let命令"><a href="#const-和-let命令" class="headerlink" title="const 和 let命令"></a>const 和 let命令</h2><p>const ：声明常量(不可修改的，例如 π)，常量的名称都是全大写的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pI = <span class="number">3.14</span></span><br><span class="line">PI++</span><br><span class="line"><span class="built_in">console</span>.log(PI)</span><br><span class="line"><span class="comment">//会报错</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：const 对于数组和对象的元素修改，不算做对常量的修改，不会报错，因为地址没变。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;吕布&#x27;</span>,</span><br><span class="line">  age: <span class="number">28</span>,</span><br><span class="line">&#125;</span><br><span class="line">obj.level = <span class="number">15</span></span><br><span class="line"><span class="comment">//不会报错</span></span><br></pre></td></tr></table></figure><p>let：声明的变量是可以被修改的</p><h3 id="let-、const-和-var-的不同"><a href="#let-、const-和-var-的不同" class="headerlink" title="let 、const 和 var 的不同"></a>let 、const 和 var 的不同</h3><ul><li><p>不能重复声明</p></li><li><p>没有声明提升</p></li><li><p>存在块级作用域(作用域被定义在 {} 内)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; <span class="number">10</span>; index++) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(index)</span><br><span class="line"><span class="comment">//会报错</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h2><p>ES6允许按照一定模式从数组和对象中提取值，对变量进行赋值，这被称为解构赋值。</p><h3 id="1、对象解构赋值"><a href="#1、对象解构赋值" class="headerlink" title="1、对象解构赋值"></a>1、对象解构赋值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  username: <span class="string">&#x27;貂蝉&#x27;</span>,</span><br><span class="line">  userage: <span class="number">18</span>,</span><br><span class="line">  level: <span class="number">10</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123; username, <span class="attr">userage</span>: age &#125; = obj</span><br><span class="line"><span class="built_in">console</span>.log(username, age)</span><br><span class="line"><span class="comment">//貂蝉 18</span></span><br></pre></td></tr></table></figure><h3 id="2、数组的解构赋值"><a href="#2、数组的解构赋值" class="headerlink" title="2、数组的解构赋值"></a>2、数组的解构赋值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> [a, b, c] = arr</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c)</span><br><span class="line"><span class="comment">// 1,2,3</span></span><br></pre></td></tr></table></figure><h3 id="3、函数参数的解构赋值"><a href="#3、函数参数的解构赋值" class="headerlink" title="3、函数参数的解构赋值"></a>3、函数参数的解构赋值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  username: <span class="string">&#x27;貂蝉&#x27;</span>,</span><br><span class="line">  userage: <span class="number">18</span>,</span><br><span class="line">  level: <span class="number">10</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showInfo</span>(<span class="params">&#123; username, level &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// const &#123; username, level &#125; = obj</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`该英雄的名称是<span class="subst">$&#123;username&#125;</span>`</span>, <span class="string">`等级<span class="subst">$&#123;level&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">showInfo(obj)</span><br><span class="line"><span class="comment">//该英雄的名称是貂蝉, 等级10</span></span><br></pre></td></tr></table></figure><h3 id="4、技巧-交换变量的值"><a href="#4、技巧-交换变量的值" class="headerlink" title="4、技巧: 交换变量的值"></a>4、技巧: 交换变量的值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line">[x, y] = [y, x];</span><br><span class="line"><span class="built_in">console</span>.log(x, y);</span><br><span class="line"><span class="comment">// 2 1</span></span><br></pre></td></tr></table></figure><h2 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h2><h3 id="模版字符串"><a href="#模版字符串" class="headerlink" title="模版字符串"></a>模版字符串</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> username = <span class="string">&#x27;lucy&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`my name is <span class="subst">$&#123;username&#125;</span>`</span>)</span><br></pre></td></tr></table></figure><h3 id="新增的字符串方法"><a href="#新增的字符串方法" class="headerlink" title="新增的字符串方法"></a>新增的字符串方法</h3><ul><li><p>includes()：返回布尔值，表示是否找到了参数字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Hello world!&#x27;</span>;</span><br><span class="line">s.includes(<span class="string">&#x27;o&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Hello world!&#x27;</span>;</span><br><span class="line">s.startsWith(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Hello world!&#x27;</span>;</span><br><span class="line">s.endsWith(<span class="string">&#x27;!&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>trimStart()：消除字符串头部的空格，返回的是新字符串，不会修改原始字符串。</p></li><li><p>trimEnd()：消除尾部的空格，返回的是新字符串，不会修改原始字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="string">&#x27;  abc  &#x27;</span>;</span><br><span class="line">s.trim() <span class="comment">// &quot;abc&quot;</span></span><br><span class="line">s.trimStart() <span class="comment">// &quot;abc  &quot;</span></span><br><span class="line">s.trimEnd() <span class="comment">// &quot;  abc&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>padStart()：用于头部补全</p></li><li><p>padEnd()：用于尾部补全</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;x&#x27;</span>.padStart(<span class="number">5</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;ababx&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.padStart(<span class="number">4</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;abax&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.padEnd(<span class="number">5</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;xabab&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.padEnd(<span class="number">4</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;xaba&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>matchAll()：返回一个正则表达式在当前字符串的所有匹配，相当于match()加了全局匹配。</p></li></ul><h2 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h2><p>ES6允许给函数参数赋值：初始值</p><h3 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h3><h4 id="普通方式：参数非对象"><a href="#普通方式：参数非对象" class="headerlink" title="普通方式：参数非对象"></a>普通方式：参数非对象</h4><p>如果该参数具有默认值并且没有为它传递实参，那么它的位置要在最后，否则的话会报错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fun = <span class="function"><span class="keyword">function</span> (<span class="params">color = <span class="string">&#x27;黑色&#x27;</span>, bgColor = <span class="string">&#x27;红色&#x27;</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;颜色:::&#x27;</span>, color)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;背景色:::&#x27;</span>, bgColor)</span><br><span class="line">&#125;</span><br><span class="line">fun(<span class="string">&#x27;蓝色&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="参数为对象"><a href="#参数为对象" class="headerlink" title="参数为对象"></a>参数为对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fun = <span class="function"><span class="keyword">function</span> (<span class="params">&#123; color = <span class="string">&#x27;黑色&#x27;</span>, bgColor = <span class="string">&#x27;蓝色&#x27;</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;颜色:::&#x27;</span>, color)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;背景色:::&#x27;</span>, bgColor)</span><br><span class="line">&#125;</span><br><span class="line">fun(&#123; <span class="attr">color</span>: <span class="string">&#x27;粉色&#x27;</span> &#125;)</span><br><span class="line"><span class="comment">// 不能什么都不传，最起码传递一个空对象</span></span><br></pre></td></tr></table></figure><h2 id="rest参数-剩余"><a href="#rest参数-剩余" class="headerlink" title="rest参数(剩余)"></a>rest参数(剩余)</h2><p>ES6引入rest参数，用于获取函数的实参，用来代替arguments</p><h3 id="ES5引入实参的方式"><a href="#ES5引入实参的方式" class="headerlink" title="ES5引入实参的方式"></a>ES5引入实参的方式</h3><ul><li>arguments是一个类数组，实际上是一个对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">date</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">date(<span class="string">&#x27;白芷&#x27;</span>，<span class="string">&#x27;阿娇&#x27;</span>，<span class="string">&#x27;思慧&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="ES6的rest参数"><a href="#ES6的rest参数" class="headerlink" title="ES6的rest参数"></a>ES6的rest参数</h3><ul><li>rest是一个数组，我们可以使用数组的方法进行操作</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...rest</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(rest)</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：如果有多个参数时，rest参数必须要放到参数的最后</p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>ES6允许使用箭头(=&gt;)定义函数。</p><h3 id="普通函数的写法"><a href="#普通函数的写法" class="headerlink" title="普通函数的写法"></a>普通函数的写法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> res = add(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br><span class="line"><span class="comment">//30</span></span><br></pre></td></tr></table></figure><h3 id="箭头函数的写法"><a href="#箭头函数的写法" class="headerlink" title="箭头函数的写法"></a>箭头函数的写法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> res = add(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br><span class="line"><span class="comment">//30</span></span><br></pre></td></tr></table></figure><h3 id="箭头函数的简写"><a href="#箭头函数的简写" class="headerlink" title="箭头函数的简写"></a>箭头函数的简写</h3><p>1、箭头左边是函数的参数部分，使用小括号包裹参数、逗号拼接，当形参有且只有一个的时候，可以省略小括号。</p><p>2、箭头右边是函数主体，使用花括号包裹，当代码体只有一条语句的时候，此时return必须省略，而且语句的执行结果就是函数的返回值时，此时可以省略花括号</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2</span><br><span class="line"><span class="keyword">const</span> res = add(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br><span class="line"><span class="comment">//30</span></span><br></pre></td></tr></table></figure><h3 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="headerlink" title="箭头函数和普通函数的区别"></a>箭头函数和普通函数的区别</h3><ul><li><p>箭头函数定义只能使用变量式定义</p></li><li><p>函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</p></li><li><p>不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误。</p></li><li><p>不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用<code>rest</code>参数代替。</p></li><li><p>不可以使用 yield 命令，因此箭头函数不能用作Generator函数。</p></li></ul><h2 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h2><h3 id="1、Array-from"><a href="#1、Array-from" class="headerlink" title="1、Array.from()"></a>1、Array.from()</h3><p><code>Array.from()</code>  将类数组转化为数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fun1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(<span class="built_in">arguments</span>))</span><br><span class="line">&#125;</span><br><span class="line">fun1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure><h3 id="2、Array-of"><a href="#2、Array-of" class="headerlink" title="2、Array.of"></a>2、Array.of</h3><p><code>Array.of</code>   用于将一组值，转换为数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3,11,8]</span></span><br></pre></td></tr></table></figure><h3 id="3、find-和-findIndex"><a href="#3、find-和-findIndex" class="headerlink" title="3、find() 和 findIndex()"></a>3、find() 和 findIndex()</h3><p><code>find</code>   用于找出第一个符合条件的数组成员。</p><p><code>findIndex</code>  返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].find(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;) <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].findIndex(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="4、entries-、keys-和-values"><a href="#4、entries-、keys-和-values" class="headerlink" title="4、entries()、keys() 和 values()"></a>4、entries()、keys() 和 values()</h3><p><code>entries()</code>，<code>keys()</code>和<code>values()</code>用于遍历数组，可以用<code>for...of</code>循环进行遍历。</p><p><code>keys()</code>是对键名的遍历</p><p><code>values()</code>是对键值的遍历</p><p><code>entries()</code>是对键值对的遍历</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 &quot;a&quot;</span></span><br><span class="line"><span class="comment">// 1 &quot;b&quot;</span></span><br></pre></td></tr></table></figure><h3 id="5、flat-和-flatMap"><a href="#5、flat-和-flatMap" class="headerlink" title="5、flat() 和 flatMap()"></a>5、flat() 和 flatMap()</h3><p><code>flat()</code>  用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]].flat()</span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p><code>flat()</code>默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将<code>flat()</code>方法的参数写成一个整数，表示想要拉平的层数，默认为1。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].flat()</span><br><span class="line"><span class="comment">// [1, 2, 3, [4, 5]]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].flat(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><p><code>flatMap()</code>  对原数组的每个成员执行一个函数（相当于执行<code>map()</code>），然后对返回值组成的数组执行<code>flat()</code>方法。该方法返回一个新数组，不改变原数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相当于 [[2, 4], [3, 6], [4, 8]].flat()</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].flatMap(<span class="function">(<span class="params">x</span>) =&gt;</span> [x, x * <span class="number">2</span>])</span><br><span class="line"><span class="comment">// [2, 4, 3, 6, 4, 8]</span></span><br></pre></td></tr></table></figure><h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><p>[…]：扩展运算符能够将数组转换为逗号分隔的参数序列</p><h3 id="扩展运算符的应用"><a href="#扩展运算符的应用" class="headerlink" title="扩展运算符的应用"></a>扩展运算符的应用</h3><h4 id="对象的拷贝或者数组的拷贝-浅拷贝，无法拷贝原型内的方法"><a href="#对象的拷贝或者数组的拷贝-浅拷贝，无法拷贝原型内的方法" class="headerlink" title="对象的拷贝或者数组的拷贝(浅拷贝，无法拷贝原型内的方法)"></a>对象的拷贝或者数组的拷贝(浅拷贝，无法拷贝原型内的方法)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;庄周&#x27;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj1 = &#123; ...obj &#125;</span><br><span class="line">obj1.hobby = <span class="string">&#x27;浪&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj, obj1)</span><br><span class="line"><span class="comment">//&#123;name: &quot;庄周&quot;, age: 18&#125; &#123;name: &quot;庄周&quot;, age: 18, hobby: &quot;浪&quot;&#125;</span></span><br></pre></td></tr></table></figure><h4 id="将伪数组转为真正的数组"><a href="#将伪数组转为真正的数组" class="headerlink" title="将伪数组转为真正的数组"></a>将伪数组转为真正的数组</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> arr1 = [...arr]</span><br><span class="line">arr1.push(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr, arr1)</span><br><span class="line"><span class="comment">// [1, 2, 3] [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><h4 id="数组的合并"><a href="#数组的合并" class="headerlink" title="数组的合并"></a>数组的合并</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> kuaizi =[王太利<span class="string">&#x27;，&#x27;</span>肖央<span class="string">&#x27;];</span></span><br><span class="line"><span class="string">const fenghuang =[曾毅&#x27;</span>，<span class="string">&#x27;玲花&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> zuixuanxiaopingguo = [...kuaizi， ...fenghuang];</span><br><span class="line"><span class="built_in">console</span>.log(zuixuanxiaopingguo);</span><br><span class="line"><span class="comment">//&#x27;王太利&quot;，&#x27;肖央&#x27;，‘曾毅&quot;，&#x27;玲花</span></span><br></pre></td></tr></table></figure><h2 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h2><h3 id="对象的简洁表示法"><a href="#对象的简洁表示法" class="headerlink" title="对象的简洁表示法"></a>对象的简洁表示法</h3><p>当对象的属性名和作为该属性的属性值的变量名相同时，我们就可以使用对象的简洁表示法</p><p>函数可以省略function，但只有普通函数可以省略</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> username = <span class="string">&#x27;哈哈&#x27;</span></span><br><span class="line"><span class="keyword">const</span> userage = <span class="number">20</span></span><br><span class="line"><span class="keyword">const</span> sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;this.username&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  username,</span><br><span class="line">  userage,</span><br><span class="line">  sayName,</span><br><span class="line">  <span class="function"><span class="title">say</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br></pre></td></tr></table></figure><h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>第七种数据类型，生成独一无二的数据</p><h3 id="创建Symbol"><a href="#创建Symbol" class="headerlink" title="创建Symbol"></a>创建Symbol</h3><p>1、let s = Symbol()</p><p>2、let s2 = Symbol(‘aa’)</p><ul><li>aa仅仅是标志，没有实际意义，通过这种方法创建两个一模一样的，===判断时是false</li></ul><p>3、let s3 = Symbol.for(‘aa’)</p><ul><li>通过这种方式创建的两个一模一样的，===判断是true</li></ul><h2 id="set-数据结构"><a href="#set-数据结构" class="headerlink" title="set 数据结构"></a>set 数据结构</h2><p>类似于数组，但是不能存在重复的值</p><p>Set本身是一个构造函数，用来生成 Set 数据结构。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ary = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">131</span>, <span class="number">312</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">131</span>])</span><br><span class="line"><span class="built_in">console</span>.log(ary)</span><br><span class="line"><span class="comment">//[1,2,131,312]</span></span><br></pre></td></tr></table></figure><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p><code>size</code>  返回Set实例的成员总数</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><code>add()</code>   向set数据内添加一个成员，返回数据本身<br><code>delete()</code>   删除某个值，返回一个布尔值<br><code>has()</code>   查看该值是否为Set的成员，返回一个布尔值<br><code>clear()</code>   清除所有成员</p><h3 id="如何将-set-数据转化成数组："><a href="#如何将-set-数据转化成数组：" class="headerlink" title="如何将 set 数据转化成数组："></a>如何将 set 数据转化成数组：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([...ary])</span><br></pre></td></tr></table></figure><h3 id="实现数组去重"><a href="#实现数组去重" class="headerlink" title="实现数组去重"></a>实现数组去重</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newArr = [<span class="number">1</span>, <span class="number">1231</span>, <span class="number">23</span>, <span class="number">12</span>, <span class="number">31</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">12</span>, <span class="number">31</span>, <span class="number">23</span>, <span class="number">12</span>]</span><br><span class="line"><span class="built_in">console</span>.log([...new <span class="built_in">Set</span>(newArr)])</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：可以使用Set实现搜索历史记录的展示</p><h3 id="Set-结构的实例有四个遍历方法，可以用于遍历成员。"><a href="#Set-结构的实例有四个遍历方法，可以用于遍历成员。" class="headerlink" title="Set 结构的实例有四个遍历方法，可以用于遍历成员。"></a>Set 结构的实例有四个遍历方法，可以用于遍历成员。</h3><ul><li>Set.prototype.keys()：返回键名的遍历器</li><li>Set.prototype.values()：返回键值的遍历器</li><li>Set.prototype.entries()：返回键值对的遍历器</li><li>Set.prototype.forEach()：使用回调函数遍历每个成员</li></ul><p>还有一个额外的 WeakSet 数据结构，内部成员只能是对象类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> 因为是对象类型，所以地址相等，才是重复</span><br><span class="line"> <span class="keyword">const</span> ary1 = <span class="keyword">new</span> <span class="built_in">WeakSet</span>([<span class="number">1</span>, <span class="number">2</span>],[<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"> <span class="built_in">console</span>.log(ary1)</span><br><span class="line"><span class="comment">//[1,2][1,2]</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"> <span class="keyword">const</span> ary1 = <span class="keyword">new</span> <span class="built_in">WeakSet</span>([arr, arr])</span><br><span class="line"> <span class="built_in">console</span>.log(ary1)</span><br><span class="line"><span class="comment">//[1,2]</span></span><br></pre></td></tr></table></figure><h2 id="class-类的基本语法"><a href="#class-类的基本语法" class="headerlink" title="class 类的基本语法"></a>class 类的基本语法</h2><p>类的花括号内默认一般只写方法，而且方法之间不需要逗号</p><p>constructor 是 class 自带函数，该函数被称作构造器，和以前的构造函数类似</p><p>constructor 函数当创建实例化类的时候自动触发，除了 constructor 函数之外定义的函数都相当于原来的 prototype 内的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  say = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我是王者荣耀的英雄&#x27;</span> + <span class="built_in">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> Hero(<span class="string">&#x27;牛&#x27;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> Hero(<span class="string">&#x27;小乔&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="built_in">console</span>.log(b)</span><br><span class="line">a.say()</span><br></pre></td></tr></table></figure><h3 id="class的继承"><a href="#class的继承" class="headerlink" title="class的继承"></a>class的继承</h3><p>Class 可以通过<code>extends</code>关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarryHero</span> <span class="keyword">extends</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name, age)</span><br><span class="line">    <span class="comment">// super 调用了才真正实现了继承</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> CarryHero(<span class="string">&#x27;赵云&#x27;</span>, <span class="number">19</span>)</span><br><span class="line"><span class="built_in">console</span>.log(c)</span><br></pre></td></tr></table></figure><h2 id="module"><a href="#module" class="headerlink" title="module"></a>module</h2><h3 id="模块的导出"><a href="#模块的导出" class="headerlink" title="模块的导出"></a>模块的导出</h3><p>默认导出和命名导出可以同时存在。</p><h4 id="1、命名导出"><a href="#1、命名导出" class="headerlink" title="1、命名导出"></a>1、命名导出</h4><p>命名导出可以使用多次</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1008</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">export</span>&#123; a &#125;;</span><br><span class="line"><span class="keyword">export</span>&#123; b &#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>导出多个使用花括号，中间用逗号隔开即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; a，b &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> school =<span class="string">&quot;实验&#x27;;</span></span><br><span class="line"><span class="string">function findob(&#123;</span></span><br><span class="line"><span class="string">console.log(&quot;</span>我们可以帮助你找工作!!<span class="string">&quot;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">export &#123;school，findob&#125;;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><h4 id="2、默认导出"><a href="#2、默认导出" class="headerlink" title="2、默认导出"></a>2、默认导出</h4><p>默认导出只能使用一次</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1008</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">school: <span class="string">&#x27;实验&#x27;</span>,</span><br><span class="line">change: <span class="function"><span class="keyword">function</span>(<span class="params">i</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="built_in">console</span>.log(<span class="string">&quot;我们可以改变你!!&quot;</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span></span></span><br></pre></td></tr></table></figure><h3 id="模块的导入"><a href="#模块的导入" class="headerlink" title="模块的导入"></a>模块的导入</h3><p>模块路径第三方和核心模块直接写包名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">&quot;jquery&quot;</span>;</span><br><span class="line"><span class="comment">//导入jQuery</span></span><br></pre></td></tr></table></figure><h4 id="1、命名导入"><a href="#1、命名导入" class="headerlink" title="1、命名导入"></a>1、命名导入</h4><p>命名导入的名称必须和导出的名称一致，但是可以使用as换名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;a,b <span class="keyword">as</span> x&#125; <span class="keyword">from</span> <span class="string">&quot;./about&quot;</span>;</span><br></pre></td></tr></table></figure><h4 id="2、默认导入"><a href="#2、默认导入" class="headerlink" title="2、默认导入"></a>2、默认导入</h4><p>默认导入，导入的名称可以和导出的名称不一致</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> x <span class="keyword">from</span> <span class="string">&#x27;./about&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> xxx，&#123; a <span class="keyword">as</span> x,b &#125;<span class="keyword">from</span> <span class="string">&quot;./about&quot;</span>;</span><br></pre></td></tr></table></figure><h4 id="3、全部导入"><a href="#3、全部导入" class="headerlink" title="3、全部导入"></a>3、全部导入</h4><p>全部导入，会将该js文件内的所有导出的变量全部导入，可以采用<code>obj.变量名</code>的形式读取值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> obj <span class="keyword">from</span> <span class="string">&quot;./about&quot;</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue组件间通信</title>
      <link href="posts/40442/"/>
      <url>posts/40442/</url>
      
        <content type="html"><![CDATA[<h1 id="vue组件间通信"><a href="#vue组件间通信" class="headerlink" title="vue组件间通信"></a>vue组件间通信</h1><p>对于vue来说，组件之间的通信是非常重要的，下面我对vue组件间的通信做了总结。</p><h2 id="一、props-emit"><a href="#一、props-emit" class="headerlink" title="一、props/$emit"></a>一、props/$emit</h2><h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><p>父组件通过指令<code>v-bind</code>(可以简写为<code>:</code>)向子组件传递一个值，子组件通过props接收，在子组件内可以直接使用。</p><p><strong>父组件内</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Son :num&#x3D;&quot;num&quot;&gt;&lt;&#x2F;Son&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Son from &quot;.&#x2F;Son&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Parent&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Son,</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      num: 100,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><strong>子组件内</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">  &lt;div&gt;子组件的data：&#123;&#123; num &#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Son&quot;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    num: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="emit"><a href="#emit" class="headerlink" title="$emit"></a>$emit</h3><p>子组件想要修改父组件data的值时，如果直接在子组件内修改，就会报错，这时我们可以通过在父组件内定义好一个方法，通过指令<code>v-on</code>(可以简写为<code>@</code>)传给子组件，子组件传参进行修改</p><p><strong>父组件内</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">  &lt;Son @change-num&#x3D;&quot;changeNum&quot;&gt;&lt;&#x2F;Son&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Son from &quot;.&#x2F;Son&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Parent&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Son,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    changeNum(num) &#123;</span><br><span class="line">      this.num &#x3D; num;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><strong>子组件内</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;$emit(&#39;change-num&#39;, 99)&quot;&gt;修改&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><p>除了在这里使用<code>$emit</code>接收之外，如果还要进行其他的操作，可以写在js内</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;handleClick&quot;&gt;修改&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default&#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleClick() &#123;</span><br><span class="line">      &#x2F;&#x2F; 接收父组件传递过来的函数并调用,传参的方式可以在父组件内直接传递，也可以在子组件内传递</span><br><span class="line">        this.$emit(&#39;change-num&#39;, 99)</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>以上这种形式，我们使用下面这样方法也是一样的。</p><p><strong>父组件内</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">      &lt;Son :num&#x3D;&quot;num&quot; @update:num&#x3D;&quot;num&#x3D;$event&quot;&gt;&lt;&#x2F;Son&gt;</span><br><span class="line">      &#x2F;&#x2F;以上可以直接使用&#39;.sync&#39;进行简化</span><br><span class="line">      &lt;Son :num.sync&#x3D;&quot;num&quot;&gt;&lt;&#x2F;Son&gt;</span><br><span class="line">      &#x2F;&#x2F;如果传过去的是一个对象，那么就是将obj内的属性全都传递给了子组件，并且每个属性都有.sync功能，</span><br><span class="line">      &lt;Son v-bind.sync&#x3D;&quot;obj&quot;&gt;&lt;&#x2F;Son&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Son from &quot;.&#x2F;Son&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Parent&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Son,</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      num: 100,</span><br><span class="line">      obj: &#123;</span><br><span class="line">        num1: 100,</span><br><span class="line">        num2: 100,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><strong>子组件内</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;$emit(&#39;update:num&#39;, 99)&quot;&gt;修改&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;$emit(&#39;update:num1&#39;, 99)&quot;&gt;修改&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Son&quot;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    num: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">    &#125;,</span><br><span class="line">    num1: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h2 id="二、v-model"><a href="#二、v-model" class="headerlink" title="二、v-model"></a>二、v-model</h2><p>父组件通过<code>v-model</code>传递值给子组件时，会自动传递一个value的prop属性，在子组件中通过this.$emit(‘input’,val)自动修改v-model绑定的值</p><p><strong>父组件内</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Son v-model&#x3D;&quot;num&quot;&gt;&lt;&#x2F;Son&gt;</span><br><span class="line">&#x2F;&#x2F;v-model其实就相当于通过以下这种方式向子组件传递</span><br><span class="line">&lt;Son :value&#x3D;&quot;num&quot; @input&#x3D;&quot;changeNum&quot;&gt;&lt;&#x2F;Son&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Son from &quot;.&#x2F;Son&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Parent&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Son,</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      num: 100,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><strong>子组件内</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;$emit(&#39;input&#39;, 999)&quot;&gt;修改&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Son&quot;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    value: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h2 id="三、provide和inject"><a href="#三、provide和inject" class="headerlink" title="三、provide和inject"></a>三、provide和inject</h2><p>在 Vue.js 的 <code>2.2.0+</code> 版本中新添加<code>provide</code>和<code>inject</code>选项。他们成对出现，用于父级组件向下传递数据。</p><p>父组件中通过provider来提供变量，然后在子组件中通过inject来注入变量。不论子组件有多深，只要调用了inject，那么就可以注入provider中的数据。</p><p><code>provide</code>提供的数据是不可响应的，如果想提供响应的数据，可以使用<code>Vue.observable</code></p><p>当提供的数据并不是data里的死数据，需要在create 或者是 mounted 生命周期里获取的，直接提供是不行的，不会响应变化，此时可以在父组件内提供一个方法，该方法返回需要的数据，然后将此方法当做provide提供的值</p><p><strong>父组件内</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import Son1 from &quot;.&#x2F;Son1&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Parent1&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Son1,</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      obj: null,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      this.obj &#x3D; &#123; name: &quot;小红&quot;, age: 10 &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  provide() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      x: this.getObj,</span><br><span class="line">      &#x2F;&#x2F;可以将值直接写成一个函数：x: () &#x3D;&gt; this.obj,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">  getObj() &#123;</span><br><span class="line">  return this.obj;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><strong>子组件内</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;子组件的data：&#123;&#123; $parent.num &#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div&gt;使用父组件provide的数据：&#123;&#123; x() &#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Son1&quot;,</span><br><span class="line">  inject: [&quot;x&quot;],</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h2 id="四、-attrs和-listeners"><a href="#四、-attrs和-listeners" class="headerlink" title="四、$attrs和$listeners"></a>四、$attrs和$listeners</h2><p>第一种方式处理父子组件之间的数据传输有一个问题：如果父组件A下面有子组件B，组件B下面有组件C,这时如果组件A想传递数据给组件C怎么办呢？ 如果采用第一种方法，我们必须让组件A通过prop传递消息给组件B，组件B在通过prop传递消息给组件C；要是组件A和组件C之间有更多的组件，那采用这种方式就很复杂了。Vue 2.4开始提供了$attrs和$listeners来解决这个问题，能够让组件A之间传递消息给组件C。</p><p><strong>A组件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Parent2 :a&#x3D;&quot;10&quot; :obj&#x3D;&quot;&#123; naem: &#39;小花儿&#39; &#125;&quot; @x&#x3D;&quot;() &#x3D;&gt; console.log(1)&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p><strong>B组件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Son2 v-bind&#x3D;&quot;$attrs&quot; v-on&#x3D;&quot;$listeners&quot;&gt;&lt;&#x2F;Son2&gt;</span><br></pre></td></tr></table></figure><p><strong>C组件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Son2&quot;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    console.log(this.$attrs, this.$listeners);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h2 id="五-parent和-children"><a href="#五-parent和-children" class="headerlink" title="五$parent和$children"></a>五$parent和$children</h2><p>在组件内部可以直接通过子组件<code>$parent</code>对父组件进行操作，父组件通过<code>$children</code>对子组件进行操作。</p><p><strong>子组件内使用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&#123;&#123; $parent.num &#125;&#125;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p><strong>父组件内使用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&#123;&#123; $children.num &#125;&#125;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><h2 id="六、vuex"><a href="#六、vuex" class="headerlink" title="六、vuex"></a>六、vuex</h2><p>如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候才有上面这一些方法可能不利于项目的维护，vuex的做法就是将这一些公共的数据抽离出来，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的。</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL注入 </tag>
            
            <tag> DDOS </tag>
            
            <tag> SYN </tag>
            
            <tag> 组件通信 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
